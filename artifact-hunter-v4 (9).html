<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Artifact Hunter - Oakland</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #1a1a2e;
      color: #eee;
      overflow: hidden;
      height: 100vh;
      height: 100dvh;
    }
    #app { height: 100%; display: flex; flex-direction: column; }
    
    .header {
      background: linear-gradient(135deg, #2d1b0e 0%, #1a1a2e 100%);
      padding: 10px 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 2px solid #c9a227;
      z-index: 1000;
    }
    .header h1 { font-size: 1.1rem; color: #c9a227; }
    .demo-badge {
      background: #c9a227;
      color: #1a1a2e;
      padding: 2px 8px;
      border-radius: 10px;
      font-size: 0.7rem;
      font-weight: bold;
      margin-left: 8px;
    }
    .header-stats { display: flex; gap: 12px; font-size: 0.8rem; align-items: center; }
    .level-badge {
      background: linear-gradient(135deg, #c9a227, #a68523);
      color: #1a1a2e;
      padding: 4px 10px;
      border-radius: 12px;
      font-weight: bold;
      font-size: 0.75rem;
    }
    .xp-bar-container { width: 80px; height: 8px; background: #333; border-radius: 4px; overflow: hidden; }
    .xp-bar { height: 100%; background: linear-gradient(90deg, #c9a227, #f0d878); transition: width 0.5s ease; }
    
    #map { flex: 1; z-index: 1; cursor: crosshair; }
    
    .instructions {
      background: rgba(201, 162, 39, 0.15);
      border-bottom: 1px solid #c9a227;
      padding: 6px 16px;
      text-align: center;
      font-size: 0.8rem;
      color: #c9a227;
    }
    
    .bottom-nav {
      background: linear-gradient(135deg, #2d1b0e 0%, #1a1a2e 100%);
      padding: 10px;
      display: flex;
      justify-content: space-around;
      border-top: 2px solid #c9a227;
      z-index: 1000;
    }
    .nav-btn {
      background: rgba(201, 162, 39, 0.2);
      border: 2px solid #c9a227;
      color: #c9a227;
      padding: 8px 14px;
      border-radius: 25px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.3s;
    }
    .nav-btn:hover, .nav-btn.active {
      background: #c9a227;
      color: #1a1a2e;
    }
    
    .modal-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.9);
      z-index: 2000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    .modal {
      background: linear-gradient(135deg, #2d1b0e 0%, #1a1a2e 100%);
      border: 2px solid #c9a227;
      border-radius: 16px;
      width: 100%;
      max-width: 500px;
      max-height: 85vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    .modal-header {
      padding: 14px 16px;
      border-bottom: 1px solid #c9a227;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .modal-header h2 { color: #c9a227; font-size: 1.1rem; }
    .close-btn { background: none; border: none; color: #c9a227; font-size: 1.5rem; cursor: pointer; }
    .modal-body { padding: 16px; overflow-y: auto; flex: 1; }
    .modal-body h3 { color: #c9a227; margin: 16px 0 8px 0; font-size: 0.95rem; }
    .modal-body h3:first-child { margin-top: 0; }
    .modal-body p { line-height: 1.5; margin-bottom: 10px; color: #ccc; font-size: 0.9rem; }
    
    .collection-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      gap: 8px;
    }
    .artifact-card {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      padding: 10px 6px;
      text-align: center;
      border: 2px solid transparent;
      cursor: pointer;
      transition: all 0.3s;
    }
    .artifact-card:hover { border-color: #c9a227; transform: translateY(-2px); }
    .artifact-card.locked { opacity: 0.4; filter: grayscale(1); cursor: default; }
    .artifact-card .emoji { font-size: 2rem; margin-bottom: 4px; }
    .artifact-card .name { font-size: 0.7rem; font-weight: 600; margin-bottom: 4px; }
    .artifact-card .rarity { font-size: 0.6rem; padding: 2px 6px; border-radius: 8px; display: inline-block; }
    
    .rarity-common { background: #6b7280; }
    .rarity-uncommon { background: #047857; }
    .rarity-rare { background: #1d4ed8; }
    .rarity-epic { background: #7c3aed; }
    .rarity-legendary { background: linear-gradient(135deg, #b45309, #dc2626); }
    
    .achievements-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 10px;
    }
    .achievement-card {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      padding: 12px;
      text-align: center;
      border: 2px solid transparent;
    }
    .achievement-card.unlocked { border-color: #c9a227; background: rgba(201, 162, 39, 0.1); }
    .achievement-card.locked { opacity: 0.5; }
    .achievement-card .emoji { font-size: 2rem; margin-bottom: 6px; }
    .achievement-card .name { font-size: 0.8rem; font-weight: 600; color: #c9a227; }
    .achievement-card .desc { font-size: 0.7rem; color: #aaa; }
    
    .stats-panel {
      background: rgba(0,0,0,0.3);
      border-radius: 10px;
      padding: 12px;
      margin-bottom: 16px;
    }
    .stats-row { display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 0.85rem; }
    .stats-row:last-child { margin-bottom: 0; }
    .stats-label { color: #888; }
    .stats-value { color: #c9a227; font-weight: 600; }
    
    .artifact-popup { text-align: center; padding: 6px; min-width: 140px; }
    .artifact-popup .emoji { font-size: 2.2rem; }
    .artifact-popup .name { font-weight: 600; margin: 4px 0; font-size: 0.95rem; }
    .artifact-popup .buried-hint { font-size: 0.75rem; color: #a08060; font-style: italic; }
    .artifact-popup .distance { font-size: 0.75rem; color: #888; margin: 4px 0; }
    .collect-btn {
      background: linear-gradient(135deg, #c9a227, #a68523);
      color: #1a1a2e;
      border: none;
      padding: 8px 16px;
      border-radius: 20px;
      margin-top: 6px;
      cursor: pointer;
      font-weight: 700;
      width: 100%;
      font-size: 0.85rem;
    }
    .collect-btn:hover { transform: scale(1.05); }
    .collect-btn:disabled { background: #444; color: #888; cursor: not-allowed; transform: none; }
    
    /* Cleaning */
    .cleaning-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(15, 12, 8, 0.98);
      z-index: 3000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
      animation: fadeIn 0.3s ease-out;
    }
    .cleaning-title { color: #c9a227; font-size: 1.2rem; margin-bottom: 10px; }
    .cleaning-instructions { color: #aaa; font-size: 0.85rem; margin-bottom: 20px; }
    .cleaning-area {
      position: relative;
      width: 280px;
      height: 280px;
      background: linear-gradient(145deg, #C4A77D, #A08060);
      border-radius: 20px;
      overflow: hidden;
      cursor: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><text y="20" font-size="20">üñåÔ∏è</text></svg>') 16 16, pointer;
      touch-action: none;
    }
    #dirtCanvas { 
      position: absolute; 
      top: 0; 
      left: 0; 
      width: 100%; 
      height: 100%; 
      border-radius: 20px; 
      z-index: 2;
    }
    .artifact-reveal { 
      position: absolute; 
      top: 50%; 
      left: 50%; 
      transform: translate(-50%, -50%); 
      font-size: 5rem; 
      z-index: 1;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    .cleaning-progress { width: 280px; height: 12px; background: #333; border-radius: 6px; margin-top: 20px; overflow: hidden; }
    .cleaning-progress-bar { height: 100%; background: linear-gradient(90deg, #c9a227, #f0d878); transition: width 0.1s; }
    .cleaning-progress-label { color: #888; font-size: 0.8rem; margin-top: 8px; }
    
    /* Cutscene */
    .cutscene-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: linear-gradient(180deg, #0a0a0a 0%, #1a1a2e 100%);
      z-index: 3500;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
      animation: fadeIn 0.5s ease-out;
    }
    .cutscene-title { 
      color: #c9a227; 
      font-size: 0.9rem; 
      text-transform: uppercase; 
      letter-spacing: 3px; 
      margin-bottom: 15px; 
      opacity: 0.9;
      text-shadow: 0 0 10px rgba(201, 162, 39, 0.5);
    }
    #cutsceneCanvas { 
      border-radius: 16px; 
      background: linear-gradient(180deg, #87CEEB 0%, #90EE90 60%, #228B22 100%); 
      box-shadow: 0 4px 30px rgba(0,0,0,0.6), 0 0 60px rgba(201, 162, 39, 0.2);
      border: 2px solid rgba(201, 162, 39, 0.3);
    }
    .cutscene-caption {
      color: #fff;
      font-size: 1rem;
      margin-top: 20px;
      max-width: 350px;
      text-align: center;
      line-height: 1.6;
      font-style: italic;
      text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
    }
    .cutscene-skip { 
      color: #666; 
      font-size: 0.8rem; 
      margin-top: 20px;
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }
    
    /* Found overlay */
    .found-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.95);
      z-index: 3000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
      overflow-y: auto;
      animation: fadeIn 0.3s ease-out;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    .found-overlay .emoji { font-size: 4rem; animation: bounce 0.6s ease-out; }
    @keyframes bounce {
      0% { transform: scale(0) rotate(-10deg); }
      50% { transform: scale(1.3) rotate(5deg); }
      100% { transform: scale(1) rotate(0deg); }
    }
    .found-overlay h2 { color: #c9a227; margin: 10px 0 6px; font-size: 1rem; text-transform: uppercase; letter-spacing: 3px; }
    .found-overlay .artifact-name { font-size: 1.3rem; font-weight: 700; margin-bottom: 6px; }
    .found-overlay .rarity-badge { padding: 4px 14px; border-radius: 20px; font-size: 0.75rem; font-weight: 600; margin-bottom: 8px; }
    .found-overlay .xp-earned { font-size: 1.4rem; color: #c9a227; font-weight: bold; margin-bottom: 12px; }
    .found-overlay .description { color: #ccc; max-width: 300px; text-align: center; margin-bottom: 12px; line-height: 1.4; font-size: 0.85rem; }
    .found-overlay .cultural-note { background: rgba(201, 162, 39, 0.1); border: 1px solid #c9a227; border-radius: 10px; padding: 10px 14px; max-width: 300px; margin-bottom: 16px; }
    .found-overlay .cultural-note h4 { color: #c9a227; font-size: 0.75rem; margin-bottom: 4px; }
    .found-overlay .cultural-note p { font-size: 0.8rem; color: #ccc; line-height: 1.4; }
    .minigame-unlock { background: rgba(100, 50, 200, 0.2); border: 1px solid #8b5cf6; border-radius: 10px; padding: 10px 14px; max-width: 300px; margin-bottom: 16px; text-align: center; }
    .minigame-unlock h4 { color: #8b5cf6; font-size: 0.8rem; margin-bottom: 4px; }
    .minigame-unlock p { font-size: 0.75rem; color: #aaa; }
    
    /* Level up */
    .levelup-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.95);
      z-index: 4000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .levelup-overlay h1 { font-size: 2.5rem; color: #c9a227; animation: levelPulse 0.5s ease-out; }
    @keyframes levelPulse { 0% { transform: scale(0); } 50% { transform: scale(1.2); } 100% { transform: scale(1); } }
    .levelup-overlay .level-num { font-size: 4rem; font-weight: bold; color: #fff; margin: 16px 0; }
    .levelup-overlay .reward { color: #aaa; font-size: 1rem; margin-bottom: 24px; }
    
    /* Mini-games */
    .minigame-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(10, 10, 10, 0.98);
      z-index: 3000;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      overflow-y: auto;
    }
    .minigame-header { text-align: center; margin-bottom: 15px; }
    .minigame-header h2 { color: #c9a227; font-size: 1.2rem; margin-bottom: 5px; }
    .minigame-header p { color: #888; font-size: 0.8rem; }
    .minigame-score { 
      font-size: 2.5rem; 
      color: #c9a227; 
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
      background: rgba(0,0,0,0.3);
      padding: 5px 20px;
      border-radius: 10px;
    }
    .minigame-timer { 
      font-size: 1.1rem; 
      color: #fff; 
      margin-bottom: 15px;
      background: rgba(0,0,0,0.3);
      padding: 4px 12px;
      border-radius: 8px;
    }
    .game-canvas-container { 
      position: relative; 
      border-radius: 12px; 
      overflow: hidden;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
      border: 2px solid #c9a227;
    }
    #gameCanvas { 
      display: block; 
      border-radius: 10px;
      background: linear-gradient(180deg, #87CEEB 0%, #7CB342 100%);
    }
    .game-instructions { color: #aaa; font-size: 0.8rem; margin-top: 15px; text-align: center; max-width: 300px; }
    
    .leaderboard { width: 100%; max-width: 350px; margin-top: 20px; }
    .leaderboard h3 { color: #c9a227; font-size: 1rem; margin-bottom: 10px; text-align: center; }
    .leaderboard-entry { display: flex; justify-content: space-between; padding: 8px 12px; background: rgba(255,255,255,0.05); border-radius: 8px; margin-bottom: 6px; font-size: 0.85rem; }
    .leaderboard-entry.you { background: rgba(201, 162, 39, 0.2); border: 1px solid #c9a227; }
    .leaderboard-rank { color: #c9a227; font-weight: bold; width: 30px; }
    .leaderboard-name { flex: 1; color: #ccc; }
    .leaderboard-score { color: #fff; font-weight: bold; }
    
    .minigame-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 12px; }
    .minigame-card {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      padding: 16px;
      text-align: center;
      border: 2px solid transparent;
      cursor: pointer;
      transition: all 0.3s;
    }
    .minigame-card:hover { border-color: #c9a227; transform: translateY(-2px); }
    .minigame-card.locked { opacity: 0.4; cursor: not-allowed; }
    .minigame-card .emoji { font-size: 2.5rem; margin-bottom: 8px; }
    .minigame-card .name { font-size: 0.85rem; font-weight: 600; color: #c9a227; }
    .minigame-card .high-score { font-size: 0.75rem; color: #888; }
    
    /* Map markers */
    .player-marker { 
      width: 24px; 
      height: 24px; 
      background: #c9a227; 
      border: 3px solid #fff; 
      border-radius: 50%; 
      box-shadow: 0 0 20px rgba(201, 162, 39, 0.8);
      transition: transform 0.15s ease-out;
    }
    .player-marker-container {
      transition: transform 0.15s ease-out;
    }
    .player-pulse { position: absolute; width: 70px; height: 70px; background: rgba(201, 162, 39, 0.25); border-radius: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%); animation: pulse-ring 2s infinite; }
    @keyframes pulse-ring { 0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; } }
    .artifact-marker { font-size: 36px; filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.5)); cursor: pointer; padding: 10px; margin: -10px; }
    .artifact-marker:hover { transform: scale(1.3); }
    .artifact-marker.nearby { animation: artifact-glow 1.5s ease-in-out infinite; }
    @keyframes artifact-glow { 0%, 100% { filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.5)); } 50% { filter: drop-shadow(0 0 15px rgba(201, 162, 39, 0.9)); } }
    .leaflet-popup-content-wrapper { border-radius: 12px; }
    
    .key-hint {
      position: absolute;
      bottom: 75px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.85);
      padding: 6px 14px;
      border-radius: 15px;
      font-size: 0.7rem;
      color: #aaa;
      z-index: 1000;
    }
    .key-hint kbd { background: #444; padding: 2px 6px; border-radius: 3px; margin: 0 2px; }
  </style>
</head>
<body>
  <div id="app"></div>

  <script>
    // ============================================
    // ARTIFACT DATA
    // ============================================
    const ARTIFACT_TYPES = [
      // TOOLS
      { 
        emoji: '‚¨õ', name: 'Obsidian Arrowhead', category: 'tools', rarity: 'common', xp: 10,
        description: 'A finely knapped obsidian point used for hunting deer and elk.',
        culturalNote: 'Ohlone hunters crafted these from volcanic glass traded from the North Bay.',
        cutscene: 'bow_hunt',
        minigame: 'bow_hunt'
      },
      { 
        emoji: 'üìê', name: 'Chert Point', category: 'tools', rarity: 'common', xp: 10,
        description: 'A tan-colored stone point for hunting small game.',
        culturalNote: 'Chert was found locally in creek beds and used for everyday tools.',
        cutscene: 'bow_hunt',
        minigame: 'bow_hunt'
      },
      { 
        emoji: 'ü™®', name: 'Chert Scraper', category: 'tools', rarity: 'common', xp: 10,
        description: 'A stone tool used for preparing animal hides.',
        culturalNote: 'These scrapers were essential for making clothing from deer hide.',
        cutscene: 'scraping'
      },
      { 
        emoji: 'ü¶¥', name: 'Bone Awl', category: 'tools', rarity: 'uncommon', xp: 25,
        description: 'A pointed bone tool for basket-making and leatherwork.',
        culturalNote: 'Awls were made from deer leg bones for weaving baskets.',
        cutscene: 'weaving',
        minigame: 'weaving'
      },
      { 
        emoji: 'ü™°', name: 'Bone Needle', category: 'tools', rarity: 'uncommon', xp: 25,
        description: 'A delicate sewing needle carved from bird bone.',
        culturalNote: 'Used to sew rabbit skin blankets with plant fiber thread.',
        cutscene: 'weaving',
        minigame: 'weaving'
      },
      { 
        emoji: 'ü™ì', name: 'Grooved Stone Axe', category: 'tools', rarity: 'rare', xp: 50,
        description: 'A heavy stone axe for felling trees.',
        culturalNote: 'These axes took hours to shape and were used for building.',
        cutscene: 'chopping'
      },
      { 
        emoji: 'üî®', name: 'Hammerstone', category: 'tools', rarity: 'common', xp: 10,
        description: 'A rounded stone used for knapping flint.',
        culturalNote: 'Every family had several hammerstones for toolmaking.',
        cutscene: 'knapping',
        minigame: 'knapping'
      },
      { 
        emoji: 'üó°Ô∏è', name: 'Obsidian Blade', category: 'tools', rarity: 'epic', xp: 100,
        description: 'A large ceremonial blade of exceptional craftsmanship.',
        culturalNote: 'Master knappers created these prestige items.',
        cutscene: 'knapping',
        minigame: 'knapping'
      },
      { 
        emoji: 'ü™ù', name: 'Bone Fish Hook', category: 'tools', rarity: 'uncommon', xp: 25,
        description: 'A curved hook for catching fish.',
        culturalNote: 'The Ohlone fished the creeks and bay for salmon and sturgeon.',
        cutscene: 'fishing',
        minigame: 'fishing'
      },
      { 
        emoji: 'üèπ', name: 'Sinew-Backed Bow', category: 'tools', rarity: 'epic', xp: 100,
        description: 'A powerful hunting bow reinforced with deer sinew.',
        culturalNote: 'These bows took weeks to make and prevented breaking.',
        cutscene: 'bow_hunt',
        minigame: 'bow_hunt'
      },
      
      // FOOD
      { 
        emoji: 'üï≥Ô∏è', name: 'Stone Mortar', category: 'food', rarity: 'common', xp: 10,
        description: 'A bowl-shaped grinding stone worn smooth by use.',
        culturalNote: 'Ohlone families ground acorns in these mortars daily.',
        cutscene: 'grinding',
        minigame: 'grinding'
      },
      { 
        emoji: 'ü•¢', name: 'Pestle', category: 'food', rarity: 'common', xp: 10,
        description: 'A cylindrical stone used to pound acorns.',
        culturalNote: 'Pestles were passed down through generations.',
        cutscene: 'grinding',
        minigame: 'grinding'
      },
      { 
        emoji: 'ü™∫', name: 'Acorn Granary Fragment', category: 'food', rarity: 'uncommon', xp: 25,
        description: 'Woven twigs from an acorn storage structure.',
        culturalNote: 'Families stored 500+ pounds of acorns for winter.',
        cutscene: 'gathering'
      },
      { 
        emoji: '‚ô®Ô∏è', name: 'Cooking Stone', category: 'food', rarity: 'uncommon', xp: 25,
        description: 'A stone used to boil water in baskets.',
        culturalNote: 'Hot stones were dropped into baskets to cook food.',
        cutscene: 'cooking'
      },
      { 
        emoji: 'üå∞', name: 'Acorn Cache', category: 'food', rarity: 'common', xp: 10,
        description: 'Preserved acorns from Valley Oaks.',
        culturalNote: 'Acorns were the main food source for the Ohlone.',
        cutscene: 'gathering',
        minigame: 'grinding'
      },
      { 
        emoji: '‚≠ê', name: 'Decorated Mortar', category: 'food', rarity: 'legendary', xp: 200,
        description: 'A rare ceremonial mortar with shell inlay.',
        culturalNote: 'Only a few have ever been found in the Bay Area.',
        cutscene: 'grinding'
      },
      
      // SHELLS
      { 
        emoji: 'üêö', name: 'Olivella Shell Bead', category: 'shells', rarity: 'common', xp: 10,
        description: 'A small shell bead used as currency.',
        culturalNote: 'These shells were California\'s money.',
        cutscene: 'trading'
      },
      { 
        emoji: 'üìø', name: 'Shell Bead Necklace', category: 'shells', rarity: 'uncommon', xp: 25,
        description: 'A strand of carefully matched shell beads.',
        culturalNote: 'Each bead was ground and drilled by hand.',
        cutscene: 'trading'
      },
      { 
        emoji: 'ü¶™', name: 'Abalone Pendant', category: 'shells', rarity: 'rare', xp: 50,
        description: 'An iridescent ornament from abalone shell.',
        culturalNote: 'Chiefs wore these as symbols of power.',
        cutscene: 'ceremony'
      },
      { 
        emoji: 'üëë', name: 'Abalone Crown', category: 'shells', rarity: 'legendary', xp: 200,
        description: 'A magnificent headpiece with abalone and feathers.',
        culturalNote: 'Worn only during the most sacred ceremonies.',
        cutscene: 'ceremony'
      },
      
      // BASKETRY
      { 
        emoji: 'üß∫', name: 'Twined Basket Fragment', category: 'basketry', rarity: 'common', xp: 10,
        description: 'A piece of basket woven from willow.',
        culturalNote: 'Baskets served as pots, plates, and even boats!',
        cutscene: 'weaving',
        minigame: 'weaving'
      },
      { 
        emoji: 'üåø', name: 'Tule Mat', category: 'basketry', rarity: 'common', xp: 10,
        description: 'Woven tule reeds for bedding.',
        culturalNote: 'Tule grew abundantly in Bay Area marshes.',
        cutscene: 'weaving',
        minigame: 'weaving'
      },
      { 
        emoji: 'üèµÔ∏è', name: 'Coiled Gift Basket', category: 'basketry', rarity: 'rare', xp: 50,
        description: 'A finely coiled basket with patterns.',
        culturalNote: 'Gift baskets could hold water‚Äî60 stitches per inch!',
        cutscene: 'weaving',
        minigame: 'weaving'
      },
      { 
        emoji: 'ü™∂', name: 'Feathered Ceremony Basket', category: 'basketry', rarity: 'legendary', xp: 200,
        description: 'A basket with woodpecker and quail feathers.',
        culturalNote: 'These treasures took months to create.',
        cutscene: 'weaving'
      },
      
      // CEREMONIAL
      { 
        emoji: 'ü¶Ö', name: 'Eagle Feather', category: 'ceremonial', rarity: 'rare', xp: 50,
        description: 'A sacred feather for ceremonies.',
        culturalNote: 'Eagles connected people to the sky world.',
        cutscene: 'ceremony'
      },
      { 
        emoji: 'üé∂', name: 'Elderberry Clapper', category: 'ceremonial', rarity: 'uncommon', xp: 25,
        description: 'A split-stick rhythm instrument.',
        culturalNote: 'Clappers drove the rhythm of dances.',
        cutscene: 'ceremony'
      },
      { 
        emoji: 'ü™à', name: 'Bone Whistle', category: 'ceremonial', rarity: 'rare', xp: 50,
        description: 'A whistle carved from bird bone.',
        culturalNote: 'Whistles called people to ceremony.',
        cutscene: 'ceremony'
      },
      { 
        emoji: 'üíé', name: 'Quartz Crystal', category: 'ceremonial', rarity: 'epic', xp: 100,
        description: 'A clear crystal for healing.',
        culturalNote: 'Shamans used crystals to see and heal illness.',
        cutscene: 'ceremony'
      },
      { 
        emoji: '‚ú®', name: 'Shaman\'s Bundle', category: 'ceremonial', rarity: 'legendary', xp: 200,
        description: 'A sacred bundle of spiritual objects.',
        culturalNote: 'These held immense spiritual significance.',
        cutscene: 'ceremony'
      },
    ];

    const RARITY_WEIGHTS = { common: 45, uncommon: 30, rare: 17, epic: 6, legendary: 2 };
    const XP_BY_RARITY = { common: 10, uncommon: 25, rare: 50, epic: 100, legendary: 200 };

    const LEVELS = [
      { level: 1, xpRequired: 0, title: 'Newcomer' },
      { level: 2, xpRequired: 50, title: 'Explorer' },
      { level: 3, xpRequired: 150, title: 'Seeker' },
      { level: 4, xpRequired: 300, title: 'Student' },
      { level: 5, xpRequired: 500, title: 'Researcher' },
      { level: 6, xpRequired: 800, title: 'Archaeologist' },
      { level: 7, xpRequired: 1200, title: 'Expert' },
      { level: 8, xpRequired: 1800, title: 'Scholar' },
      { level: 9, xpRequired: 2500, title: 'Master' },
      { level: 10, xpRequired: 3500, title: 'Historian' },
    ];

    const ACHIEVEMENTS = [
      { id: 'first_find', emoji: 'üéØ', name: 'First Discovery', desc: 'Collect your first artifact', check: (s) => s.collection.length >= 1 },
      { id: 'ten_artifacts', emoji: 'üì¶', name: 'Getting Started', desc: 'Collect 10 artifacts', check: (s) => s.collection.length >= 10 },
      { id: 'first_rare', emoji: 'üíé', name: 'Rare Find', desc: 'Find a rare artifact', check: (s) => s.collection.some(a => a.rarity === 'rare') },
      { id: 'first_legendary', emoji: '‚ú®', name: 'Legendary!', desc: 'Find a legendary artifact', check: (s) => s.collection.some(a => a.rarity === 'legendary') },
      { id: 'sharpshooter', emoji: 'üéØ', name: 'Sharpshooter', desc: 'Score 300+ in Bow Hunt', check: (s) => (s.highScores?.bow_hunt || 0) >= 300 },
      { id: 'master_weaver', emoji: 'üß∫', name: 'Master Weaver', desc: 'Score 400+ in Weaving', check: (s) => (s.highScores?.weaving || 0) >= 400 },
    ];

    const MINIGAMES = {
      bow_hunt: { name: 'Bow Hunting', emoji: 'üèπ', desc: 'Draw, aim, and release to hunt!' },
      fishing: { name: 'Fishing', emoji: 'üé£', desc: 'Cast, wait, and catch fish!' },
      grinding: { name: 'Acorn Grinding', emoji: 'üå∞', desc: 'Grind acorns into flour!' },
      weaving: { name: 'Basket Weaving', emoji: 'üß∫', desc: 'Follow the pattern!' },
      knapping: { name: 'Knapping', emoji: 'ü™®', desc: 'Shape obsidian into tools!' }
    };

    // ============================================
    // GAME STATE
    // ============================================
    let state = {
      playerPos: { lat: 37.8044, lon: -122.2712 },
      artifacts: [],
      collection: [],
      xp: 0,
      unlockedAchievements: [],
      unlockedMinigames: [],
      highScores: {},
      map: null,
      playerMarker: null,
      radiusCircle: null,
      artifactMarkers: [],
      showingModal: null,
      cleaningArtifact: null,
      showingCutscene: null,
      foundArtifact: null,
      showLevelUp: false,
      newLevel: null,
      playingMinigame: null,
      minigameScore: 0,
      minigameTimer: 0,
      minigameActive: false,
      zoomLevel: 17,
      // Game-specific state
      gameState: {}
    };

    const COLLECT_DISTANCE = 50;
    const SPAWN_RADIUS_MIN = 30;
    const SPAWN_RADIUS_MAX = 250;
    const ARTIFACT_COUNT = 12;

    // ============================================
    // UTILITIES
    // ============================================
    function getDistance(lat1, lon1, lat2, lon2) {
      const R = 6371e3;
      const œÜ1 = lat1 * Math.PI / 180, œÜ2 = lat2 * Math.PI / 180;
      const ŒîœÜ = (lat2 - lat1) * Math.PI / 180, ŒîŒª = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(ŒîœÜ/2)**2 + Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(ŒîŒª/2)**2;
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    }
    function formatDistance(m) { return m < 1000 ? `${Math.round(m)}m` : `${(m/1000).toFixed(1)}km`; }
    function randomInRange(min, max) { return Math.random() * (max - min) + min; }
    function pickRarity() {
      const total = Object.values(RARITY_WEIGHTS).reduce((a, b) => a + b, 0);
      let r = Math.random() * total;
      for (const [rarity, weight] of Object.entries(RARITY_WEIGHTS)) { r -= weight; if (r <= 0) return rarity; }
      return 'common';
    }
    function pickArtifactType() {
      const rarity = pickRarity();
      const options = ARTIFACT_TYPES.filter(a => a.rarity === rarity);
      return options[Math.floor(Math.random() * options.length)];
    }
    function spawnArtifactNear(lat, lon) {
      const angle = Math.random() * 2 * Math.PI;
      const distance = randomInRange(SPAWN_RADIUS_MIN, SPAWN_RADIUS_MAX);
      const latOff = (distance * Math.cos(angle)) / 111320;
      const lonOff = (distance * Math.sin(angle)) / (111320 * Math.cos(lat * Math.PI / 180));
      return { id: Date.now() + Math.random(), lat: lat + latOff, lon: lon + lonOff, ...pickArtifactType() };
    }
    function getLevelInfo(xp) {
      let cur = LEVELS[0];
      for (const l of LEVELS) { if (xp >= l.xpRequired) cur = l; else break; }
      const next = LEVELS.find(l => l.level === cur.level + 1);
      return { ...cur, nextLevel: next, xpForNext: next ? next.xpRequired - cur.xpRequired : 0, xpProgress: next ? xp - cur.xpRequired : 0 };
    }

    // ============================================
    // GAME LOGIC
    // ============================================
    function initArtifacts() {
      while (state.artifacts.length < ARTIFACT_COUNT) state.artifacts.push(spawnArtifactNear(state.playerPos.lat, state.playerPos.lon));
      updateArtifactMarkers();
    }

    function startCleaning(artifact) {
      state.cleaningArtifact = artifact;
      render();
    }

    function showCutscene(artifact) {
      state.cleaningArtifact = null;
      state.showingCutscene = artifact;
      render();
      setTimeout(() => startCutsceneAnimation(artifact), 100);
    }

    function completeCutscene() {
      const artifact = state.showingCutscene;
      if (!artifact) return; // Guard against double-calls
      
      state.showingCutscene = null;
      
      state.collection.push({ ...artifact, collectedAt: new Date().toISOString() });
      
      const xpGained = artifact.xp || XP_BY_RARITY[artifact.rarity];
      const oldLevel = getLevelInfo(state.xp).level;
      state.xp += xpGained;
      const newLevelInfo = getLevelInfo(state.xp);
      
      if (newLevelInfo.level > oldLevel) { state.showLevelUp = true; state.newLevel = newLevelInfo; }
      if (artifact.minigame && !state.unlockedMinigames.includes(artifact.minigame)) state.unlockedMinigames.push(artifact.minigame);
      
      checkAchievements();
      saveGame();
      state.artifacts = state.artifacts.filter(a => a.id !== artifact.id);
      state.foundArtifact = { ...artifact, xpGained };
      
      // Clean up map before re-render
      if (state.map) {
        state.map.remove();
        state.map = null;
      }
      
      render();
      
      // Spawn replacement artifact after a delay
      setTimeout(() => { 
        state.artifacts.push(spawnArtifactNear(state.playerPos.lat, state.playerPos.lon)); 
      }, 500);
    }

    function checkAchievements() {
      ACHIEVEMENTS.forEach(ach => {
        if (!state.unlockedAchievements.includes(ach.id) && ach.check(state)) state.unlockedAchievements.push(ach.id);
      });
    }

    function saveGame() {
      localStorage.setItem('artifactHunterV4', JSON.stringify({
        collection: state.collection, xp: state.xp,
        unlockedAchievements: state.unlockedAchievements,
        unlockedMinigames: state.unlockedMinigames,
        highScores: state.highScores
      }));
    }

    function loadGame() {
      const saved = localStorage.getItem('artifactHunterV4');
      if (saved) {
        const d = JSON.parse(saved);
        state.collection = d.collection || [];
        state.xp = d.xp || 0;
        state.unlockedAchievements = d.unlockedAchievements || [];
        state.unlockedMinigames = d.unlockedMinigames || [];
        state.highScores = d.highScores || {};
      }
    }

    // ============================================
    // CUTSCENE ANIMATIONS - DETAILED GRAPHICS
    // ============================================
    function startCutsceneAnimation(artifact) {
      const canvas = document.getElementById('cutsceneCanvas');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      const W = canvas.width, H = canvas.height;
      
      let frame = 0;
      const type = artifact.cutscene || 'generic';
      
      // Colors
      const SKIN = '#C68642';
      const SKIN_DARK = '#8D5524';
      const HAIR = '#2C1810';
      const CLOTH = '#8B7355';
      const CLOTH_DARK = '#6B5344';
      
      // Draw detailed person
      function drawPerson(x, y, scale = 1, pose = 'stand', facing = 1) {
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(facing * scale, scale);
        
        const s = 1; // Internal scale
        
        // Body/torso
        ctx.fillStyle = CLOTH;
        ctx.beginPath();
        ctx.ellipse(0, 0, 12 * s, 18 * s, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Cloth detail
        ctx.strokeStyle = CLOTH_DARK;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-8 * s, -10 * s);
        ctx.lineTo(-5 * s, 15 * s);
        ctx.moveTo(8 * s, -10 * s);
        ctx.lineTo(5 * s, 15 * s);
        ctx.stroke();
        
        // Head
        ctx.fillStyle = SKIN;
        ctx.beginPath();
        ctx.ellipse(0, -28 * s, 10 * s, 12 * s, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Hair
        ctx.fillStyle = HAIR;
        ctx.beginPath();
        ctx.ellipse(0, -35 * s, 11 * s, 8 * s, 0, Math.PI, Math.PI * 2);
        ctx.fill();
        // Hair sides
        ctx.fillRect(-11 * s, -35 * s, 4 * s, 20 * s);
        ctx.fillRect(7 * s, -35 * s, 4 * s, 20 * s);
        
        // Face
        ctx.fillStyle = '#1a1a1a';
        ctx.beginPath();
        ctx.arc(-4 * s, -30 * s, 1.5 * s, 0, Math.PI * 2); // Left eye
        ctx.arc(4 * s, -30 * s, 1.5 * s, 0, Math.PI * 2); // Right eye
        ctx.fill();
        
        // Arms based on pose
        ctx.fillStyle = SKIN;
        ctx.strokeStyle = SKIN;
        ctx.lineWidth = 6 * s;
        ctx.lineCap = 'round';
        
        if (pose === 'stand') {
          // Arms at sides
          ctx.beginPath();
          ctx.moveTo(-12 * s, -8 * s);
          ctx.lineTo(-15 * s, 20 * s);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(12 * s, -8 * s);
          ctx.lineTo(15 * s, 20 * s);
          ctx.stroke();
        } else if (pose === 'bow_draw') {
          // Left arm extended
          ctx.beginPath();
          ctx.moveTo(-12 * s, -8 * s);
          ctx.lineTo(-40 * s, -15 * s);
          ctx.stroke();
          // Right arm pulled back
          ctx.beginPath();
          ctx.moveTo(12 * s, -8 * s);
          ctx.lineTo(5 * s, -20 * s);
          ctx.stroke();
        } else if (pose === 'grind') {
          const armY = Math.sin(frame * 0.15) * 8;
          ctx.beginPath();
          ctx.moveTo(-12 * s, -8 * s);
          ctx.lineTo(-8 * s, 15 * s + armY);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(12 * s, -8 * s);
          ctx.lineTo(8 * s, 15 * s + armY);
          ctx.stroke();
        } else if (pose === 'weave') {
          const armX = Math.sin(frame * 0.1) * 15;
          ctx.beginPath();
          ctx.moveTo(-12 * s, -8 * s);
          ctx.lineTo(-20 * s + armX, 10 * s);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(12 * s, -8 * s);
          ctx.lineTo(20 * s - armX, 10 * s);
          ctx.stroke();
        } else if (pose === 'fish') {
          // Holding rod
          ctx.beginPath();
          ctx.moveTo(-12 * s, -8 * s);
          ctx.lineTo(-5 * s, 15 * s);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(12 * s, -8 * s);
          ctx.lineTo(25 * s, -25 * s);
          ctx.stroke();
        }
        
        // Legs
        ctx.fillStyle = SKIN_DARK;
        ctx.strokeStyle = SKIN_DARK;
        ctx.lineWidth = 7 * s;
        ctx.beginPath();
        ctx.moveTo(-6 * s, 15 * s);
        ctx.lineTo(-8 * s, 45 * s);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(6 * s, 15 * s);
        ctx.lineTo(8 * s, 45 * s);
        ctx.stroke();
        
        // Feet
        ctx.fillStyle = CLOTH_DARK;
        ctx.beginPath();
        ctx.ellipse(-8 * s, 48 * s, 6 * s, 4 * s, 0, 0, Math.PI * 2);
        ctx.ellipse(8 * s, 48 * s, 6 * s, 4 * s, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
      }
      
      // Draw detailed bow
      function drawBow(x, y, drawn = false, angle = 0) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        
        const curve = drawn ? 25 : 35;
        
        // Bow wood
        ctx.strokeStyle = '#5D4037';
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(0, -40);
        ctx.quadraticCurveTo(curve, 0, 0, 40);
        ctx.stroke();
        
        // Bow detail
        ctx.strokeStyle = '#8D6E63';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, -40);
        ctx.quadraticCurveTo(curve - 5, 0, 0, 40);
        ctx.stroke();
        
        // String
        ctx.strokeStyle = '#4E342E';
        ctx.lineWidth = 2;
        const pullBack = drawn ? -15 : 0;
        ctx.beginPath();
        ctx.moveTo(0, -40);
        ctx.lineTo(pullBack, 0);
        ctx.lineTo(0, 40);
        ctx.stroke();
        
        ctx.restore();
      }
      
      // Draw arrow
      function drawArrow(x, y, angle = 0) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        
        // Shaft
        ctx.strokeStyle = '#8D6E63';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(-25, 0);
        ctx.lineTo(20, 0);
        ctx.stroke();
        
        // Arrowhead (obsidian)
        ctx.fillStyle = '#1a1a1a';
        ctx.beginPath();
        ctx.moveTo(20, 0);
        ctx.lineTo(30, -6);
        ctx.lineTo(35, 0);
        ctx.lineTo(30, 6);
        ctx.closePath();
        ctx.fill();
        
        // Fletching
        ctx.fillStyle = '#B71C1C';
        ctx.beginPath();
        ctx.moveTo(-25, 0);
        ctx.lineTo(-20, -8);
        ctx.lineTo(-15, 0);
        ctx.lineTo(-20, 8);
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
      }
      
      // Draw detailed deer
      function drawDeer(x, y, scale = 1, hit = false) {
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(scale, scale);
        
        const bodyColor = hit ? '#8D6E63' : '#A1887F';
        const legColor = hit ? '#6D4C41' : '#8D6E63';
        
        // Body
        ctx.fillStyle = bodyColor;
        ctx.beginPath();
        ctx.ellipse(0, 0, 40, 25, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Neck
        ctx.beginPath();
        ctx.ellipse(35, -15, 12, 20, 0.5, 0, Math.PI * 2);
        ctx.fill();
        
        // Head
        ctx.beginPath();
        ctx.ellipse(50, -30, 12, 10, 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Ear
        ctx.beginPath();
        ctx.ellipse(45, -42, 4, 8, -0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Eye
        ctx.fillStyle = '#1a1a1a';
        ctx.beginPath();
        ctx.arc(55, -32, 3, 0, Math.PI * 2);
        ctx.fill();
        
        // Antlers
        ctx.strokeStyle = '#5D4037';
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(48, -40);
        ctx.lineTo(55, -55);
        ctx.lineTo(60, -50);
        ctx.moveTo(55, -55);
        ctx.lineTo(50, -60);
        ctx.stroke();
        
        // Legs
        ctx.strokeStyle = legColor;
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(-20, 20);
        ctx.lineTo(-22, 50);
        ctx.moveTo(-5, 22);
        ctx.lineTo(-5, 50);
        ctx.moveTo(15, 22);
        ctx.lineTo(15, 50);
        ctx.moveTo(25, 20);
        ctx.lineTo(27, 50);
        ctx.stroke();
        
        // Hooves
        ctx.fillStyle = '#3E2723';
        ctx.beginPath();
        [-22, -5, 15, 27].forEach(lx => {
          ctx.moveTo(lx, 50);
          ctx.arc(lx, 52, 4, 0, Math.PI * 2);
        });
        ctx.fill();
        
        // White belly
        ctx.fillStyle = '#EFEBE9';
        ctx.beginPath();
        ctx.ellipse(0, 15, 25, 10, 0, 0, Math.PI);
        ctx.fill();
        
        // Tail
        ctx.fillStyle = '#EFEBE9';
        ctx.beginPath();
        ctx.ellipse(-42, -5, 8, 6, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
      }
      
      // Draw grass
      function drawGrass(groundY) {
        ctx.strokeStyle = '#2E7D32';
        ctx.lineWidth = 2;
        for (let i = 0; i < W; i += 8) {
          const h = 10 + Math.sin(i + frame * 0.05) * 5;
          const sway = Math.sin(frame * 0.03 + i * 0.1) * 3;
          ctx.beginPath();
          ctx.moveTo(i, groundY);
          ctx.quadraticCurveTo(i + sway, groundY - h/2, i + sway * 2, groundY - h);
          ctx.stroke();
        }
      }
      
      // Draw tree
      function drawTree(x, groundY, size = 1) {
        ctx.save();
        ctx.translate(x, groundY);
        ctx.scale(size, size);
        
        // Trunk
        ctx.fillStyle = '#5D4037';
        ctx.fillRect(-8, -60, 16, 60);
        
        // Foliage layers
        ctx.fillStyle = '#2E7D32';
        ctx.beginPath();
        ctx.moveTo(0, -140);
        ctx.lineTo(-35, -60);
        ctx.lineTo(35, -60);
        ctx.closePath();
        ctx.fill();
        
        ctx.fillStyle = '#388E3C';
        ctx.beginPath();
        ctx.moveTo(0, -120);
        ctx.lineTo(-40, -50);
        ctx.lineTo(40, -50);
        ctx.closePath();
        ctx.fill();
        
        ctx.fillStyle = '#43A047';
        ctx.beginPath();
        ctx.moveTo(0, -100);
        ctx.lineTo(-45, -40);
        ctx.lineTo(45, -40);
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
      }
      
      // Draw oak tree
      function drawOakTree(x, groundY, size = 1) {
        ctx.save();
        ctx.translate(x, groundY);
        ctx.scale(size, size);
        
        // Trunk
        ctx.fillStyle = '#4E342E';
        ctx.beginPath();
        ctx.moveTo(-15, 0);
        ctx.lineTo(-10, -80);
        ctx.lineTo(10, -80);
        ctx.lineTo(15, 0);
        ctx.closePath();
        ctx.fill();
        
        // Branches
        ctx.strokeStyle = '#5D4037';
        ctx.lineWidth = 8;
        ctx.beginPath();
        ctx.moveTo(0, -70);
        ctx.lineTo(-40, -100);
        ctx.moveTo(0, -60);
        ctx.lineTo(45, -95);
        ctx.stroke();
        
        // Foliage (multiple circles)
        ctx.fillStyle = '#33691E';
        [[-30, -110], [0, -120], [35, -105], [-15, -95], [20, -115]].forEach(([ox, oy]) => {
          ctx.beginPath();
          ctx.arc(ox, oy, 30, 0, Math.PI * 2);
          ctx.fill();
        });
        
        ctx.fillStyle = '#558B2F';
        [[-20, -115], [15, -110], [0, -100]].forEach(([ox, oy]) => {
          ctx.beginPath();
          ctx.arc(ox, oy, 25, 0, Math.PI * 2);
          ctx.fill();
        });
        
        ctx.restore();
      }
      
      // Draw water
      function drawWater(startY) {
        // Water gradient
        const waterGrad = ctx.createLinearGradient(0, startY, 0, H);
        waterGrad.addColorStop(0, '#4FC3F7');
        waterGrad.addColorStop(0.3, '#039BE5');
        waterGrad.addColorStop(1, '#01579B');
        ctx.fillStyle = waterGrad;
        ctx.fillRect(0, startY, W, H - startY);
        
        // Ripples
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = 1;
        for (let i = 0; i < 8; i++) {
          const ry = startY + 20 + i * 25;
          const rx = W/2 + Math.sin(frame * 0.02 + i) * 30;
          ctx.beginPath();
          ctx.ellipse(rx, ry, 40 + Math.sin(frame * 0.05 + i) * 10, 5, 0, 0, Math.PI * 2);
          ctx.stroke();
        }
        
        // Light reflections
        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
        for (let i = 0; i < 5; i++) {
          ctx.beginPath();
          ctx.ellipse(50 + i * 60, startY + 30 + Math.sin(frame * 0.03 + i) * 5, 15, 3, 0, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      // Draw fish
      function drawFish(x, y, size = 1, type = 'salmon') {
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(size, size);
        
        const colors = type === 'salmon' ? ['#E57373', '#C62828'] : ['#90A4AE', '#546E7A'];
        
        // Body
        ctx.fillStyle = colors[0];
        ctx.beginPath();
        ctx.ellipse(0, 0, 25, 12, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Tail
        ctx.fillStyle = colors[1];
        ctx.beginPath();
        ctx.moveTo(-25, 0);
        ctx.lineTo(-40, -15);
        ctx.lineTo(-40, 15);
        ctx.closePath();
        ctx.fill();
        
        // Fins
        ctx.beginPath();
        ctx.moveTo(0, -10);
        ctx.lineTo(-5, -20);
        ctx.lineTo(10, -10);
        ctx.closePath();
        ctx.fill();
        
        // Eye
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(15, -2, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(16, -2, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Scales pattern
        ctx.strokeStyle = colors[1];
        ctx.lineWidth = 0.5;
        for (let i = -15; i < 15; i += 8) {
          ctx.beginPath();
          ctx.arc(i, 0, 6, -0.5, 0.5);
          ctx.stroke();
        }
        
        ctx.restore();
      }
      
      // Draw mortar and pestle
      function drawMortar(x, y, pestleY = 0) {
        ctx.save();
        ctx.translate(x, y);
        
        // Mortar (stone bowl)
        const mortarGrad = ctx.createRadialGradient(0, 20, 10, 0, 20, 50);
        mortarGrad.addColorStop(0, '#9E9E9E');
        mortarGrad.addColorStop(1, '#616161');
        ctx.fillStyle = mortarGrad;
        
        ctx.beginPath();
        ctx.moveTo(-45, 0);
        ctx.quadraticCurveTo(-55, 50, -35, 70);
        ctx.lineTo(35, 70);
        ctx.quadraticCurveTo(55, 50, 45, 0);
        ctx.closePath();
        ctx.fill();
        
        // Inner bowl
        ctx.fillStyle = '#424242';
        ctx.beginPath();
        ctx.ellipse(0, 10, 35, 20, 0, 0, Math.PI);
        ctx.fill();
        
        // Acorns/meal inside
        ctx.fillStyle = '#D7CCC8';
        ctx.beginPath();
        ctx.ellipse(0, 20, 30, 12, 0, 0, Math.PI);
        ctx.fill();
        
        // Stone texture
        ctx.fillStyle = 'rgba(0,0,0,0.1)';
        for (let i = 0; i < 10; i++) {
          ctx.beginPath();
          ctx.arc(-30 + Math.random() * 60, 20 + Math.random() * 40, 3 + Math.random() * 5, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Pestle
        const py = pestleY;
        ctx.fillStyle = '#757575';
        ctx.beginPath();
        ctx.ellipse(0, py - 20, 12, 8, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillRect(-8, py - 70, 16, 50);
        ctx.beginPath();
        ctx.ellipse(0, py - 70, 8, 4, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Pestle highlight
        ctx.fillStyle = 'rgba(255,255,255,0.2)';
        ctx.fillRect(-2, py - 65, 4, 40);
        
        ctx.restore();
      }
      
      // Draw basket
      function drawBasket(x, y, progress = 1) {
        ctx.save();
        ctx.translate(x, y);
        
        const maxH = 60 * progress;
        
        // Basket weave
        ctx.strokeStyle = '#8D6E63';
        ctx.lineWidth = 3;
        
        // Horizontal weaves
        for (let i = 0; i < maxH; i += 6) {
          ctx.strokeStyle = i % 12 === 0 ? '#6D4C41' : '#A1887F';
          ctx.beginPath();
          const w = 30 + (i / maxH) * 20;
          ctx.ellipse(0, -i, w, 8, 0, 0, Math.PI * 2);
          ctx.stroke();
        }
        
        // Vertical supports
        ctx.strokeStyle = '#5D4037';
        ctx.lineWidth = 2;
        for (let a = 0; a < Math.PI * 2; a += Math.PI / 6) {
          ctx.beginPath();
          ctx.moveTo(Math.cos(a) * 30, 0);
          ctx.lineTo(Math.cos(a) * 50, -maxH);
          ctx.stroke();
        }
        
        ctx.restore();
      }
      
      // Draw background
      function drawBackground(type) {
        // Sky
        const skyGrad = ctx.createLinearGradient(0, 0, 0, H * 0.7);
        skyGrad.addColorStop(0, '#81D4FA');
        skyGrad.addColorStop(0.5, '#B3E5FC');
        skyGrad.addColorStop(1, '#E1F5FE');
        ctx.fillStyle = skyGrad;
        ctx.fillRect(0, 0, W, H);
        
        // Sun
        ctx.fillStyle = '#FFF9C4';
        ctx.beginPath();
        ctx.arc(W - 50, 40, 25, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#FFEB3B';
        ctx.beginPath();
        ctx.arc(W - 50, 40, 20, 0, Math.PI * 2);
        ctx.fill();
        
        // Sun rays
        ctx.strokeStyle = 'rgba(255, 235, 59, 0.3)';
        ctx.lineWidth = 2;
        for (let i = 0; i < 8; i++) {
          const angle = (i / 8) * Math.PI * 2 + frame * 0.005;
          ctx.beginPath();
          ctx.moveTo(W - 50 + Math.cos(angle) * 28, 40 + Math.sin(angle) * 28);
          ctx.lineTo(W - 50 + Math.cos(angle) * 40, 40 + Math.sin(angle) * 40);
          ctx.stroke();
        }
        
        // Clouds
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        const cloudX1 = (frame * 0.2) % (W + 100) - 50;
        const cloudX2 = (frame * 0.15 + 150) % (W + 100) - 50;
        
        // Cloud 1
        ctx.beginPath();
        ctx.arc(cloudX1, 50, 20, 0, Math.PI * 2);
        ctx.arc(cloudX1 + 25, 45, 25, 0, Math.PI * 2);
        ctx.arc(cloudX1 + 50, 50, 18, 0, Math.PI * 2);
        ctx.fill();
        
        // Cloud 2
        ctx.beginPath();
        ctx.arc(cloudX2, 80, 15, 0, Math.PI * 2);
        ctx.arc(cloudX2 + 20, 75, 20, 0, Math.PI * 2);
        ctx.arc(cloudX2 + 40, 80, 15, 0, Math.PI * 2);
        ctx.fill();
        
        // Birds
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1.5;
        for (let i = 0; i < 3; i++) {
          const birdX = (frame * 0.5 + i * 80) % (W + 50) - 25;
          const birdY = 60 + i * 20 + Math.sin(frame * 0.1 + i) * 5;
          ctx.beginPath();
          ctx.moveTo(birdX - 8, birdY);
          ctx.quadraticCurveTo(birdX - 4, birdY - 5, birdX, birdY);
          ctx.quadraticCurveTo(birdX + 4, birdY - 5, birdX + 8, birdY);
          ctx.stroke();
        }
        
        // Distant hills
        ctx.fillStyle = '#81C784';
        ctx.beginPath();
        ctx.moveTo(0, H * 0.5);
        ctx.quadraticCurveTo(W * 0.25, H * 0.35, W * 0.5, H * 0.45);
        ctx.quadraticCurveTo(W * 0.75, H * 0.55, W, H * 0.4);
        ctx.lineTo(W, H);
        ctx.lineTo(0, H);
        ctx.closePath();
        ctx.fill();
        
        // Ground
        const groundY = H * 0.7;
        const groundGrad = ctx.createLinearGradient(0, groundY, 0, H);
        groundGrad.addColorStop(0, '#7CB342');
        groundGrad.addColorStop(1, '#558B2F');
        ctx.fillStyle = groundGrad;
        ctx.fillRect(0, groundY, W, H * 0.3);
        
        // Ground texture
        ctx.fillStyle = 'rgba(85, 139, 47, 0.3)';
        for (let i = 0; i < 20; i++) {
          ctx.beginPath();
          ctx.ellipse(Math.random() * W, groundY + 5 + Math.random() * 30, 10 + Math.random() * 15, 3, 0, 0, Math.PI * 2);
          ctx.fill();
        }
        
        return groundY;
      }
      
      let animationId;
      function animate() {
        ctx.clearRect(0, 0, W, H);
        
        const groundY = drawBackground(type);
        
        if (type === 'bow_hunt') {
          // Trees in background
          drawTree(50, groundY, 0.6);
          drawOakTree(W - 60, groundY, 0.5);
          
          const phase = (frame % 200) / 200;
          
          // Deer
          const deerHit = phase > 0.6;
          const deerX = deerHit ? W - 100 : W - 100 + Math.sin(frame * 0.02) * 10;
          drawDeer(deerX, groundY - 30, 0.8, deerHit);
          
          // Hunter
          const pose = phase < 0.5 ? 'bow_draw' : 'stand';
          drawPerson(80, groundY - 50, 1, pose);
          
          // Bow
          const bowDrawn = phase < 0.5;
          drawBow(45, groundY - 55, bowDrawn, -0.2);
          
          // Arrow flight
          if (phase > 0.4 && phase < 0.65) {
            const arrowProgress = (phase - 0.4) / 0.25;
            const arrowX = 80 + arrowProgress * (W - 180);
            const arrowY = groundY - 55 + Math.sin(arrowProgress * Math.PI) * -20;
            drawArrow(arrowX, arrowY, -0.1 + arrowProgress * 0.1);
          }
          
          // Success message
          if (deerHit) {
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(W/2 - 80, 15, 160, 35);
            ctx.fillStyle = '#FFD54F';
            ctx.font = 'bold 18px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('üéØ Successful Hunt!', W/2, 40);
          }
          
          // Grass
          drawGrass(groundY);
          
        } else if (type === 'grinding') {
          drawOakTree(W - 80, groundY, 0.7);
          
          // Falling acorns occasionally
          if (frame % 60 < 30) {
            ctx.fillStyle = '#795548';
            const acornY = (frame % 60) * 3;
            ctx.beginPath();
            ctx.ellipse(W - 80 + (frame % 20), groundY - 100 + acornY, 5, 7, 0, 0, Math.PI * 2);
            ctx.fill();
          }
          
          // Mortar
          const pestleY = Math.sin(frame * 0.15) * 15;
          drawMortar(W/2, groundY - 20, pestleY);
          
          // Person grinding
          drawPerson(W/2, groundY - 70, 1, 'grind');
          
          // Dust particles
          ctx.fillStyle = 'rgba(215, 204, 200, 0.6)';
          for (let i = 0; i < 5; i++) {
            const px = W/2 - 20 + Math.random() * 40;
            const py = groundY - 30 - Math.random() * 20 - (frame % 30);
            ctx.beginPath();
            ctx.arc(px, py, 2, 0, Math.PI * 2);
            ctx.fill();
          }
          
          drawGrass(groundY);
          
        } else if (type === 'weaving') {
          drawOakTree(50, groundY, 0.6);
          
          // Person weaving
          drawPerson(W/2 - 50, groundY - 50, 1, 'weave');
          
          // Basket being woven
          const basketProgress = 0.3 + (Math.sin(frame * 0.02) + 1) * 0.35;
          drawBasket(W/2 + 40, groundY - 10, basketProgress);
          
          // Materials nearby
          ctx.strokeStyle = '#8D6E63';
          ctx.lineWidth = 2;
          for (let i = 0; i < 8; i++) {
            ctx.beginPath();
            ctx.moveTo(W/2 + 80 + i * 3, groundY);
            ctx.lineTo(W/2 + 85 + i * 3 + Math.sin(i) * 5, groundY - 40);
            ctx.stroke();
          }
          
          drawGrass(groundY);
          
        } else if (type === 'fishing') {
          // Water scene
          ctx.fillStyle = '#81D4FA';
          ctx.fillRect(0, 0, W, H * 0.4);
          
          // Bank
          ctx.fillStyle = '#8D6E63';
          ctx.beginPath();
          ctx.moveTo(0, H * 0.4);
          ctx.quadraticCurveTo(W * 0.3, H * 0.35, W * 0.5, H * 0.5);
          ctx.lineTo(0, H);
          ctx.closePath();
          ctx.fill();
          
          // Grass on bank
          ctx.fillStyle = '#7CB342';
          ctx.beginPath();
          ctx.moveTo(0, H * 0.38);
          ctx.quadraticCurveTo(W * 0.25, H * 0.33, W * 0.4, H * 0.45);
          ctx.lineTo(0, H * 0.6);
          ctx.closePath();
          ctx.fill();
          
          drawWater(H * 0.4);
          
          // Fisher
          drawPerson(100, H * 0.5, 0.9, 'fish');
          
          // Fishing rod
          ctx.strokeStyle = '#5D4037';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(125, H * 0.45);
          ctx.quadraticCurveTo(180, H * 0.3, 200, H * 0.35);
          ctx.stroke();
          
          // Fishing line
          ctx.strokeStyle = '#424242';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(200, H * 0.35);
          ctx.lineTo(220, H * 0.55 + Math.sin(frame * 0.1) * 5);
          ctx.stroke();
          
          // Bobber
          ctx.fillStyle = '#F44336';
          ctx.beginPath();
          ctx.arc(220, H * 0.55 + Math.sin(frame * 0.1) * 5, 5, 0, Math.PI * 2);
          ctx.fill();
          
          // Fish swimming
          const fishX = W - 50 - (frame % 150);
          drawFish(fishX, H * 0.65 + Math.sin(frame * 0.05) * 10, 0.7);
          drawFish(fishX + 80, H * 0.75, 0.5, 'other');
          
        } else if (type === 'ceremony') {
          // Night sky
          const nightGrad = ctx.createLinearGradient(0, 0, 0, H);
          nightGrad.addColorStop(0, '#1A237E');
          nightGrad.addColorStop(0.5, '#303F9F');
          nightGrad.addColorStop(1, '#3F51B5');
          ctx.fillStyle = nightGrad;
          ctx.fillRect(0, 0, W, H);
          
          // Stars
          ctx.fillStyle = '#fff';
          for (let i = 0; i < 30; i++) {
            const sx = (i * 37) % W;
            const sy = (i * 23) % (H * 0.5);
            const twinkle = Math.sin(frame * 0.1 + i) > 0.5 ? 2 : 1;
            ctx.beginPath();
            ctx.arc(sx, sy, twinkle, 0, Math.PI * 2);
            ctx.fill();
          }
          
          // Moon
          ctx.fillStyle = '#FFF9C4';
          ctx.beginPath();
          ctx.arc(W - 60, 50, 25, 0, Math.PI * 2);
          ctx.fill();
          
          // Ground
          ctx.fillStyle = '#33691E';
          ctx.fillRect(0, H * 0.7, W, H * 0.3);
          
          // Fire
          const fireX = W/2;
          const fireY = H * 0.75;
          
          // Fire glow
          const glowGrad = ctx.createRadialGradient(fireX, fireY, 10, fireX, fireY, 80);
          glowGrad.addColorStop(0, 'rgba(255, 152, 0, 0.4)');
          glowGrad.addColorStop(1, 'rgba(255, 152, 0, 0)');
          ctx.fillStyle = glowGrad;
          ctx.fillRect(fireX - 100, fireY - 80, 200, 120);
          
          // Fire flames
          for (let i = 0; i < 8; i++) {
            const flameX = fireX - 20 + i * 5 + Math.sin(frame * 0.2 + i) * 3;
            const flameH = 30 + Math.sin(frame * 0.3 + i * 0.5) * 15;
            const hue = 30 + i * 5;
            ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
            ctx.beginPath();
            ctx.moveTo(flameX - 5, fireY);
            ctx.quadraticCurveTo(flameX, fireY - flameH, flameX + 5, fireY);
            ctx.fill();
          }
          
          // Sparks
          ctx.fillStyle = '#FFEB3B';
          for (let i = 0; i < 5; i++) {
            const sparkX = fireX - 10 + Math.random() * 20;
            const sparkY = fireY - 40 - (frame + i * 10) % 50;
            ctx.beginPath();
            ctx.arc(sparkX, sparkY, 1.5, 0, Math.PI * 2);
            ctx.fill();
          }
          
          // Dancers
          for (let i = 0; i < 3; i++) {
            const dx = fireX - 80 + i * 80;
            const sway = Math.sin(frame * 0.08 + i * 2) * 5;
            drawPerson(dx + sway, H * 0.65, 0.8, 'stand');
          }
          
        } else if (type === 'knapping') {
          drawTree(W - 70, groundY, 0.5);
          
          // Person
          drawPerson(W/2 - 30, groundY - 50, 1, 'grind');
          
          // Obsidian being worked
          ctx.fillStyle = '#1a1a1a';
          ctx.beginPath();
          ctx.moveTo(W/2 + 20, groundY - 30);
          ctx.lineTo(W/2 + 50, groundY - 50);
          ctx.lineTo(W/2 + 60, groundY - 35);
          ctx.lineTo(W/2 + 45, groundY - 15);
          ctx.closePath();
          ctx.fill();
          
          // Obsidian shine
          ctx.fillStyle = 'rgba(255,255,255,0.3)';
          ctx.beginPath();
          ctx.moveTo(W/2 + 30, groundY - 40);
          ctx.lineTo(W/2 + 45, groundY - 45);
          ctx.lineTo(W/2 + 40, groundY - 35);
          ctx.closePath();
          ctx.fill();
          
          // Hammerstone
          ctx.fillStyle = '#9E9E9E';
          const hammerY = groundY - 60 + Math.abs(Math.sin(frame * 0.15)) * 20;
          ctx.beginPath();
          ctx.ellipse(W/2 + 40, hammerY, 12, 10, 0, 0, Math.PI * 2);
          ctx.fill();
          
          // Sparks when hitting
          if (Math.sin(frame * 0.15) > 0.8) {
            ctx.fillStyle = '#FFD54F';
            for (let i = 0; i < 6; i++) {
              const sparkX = W/2 + 40 + (Math.random() - 0.5) * 30;
              const sparkY = groundY - 40 - Math.random() * 20;
              ctx.beginPath();
              ctx.arc(sparkX, sparkY, 2, 0, Math.PI * 2);
              ctx.fill();
            }
          }
          
          // Flakes on ground
          ctx.fillStyle = '#37474F';
          for (let i = 0; i < 5; i++) {
            ctx.beginPath();
            ctx.ellipse(W/2 + 30 + i * 10, groundY - 5, 4, 2, i * 0.5, 0, Math.PI * 2);
            ctx.fill();
          }
          
          drawGrass(groundY);
          
        } else if (type === 'trading') {
          // Trading scene
          drawOakTree(W - 70, groundY, 0.6);
          drawOakTree(40, groundY, 0.5);
          
          // Two people trading
          drawPerson(W/2 - 60, groundY - 50, 0.9, 'stand', 1);
          drawPerson(W/2 + 60, groundY - 50, 0.9, 'stand', -1);
          
          // Shell beads being exchanged (animated)
          const beadY = groundY - 80 + Math.sin(frame * 0.05) * 5;
          ctx.fillStyle = '#E8E8E8';
          for (let i = 0; i < 5; i++) {
            ctx.beginPath();
            ctx.ellipse(W/2 - 10 + i * 5, beadY, 4, 6, 0, 0, Math.PI * 2);
            ctx.fill();
          }
          
          // Basket of goods
          ctx.fillStyle = '#8D6E63';
          ctx.beginPath();
          ctx.ellipse(W/2, groundY - 10, 25, 15, 0, Math.PI, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = '#6D4C41';
          ctx.lineWidth = 2;
          for (let i = 0; i < 5; i++) {
            ctx.beginPath();
            ctx.ellipse(W/2, groundY - 10 - i * 3, 25 - i * 2, 8, 0, 0, Math.PI);
            ctx.stroke();
          }
          
          drawGrass(groundY);
          
        } else if (type === 'gathering') {
          // Acorn gathering scene
          drawOakTree(W/2, groundY, 1.2);
          
          // Falling acorns
          ctx.fillStyle = '#795548';
          for (let i = 0; i < 5; i++) {
            const acornX = W/2 - 40 + ((frame + i * 30) % 80);
            const acornY = groundY - 120 + ((frame + i * 20) % 100);
            ctx.beginPath();
            ctx.ellipse(acornX, acornY, 5, 7, 0, 0, Math.PI * 2);
            ctx.fill();
            // Acorn cap
            ctx.fillStyle = '#5D4037';
            ctx.beginPath();
            ctx.ellipse(acornX, acornY - 5, 6, 3, 0, Math.PI, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#795548';
          }
          
          // Person gathering with basket
          drawPerson(W/2 - 80, groundY - 50, 1, 'grind');
          
          // Gathering basket
          ctx.fillStyle = '#A1887F';
          ctx.beginPath();
          ctx.ellipse(W/2 - 50, groundY - 20, 20, 12, 0.3, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#795548';
          for (let i = 0; i < 6; i++) {
            ctx.beginPath();
            ctx.ellipse(W/2 - 50 + (Math.random() - 0.5) * 20, groundY - 22, 4, 5, 0, 0, Math.PI * 2);
            ctx.fill();
          }
          
          drawGrass(groundY);
          
        } else if (type === 'cooking') {
          // Cooking with hot stones scene
          
          // Cooking basket
          ctx.fillStyle = '#8D6E63';
          ctx.beginPath();
          ctx.moveTo(W/2 - 40, groundY - 30);
          ctx.quadraticCurveTo(W/2 - 50, groundY + 20, W/2 - 30, groundY + 40);
          ctx.lineTo(W/2 + 30, groundY + 40);
          ctx.quadraticCurveTo(W/2 + 50, groundY + 20, W/2 + 40, groundY - 30);
          ctx.closePath();
          ctx.fill();
          
          // Weave pattern
          ctx.strokeStyle = '#6D4C41';
          ctx.lineWidth = 2;
          for (let i = 0; i < 8; i++) {
            ctx.beginPath();
            ctx.ellipse(W/2, groundY + 5 - i * 8, 35 - i * 2, 8, 0, 0, Math.PI * 2);
            ctx.stroke();
          }
          
          // Water/soup inside
          ctx.fillStyle = '#90A4AE';
          ctx.beginPath();
          ctx.ellipse(W/2, groundY - 20, 32, 15, 0, 0, Math.PI * 2);
          ctx.fill();
          
          // Steam
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
          ctx.lineWidth = 2;
          for (let i = 0; i < 4; i++) {
            const steamX = W/2 - 20 + i * 15;
            const steamOffset = Math.sin(frame * 0.1 + i) * 5;
            ctx.beginPath();
            ctx.moveTo(steamX, groundY - 35);
            ctx.quadraticCurveTo(steamX + steamOffset, groundY - 55, steamX, groundY - 75);
            ctx.stroke();
          }
          
          // Hot stone being added
          const stoneY = groundY - 60 - (frame % 60);
          if (frame % 120 < 60) {
            ctx.fillStyle = '#FF6B6B';
            ctx.beginPath();
            ctx.ellipse(W/2 + 10, stoneY, 10, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            // Glow
            ctx.fillStyle = 'rgba(255, 100, 100, 0.3)';
            ctx.beginPath();
            ctx.ellipse(W/2 + 10, stoneY, 15, 12, 0, 0, Math.PI * 2);
            ctx.fill();
          }
          
          // Person cooking
          drawPerson(W/2 - 70, groundY - 50, 0.9, 'stand');
          
          // Fire nearby
          for (let i = 0; i < 5; i++) {
            const flameH = 15 + Math.sin(frame * 0.3 + i) * 8;
            ctx.fillStyle = `hsl(${25 + i * 5}, 100%, 50%)`;
            ctx.beginPath();
            ctx.moveTo(W/2 + 80 + i * 8, groundY);
            ctx.quadraticCurveTo(W/2 + 84 + i * 8, groundY - flameH, W/2 + 88 + i * 8, groundY);
            ctx.fill();
          }
          
          drawGrass(groundY);
          
        } else if (type === 'scraping') {
          // Hide scraping scene
          
          // Stretched hide on frame
          ctx.fillStyle = '#D7CCC8';
          ctx.beginPath();
          ctx.ellipse(W/2 + 30, groundY - 40, 50, 35, 0.2, 0, Math.PI * 2);
          ctx.fill();
          
          // Hide texture
          ctx.fillStyle = '#BCAAA4';
          for (let i = 0; i < 8; i++) {
            ctx.beginPath();
            ctx.ellipse(W/2 + 20 + Math.random() * 40, groundY - 50 + Math.random() * 30, 5, 3, Math.random(), 0, Math.PI * 2);
            ctx.fill();
          }
          
          // Frame poles
          ctx.strokeStyle = '#5D4037';
          ctx.lineWidth = 6;
          ctx.beginPath();
          ctx.moveTo(W/2 - 30, groundY);
          ctx.lineTo(W/2 - 20, groundY - 90);
          ctx.moveTo(W/2 + 90, groundY);
          ctx.lineTo(W/2 + 80, groundY - 90);
          ctx.stroke();
          
          // Cross bar
          ctx.beginPath();
          ctx.moveTo(W/2 - 20, groundY - 85);
          ctx.lineTo(W/2 + 80, groundY - 85);
          ctx.stroke();
          
          // Person scraping
          drawPerson(W/2 - 50, groundY - 50, 1, 'grind');
          
          // Scraping tool in motion
          const toolX = W/2 + 10 + Math.sin(frame * 0.15) * 15;
          ctx.fillStyle = '#795548';
          ctx.fillRect(toolX, groundY - 55, 25, 5);
          ctx.fillStyle = '#9E9E9E';
          ctx.beginPath();
          ctx.moveTo(toolX + 25, groundY - 55);
          ctx.lineTo(toolX + 35, groundY - 52);
          ctx.lineTo(toolX + 25, groundY - 50);
          ctx.closePath();
          ctx.fill();
          
          drawGrass(groundY);
          
        } else {
          // Generic scene
          drawOakTree(W - 80, groundY, 0.7);
          drawPerson(W/2, groundY - 50, 1, 'stand');
          
          // Show artifact emoji
          ctx.font = '50px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText(artifact.emoji, W/2, groundY - 120);
          
          drawGrass(groundY);
        }
        
        frame++;
        animationId = requestAnimationFrame(animate);
      }
      
      animate();
      window.currentCutsceneAnimation = animationId;
    }

    // ============================================
    // MOVEMENT & MAP
    // ============================================
    function movePlayer(lat, lon) {
      state.playerPos = { lat, lon };
      if (state.playerMarker) {
        state.playerMarker.setLatLng([lat, lon]);
      }
      if (state.radiusCircle) {
        state.radiusCircle.setLatLng([lat, lon]);
      }
      updateArtifactMarkers();
    }

    function movePlayerByMeters(mN, mE) {
      const dLat = mN / 111320;
      const dLon = mE / (111320 * Math.cos(state.playerPos.lat * Math.PI / 180));
      const newLat = state.playerPos.lat + dLat;
      const newLon = state.playerPos.lon + dLon;
      movePlayer(newLat, newLon);
      // Smooth pan to new location
      if (state.map) {
        state.map.panTo([newLat, newLon], { animate: true, duration: 0.1, easeLinearity: 0.5 });
      }
    }

    function initMap() {
      const { lat, lon } = state.playerPos;
      state.map = L.map('map', { 
        zoomControl: true,
        zoomAnimation: true,
        markerZoomAnimation: true,
        zoomAnimationThreshold: 4
      }).setView([lat, lon], state.zoomLevel);
      L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
        attribution: '¬© OpenStreetMap ¬© CARTO', subdomains: 'abcd', maxZoom: 20
      }).addTo(state.map);
      state.radiusCircle = L.circle([lat, lon], { radius: COLLECT_DISTANCE, color: '#c9a227', fillColor: '#c9a227', fillOpacity: 0.1, weight: 2, dashArray: '5, 5' }).addTo(state.map);
      state.playerMarker = L.marker([lat, lon], { icon: L.divIcon({ className: '', html: '<div class="player-pulse"></div><div class="player-marker"></div>', iconSize: [24, 24], iconAnchor: [12, 12] }), zIndexOffset: 1000 }).addTo(state.map);
      state.map.on('click', e => { 
        movePlayer(e.latlng.lat, e.latlng.lng); 
        state.map.panTo(e.latlng, { animate: true, duration: 0.25 }); 
      });
      document.addEventListener('keydown', handleKeydown);
    }

    function handleKeydown(e) {
      if (state.showingModal || state.foundArtifact || state.showLevelUp || state.cleaningArtifact || state.showingCutscene || state.playingMinigame) return;
      const key = e.key.toLowerCase();
      let moved = false;
      const moveAmount = 8; // Smaller, smoother movement
      if (key === 'w' || key === 'arrowup') { movePlayerByMeters(moveAmount, 0); moved = true; }
      if (key === 's' || key === 'arrowdown') { movePlayerByMeters(-moveAmount, 0); moved = true; }
      if (key === 'a' || key === 'arrowleft') { movePlayerByMeters(0, -moveAmount); moved = true; }
      if (key === 'd' || key === 'arrowright') { movePlayerByMeters(0, moveAmount); moved = true; }
      
      // Q = zoom IN (higher zoom number = closer), E = zoom OUT (lower zoom number = further)
      if (key === 'q') { 
        state.zoomLevel = Math.min(20, state.zoomLevel + 1);
        if (state.map) {
          state.map.flyTo([state.playerPos.lat, state.playerPos.lon], state.zoomLevel, {
            animate: true,
            duration: 0.3,
            easeLinearity: 0.25
          });
        }
      }
      if (key === 'e') { 
        state.zoomLevel = Math.max(14, state.zoomLevel - 1);
        if (state.map) {
          state.map.flyTo([state.playerPos.lat, state.playerPos.lon], state.zoomLevel, {
            animate: true,
            duration: 0.3,
            easeLinearity: 0.25
          });
        }
      }
      
      if (moved) { 
        e.preventDefault(); 
      }
    }

    function updateArtifactMarkers() {
      state.artifactMarkers.forEach(m => m.remove());
      state.artifactMarkers = [];
      state.artifacts.forEach(artifact => {
        const dist = getDistance(state.playerPos.lat, state.playerPos.lon, artifact.lat, artifact.lon);
        const near = dist <= COLLECT_DISTANCE;
        const marker = L.marker([artifact.lat, artifact.lon], { icon: L.divIcon({ className: `artifact-marker ${near ? 'nearby' : ''}`, html: artifact.emoji, iconSize: [60, 60], iconAnchor: [30, 30] }) }).addTo(state.map);
        marker.bindPopup(`<div class="artifact-popup"><div class="emoji">${artifact.emoji}</div><div class="name">${artifact.name}</div><div class="buried-hint">Half-buried...</div><div class="distance">${formatDistance(dist)}</div><button class="collect-btn" ${near ? '' : 'disabled'} onclick="window.startDigging('${artifact.id}')">${near ? 'üñåÔ∏è Excavate!' : 'Get closer'}</button></div>`, { closeButton: false });
        state.artifactMarkers.push(marker);
      });
    }

    window.startDigging = id => {
      const a = state.artifacts.find(x => x.id == id);
      if (a) { state.map.closePopup(); startCleaning(a); }
    };

    // ============================================
    // MINI-GAMES
    // ============================================
    function startMinigame(type) {
      state.playingMinigame = type;
      state.minigameScore = 0;
      state.minigameTimer = 30;
      state.minigameActive = true;
      state.gameState = {};
      render();
      setTimeout(() => initMinigameCanvas(type), 100);
      
      const timer = setInterval(() => {
        if (!state.minigameActive) { clearInterval(timer); return; }
        state.minigameTimer--;
        updateMinigameUI();
        if (state.minigameTimer <= 0) { endMinigame(); clearInterval(timer); }
      }, 1000);
    }

    function endMinigame() {
      state.minigameActive = false;
      const game = state.playingMinigame;
      if (!state.highScores[game] || state.minigameScore > state.highScores[game]) {
        state.highScores[game] = state.minigameScore;
      }
      checkAchievements();
      saveGame();
      render();
    }

    function updateMinigameUI() {
      const scoreEl = document.getElementById('mgScore');
      const timerEl = document.getElementById('mgTimer');
      if (scoreEl) scoreEl.textContent = state.minigameScore;
      if (timerEl) timerEl.textContent = state.minigameActive ? `‚è±Ô∏è ${state.minigameTimer}s` : 'üèÅ Done!';
    }

    function initMinigameCanvas(type) {
      const canvas = document.getElementById('gameCanvas');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      const W = canvas.width, H = canvas.height;
      
      if (type === 'bow_hunt') initBowHunt(canvas, ctx, W, H);
      else if (type === 'fishing') initFishing(canvas, ctx, W, H);
      else if (type === 'grinding') initGrinding(canvas, ctx, W, H);
      else if (type === 'weaving') initWeaving(canvas, ctx, W, H);
      else if (type === 'knapping') initKnapping(canvas, ctx, W, H);
    }

    // BOW HUNTING GAME - DETAILED GRAPHICS
    function initBowHunt(canvas, ctx, W, H) {
      const gs = state.gameState;
      gs.bowDrawn = 0;
      gs.arrowFlying = false;
      gs.arrowX = 100;
      gs.arrowY = H - 100;
      gs.arrowVX = 0;
      gs.arrowVY = 0;
      gs.targets = [{ x: W - 100, y: H - 80, dir: -1, frame: 0 }];
      gs.aimAngle = 0;
      gs.particles = [];
      gs.frame = 0;
      
      let mouseDown = false;
      let mouseY = H / 2;
      
      canvas.onmousedown = canvas.ontouchstart = e => { mouseDown = true; e.preventDefault(); };
      canvas.onmouseup = canvas.ontouchend = e => {
        if (gs.bowDrawn > 0.3 && !gs.arrowFlying) {
          gs.arrowFlying = true;
          const power = gs.bowDrawn * 16;
          // Arrow flies RIGHT (positive X) and up based on aim
          gs.arrowVX = power;
          gs.arrowVY = gs.aimAngle * power * 0.8;
        }
        mouseDown = false;
        gs.bowDrawn = 0;
        e.preventDefault();
      };
      canvas.onmousemove = canvas.ontouchmove = e => {
        const rect = canvas.getBoundingClientRect();
        const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
        mouseY = y;
        // Aim angle: negative = up, positive = down
        gs.aimAngle = (H * 0.6 - y) / (H * 0.5);
        gs.aimAngle = Math.max(-0.8, Math.min(0.5, gs.aimAngle));
        e.preventDefault();
      };
      
      function drawDetailedDeer(x, y, scale = 1, walking = false, frame = 0) {
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(-scale, scale); // Flip to face left (toward archer)
        
        const legOffset = walking ? Math.sin(frame * 0.15) * 8 : 0;
        
        // Body
        ctx.fillStyle = '#A1887F';
        ctx.beginPath();
        ctx.ellipse(0, 0, 35, 22, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Neck
        ctx.beginPath();
        ctx.ellipse(30, -12, 10, 18, 0.4, 0, Math.PI * 2);
        ctx.fill();
        
        // Head
        ctx.beginPath();
        ctx.ellipse(45, -28, 10, 8, 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Snout
        ctx.fillStyle = '#8D6E63';
        ctx.beginPath();
        ctx.ellipse(55, -25, 5, 4, 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Ears
        ctx.fillStyle = '#A1887F';
        ctx.beginPath();
        ctx.ellipse(40, -38, 4, 8, -0.4, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#FFCCBC';
        ctx.beginPath();
        ctx.ellipse(40, -38, 2, 5, -0.4, 0, Math.PI * 2);
        ctx.fill();
        
        // Eye
        ctx.fillStyle = '#1a1a1a';
        ctx.beginPath();
        ctx.arc(50, -30, 2.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(49, -31, 1, 0, Math.PI * 2);
        ctx.fill();
        
        // Antlers
        ctx.strokeStyle = '#5D4037';
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(43, -35);
        ctx.lineTo(48, -50);
        ctx.lineTo(55, -48);
        ctx.moveTo(48, -50);
        ctx.lineTo(45, -55);
        ctx.moveTo(48, -45);
        ctx.lineTo(52, -42);
        ctx.stroke();
        
        // Legs
        ctx.fillStyle = '#8D6E63';
        ctx.strokeStyle = '#8D6E63';
        ctx.lineWidth = 5;
        ctx.lineCap = 'round';
        
        // Front legs
        ctx.beginPath();
        ctx.moveTo(-15, 18);
        ctx.lineTo(-18 + legOffset, 45);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(5, 20);
        ctx.lineTo(5 - legOffset, 45);
        ctx.stroke();
        
        // Back legs
        ctx.beginPath();
        ctx.moveTo(20, 18);
        ctx.lineTo(22 - legOffset, 45);
        ctx.stroke();
        
        // White belly
        ctx.fillStyle = '#EFEBE9';
        ctx.beginPath();
        ctx.ellipse(0, 12, 22, 8, 0, 0, Math.PI);
        ctx.fill();
        
        // Tail
        ctx.fillStyle = '#EFEBE9';
        ctx.beginPath();
        ctx.ellipse(-38, -5, 7, 5, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
      }
      
      function drawBowAndArcher(x, y, drawAmount, aimAngle) {
        ctx.save();
        ctx.translate(x, y);
        
        // Archer body (facing right)
        ctx.fillStyle = '#8D6E63';
        ctx.beginPath();
        ctx.ellipse(0, 0, 12, 18, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Head
        ctx.fillStyle = '#C68642';
        ctx.beginPath();
        ctx.arc(0, -28, 10, 0, Math.PI * 2);
        ctx.fill();
        
        // Hair
        ctx.fillStyle = '#2C1810';
        ctx.beginPath();
        ctx.arc(0, -32, 10, Math.PI, Math.PI * 2);
        ctx.fill();
        
        // Eyes looking right
        ctx.fillStyle = '#1a1a1a';
        ctx.beginPath();
        ctx.arc(5, -28, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Legs
        ctx.strokeStyle = '#6D4C41';
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(-5, 15);
        ctx.lineTo(-8, 45);
        ctx.moveTo(5, 15);
        ctx.lineTo(8, 45);
        ctx.stroke();
        
        // Arms and bow - rotated by aim angle
        ctx.save();
        ctx.translate(5, -5);
        ctx.rotate(-aimAngle * 0.5);
        
        // Back arm (holding bow)
        ctx.strokeStyle = '#C68642';
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(30, 0);
        ctx.stroke();
        
        // Front arm (pulling string)
        const pullBack = drawAmount * 25;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(10 - pullBack * 0.3, 5);
        ctx.stroke();
        
        // Bow
        ctx.strokeStyle = '#5D4037';
        ctx.lineWidth = 5;
        const bowX = 35;
        const bowCurve = 25 - drawAmount * 8;
        ctx.beginPath();
        ctx.moveTo(bowX, -30);
        ctx.quadraticCurveTo(bowX + bowCurve, 0, bowX, 30);
        ctx.stroke();
        
        // Bow detail
        ctx.strokeStyle = '#8D6E63';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(bowX, -28);
        ctx.quadraticCurveTo(bowX + bowCurve - 3, 0, bowX, 28);
        ctx.stroke();
        
        // String
        ctx.strokeStyle = '#4E342E';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(bowX, -30);
        ctx.lineTo(bowX - pullBack, 0);
        ctx.lineTo(bowX, 30);
        ctx.stroke();
        
        // Arrow on bow (if not flying)
        if (!gs.arrowFlying && drawAmount > 0.1) {
          ctx.fillStyle = '#8D6E63';
          ctx.fillRect(bowX - pullBack - 5, -2, 35, 4);
          // Arrowhead
          ctx.fillStyle = '#1a1a1a';
          ctx.beginPath();
          ctx.moveTo(bowX + 30, 0);
          ctx.lineTo(bowX + 38, -5);
          ctx.lineTo(bowX + 38, 5);
          ctx.closePath();
          ctx.fill();
          // Fletching
          ctx.fillStyle = '#C62828';
          ctx.beginPath();
          ctx.moveTo(bowX - pullBack - 5, 0);
          ctx.lineTo(bowX - pullBack - 12, -6);
          ctx.lineTo(bowX - pullBack - 12, 6);
          ctx.closePath();
          ctx.fill();
        }
        
        ctx.restore();
        ctx.restore();
      }
      
      function draw() {
        if (!state.minigameActive && !gs.arrowFlying) return;
        gs.frame++;
        
        // Sky
        const skyGrad = ctx.createLinearGradient(0, 0, 0, H * 0.65);
        skyGrad.addColorStop(0, '#81D4FA');
        skyGrad.addColorStop(1, '#E1F5FE');
        ctx.fillStyle = skyGrad;
        ctx.fillRect(0, 0, W, H);
        
        // Distant trees
        ctx.fillStyle = '#66BB6A';
        for (let i = 0; i < 8; i++) {
          ctx.beginPath();
          ctx.moveTo(i * 45, H * 0.65);
          ctx.lineTo(i * 45 + 20, H * 0.45);
          ctx.lineTo(i * 45 + 40, H * 0.65);
          ctx.fill();
        }
        
        // Ground
        ctx.fillStyle = '#7CB342';
        ctx.fillRect(0, H * 0.65, W, H * 0.35);
        
        // Grass
        ctx.strokeStyle = '#558B2F';
        ctx.lineWidth = 2;
        for (let i = 0; i < W; i += 12) {
          ctx.beginPath();
          ctx.moveTo(i, H * 0.65);
          ctx.lineTo(i + Math.sin(gs.frame * 0.02 + i) * 2, H * 0.65 - 8 - Math.random() * 4);
          ctx.stroke();
        }
        
        // Power meter
        if (mouseDown && !gs.arrowFlying) {
          gs.bowDrawn = Math.min(1, gs.bowDrawn + 0.025);
        }
        
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(10, 10, 80, 18);
        ctx.fillStyle = gs.bowDrawn > 0.7 ? '#4CAF50' : '#FFC107';
        ctx.fillRect(12, 12, gs.bowDrawn * 76, 14);
        ctx.fillStyle = '#fff';
        ctx.font = '10px sans-serif';
        ctx.fillText('POWER', 14, 23);
        
        // Archer with bow (on left side, facing right)
        drawBowAndArcher(60, H - 80, gs.bowDrawn, gs.aimAngle);
        
        // Flying arrow
        if (gs.arrowFlying) {
          gs.arrowX += gs.arrowVX;
          gs.arrowY -= gs.arrowVY;
          gs.arrowVY -= 0.35; // Gravity
          
          const arrowAngle = Math.atan2(-gs.arrowVY, gs.arrowVX);
          
          ctx.save();
          ctx.translate(gs.arrowX, gs.arrowY);
          ctx.rotate(arrowAngle);
          
          // Arrow shaft
          ctx.fillStyle = '#8D6E63';
          ctx.fillRect(-20, -2, 40, 4);
          
          // Arrowhead (pointing right, in direction of travel)
          ctx.fillStyle = '#1a1a1a';
          ctx.beginPath();
          ctx.moveTo(20, 0);
          ctx.lineTo(28, -5);
          ctx.lineTo(28, 5);
          ctx.closePath();
          ctx.fill();
          
          // Fletching (on the back)
          ctx.fillStyle = '#C62828';
          ctx.beginPath();
          ctx.moveTo(-20, 0);
          ctx.lineTo(-28, -6);
          ctx.lineTo(-28, 6);
          ctx.closePath();
          ctx.fill();
          
          ctx.restore();
          
          // Check hits
          gs.targets.forEach((t, i) => {
            if (Math.abs(gs.arrowX - t.x) < 50 && Math.abs(gs.arrowY - t.y) < 40) {
              state.minigameScore += 100;
              // Add particles
              for (let p = 0; p < 10; p++) {
                gs.particles.push({
                  x: t.x, y: t.y,
                  vx: (Math.random() - 0.5) * 8,
                  vy: -Math.random() * 5,
                  life: 30,
                  color: '#FFD54F'
                });
              }
              gs.targets.splice(i, 1);
              gs.arrowFlying = false;
              gs.arrowX = 100;
              gs.arrowY = H - 100;
              updateMinigameUI();
            }
          });
          
          // Reset if out of bounds
          if (gs.arrowX > W + 50 || gs.arrowY > H + 50 || gs.arrowY < -50 || gs.arrowX < -50) {
            gs.arrowFlying = false;
            gs.arrowX = 100;
            gs.arrowY = H - 100;
          }
        }
        
        // Deer targets (on right side, facing left toward archer)
        gs.targets.forEach(t => {
          t.x += t.dir * 0.8;
          t.frame++;
          if (t.x > W - 40 || t.x < W * 0.5) t.dir *= -1;
          drawDetailedDeer(t.x, t.y, 0.7, true, t.frame);
        });
        
        // Spawn new targets
        if (gs.targets.length < 2 && Math.random() < 0.015) {
          gs.targets.push({ x: W - 60, y: H - 60 - Math.random() * 50, dir: -1, frame: 0 });
        }
        
        // Particles
        gs.particles = gs.particles.filter(p => {
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.3;
          p.life--;
          ctx.fillStyle = p.color;
          ctx.globalAlpha = p.life / 30;
          ctx.beginPath();
          ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
          return p.life > 0;
        });
        
        // Aim guide line (faint)
        if (!gs.arrowFlying && gs.bowDrawn > 0.1) {
          ctx.strokeStyle = 'rgba(255,255,255,0.3)';
          ctx.setLineDash([5, 5]);
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(100, H - 85);
          const guideLen = 80;
          ctx.lineTo(100 + guideLen, H - 85 - gs.aimAngle * guideLen * 0.8);
          ctx.stroke();
          ctx.setLineDash([]);
        }
        
        requestAnimationFrame(draw);
      }
      draw();
    }

    // FISHING GAME - DETAILED GRAPHICS
    function initFishing(canvas, ctx, W, H) {
      const gs = state.gameState;
      gs.casting = false;
      gs.lineOut = false;
      gs.bobberX = 0;
      gs.bobberY = 0;
      gs.fishNear = false;
      gs.fishHooked = false;
      gs.reeling = false;
      gs.fishX = 0;
      gs.fishY = 0;
      gs.tension = 0;
      gs.hookWindow = 0;
      gs.ripples = [];
      gs.fish = [];
      gs.frame = 0;
      
      // Spawn some fish
      for (let i = 0; i < 4; i++) {
        gs.fish.push({
          x: 100 + Math.random() * (W - 150),
          y: H * 0.55 + Math.random() * 80,
          speed: 0.5 + Math.random() * 1,
          dir: Math.random() > 0.5 ? 1 : -1,
          type: Math.random() > 0.5 ? 'salmon' : 'trout',
          size: 0.6 + Math.random() * 0.4
        });
      }
      
      canvas.onclick = e => {
        if (!state.minigameActive) return;
        if (!gs.lineOut) {
          gs.lineOut = true;
          gs.bobberX = W * 0.55 + Math.random() * 80;
          gs.bobberY = H * 0.48;
          gs.fishNear = false;
          gs.hookWindow = 0;
          gs.ripples.push({ x: gs.bobberX, y: gs.bobberY, size: 5, alpha: 1 });
          setTimeout(() => {
            if (gs.lineOut && !gs.fishHooked) {
              gs.fishNear = true;
              gs.hookWindow = 90;
            }
          }, 1500 + Math.random() * 2000);
        } else if (gs.fishNear && gs.hookWindow > 0) {
          gs.fishHooked = true;
          gs.fishNear = false;
          gs.fishX = gs.bobberX;
          gs.fishY = gs.bobberY + 40;
          gs.reeling = true;
          gs.tension = 0.5;
        } else if (gs.fishHooked) {
          gs.tension = Math.min(1, gs.tension + 0.12);
        }
      };
      
      function drawDetailedFish(x, y, scale, type, dir) {
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(dir * scale, scale);
        
        const colors = type === 'salmon' ? 
          { body: '#E57373', belly: '#FFCDD2', fin: '#C62828', spots: '#B71C1C' } :
          { body: '#81C784', belly: '#C8E6C9', fin: '#388E3C', spots: '#1B5E20' };
        
        // Body
        ctx.fillStyle = colors.body;
        ctx.beginPath();
        ctx.ellipse(0, 0, 30, 14, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Gradient overlay
        const bodyGrad = ctx.createLinearGradient(0, -14, 0, 14);
        bodyGrad.addColorStop(0, 'rgba(255,255,255,0.3)');
        bodyGrad.addColorStop(0.5, 'rgba(255,255,255,0)');
        bodyGrad.addColorStop(1, 'rgba(0,0,0,0.2)');
        ctx.fillStyle = bodyGrad;
        ctx.beginPath();
        ctx.ellipse(0, 0, 30, 14, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Belly
        ctx.fillStyle = colors.belly;
        ctx.beginPath();
        ctx.ellipse(0, 6, 22, 6, 0, 0, Math.PI);
        ctx.fill();
        
        // Tail
        ctx.fillStyle = colors.fin;
        ctx.beginPath();
        ctx.moveTo(-30, 0);
        ctx.lineTo(-48, -18);
        ctx.quadraticCurveTo(-38, 0, -48, 18);
        ctx.closePath();
        ctx.fill();
        
        // Dorsal fin
        ctx.beginPath();
        ctx.moveTo(-5, -12);
        ctx.lineTo(0, -24);
        ctx.lineTo(12, -12);
        ctx.closePath();
        ctx.fill();
        
        // Pectoral fin
        ctx.beginPath();
        ctx.moveTo(5, 5);
        ctx.lineTo(15, 18);
        ctx.lineTo(-5, 10);
        ctx.closePath();
        ctx.fill();
        
        // Spots
        ctx.fillStyle = colors.spots;
        for (let i = 0; i < 5; i++) {
          ctx.beginPath();
          ctx.arc(-15 + i * 8, -3 + (i % 2) * 4, 2, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Eye
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(20, -3, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#1a1a1a';
        ctx.beginPath();
        ctx.arc(21, -3, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(20, -4, 1, 0, Math.PI * 2);
        ctx.fill();
        
        // Mouth
        ctx.strokeStyle = colors.spots;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(28, 2, 4, 0.5, Math.PI - 0.5);
        ctx.stroke();
        
        // Scales shimmer
        ctx.fillStyle = 'rgba(255,255,255,0.15)';
        for (let i = 0; i < 8; i++) {
          ctx.beginPath();
          ctx.arc(-20 + i * 6, 0, 4, 0, Math.PI * 2);
          ctx.fill();
        }
        
        ctx.restore();
      }
      
      function draw() {
        if (!state.minigameActive && !gs.fishHooked) return;
        gs.frame++;
        
        // Sky
        const skyGrad = ctx.createLinearGradient(0, 0, 0, H * 0.4);
        skyGrad.addColorStop(0, '#81D4FA');
        skyGrad.addColorStop(1, '#E1F5FE');
        ctx.fillStyle = skyGrad;
        ctx.fillRect(0, 0, W, H * 0.4);
        
        // Distant trees
        ctx.fillStyle = '#66BB6A';
        for (let i = 0; i < 6; i++) {
          ctx.beginPath();
          ctx.arc(W - 50 - i * 30, H * 0.35, 20, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Bank
        ctx.fillStyle = '#8D6E63';
        ctx.beginPath();
        ctx.moveTo(0, H * 0.35);
        ctx.quadraticCurveTo(W * 0.2, H * 0.32, W * 0.35, H * 0.45);
        ctx.lineTo(0, H);
        ctx.closePath();
        ctx.fill();
        
        // Grass on bank
        ctx.fillStyle = '#7CB342';
        ctx.beginPath();
        ctx.moveTo(0, H * 0.33);
        ctx.quadraticCurveTo(W * 0.15, H * 0.3, W * 0.3, H * 0.42);
        ctx.lineTo(0, H * 0.5);
        ctx.closePath();
        ctx.fill();
        
        // Water
        const waterGrad = ctx.createLinearGradient(0, H * 0.4, 0, H);
        waterGrad.addColorStop(0, '#4FC3F7');
        waterGrad.addColorStop(0.5, '#039BE5');
        waterGrad.addColorStop(1, '#01579B');
        ctx.fillStyle = waterGrad;
        ctx.fillRect(W * 0.3, H * 0.4, W * 0.7, H * 0.6);
        
        // Water surface shimmer
        ctx.fillStyle = 'rgba(255,255,255,0.1)';
        for (let i = 0; i < 10; i++) {
          const wx = W * 0.35 + i * 25 + Math.sin(gs.frame * 0.02 + i) * 5;
          ctx.beginPath();
          ctx.ellipse(wx, H * 0.42, 15, 3, 0, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Underwater fish
        gs.fish.forEach(f => {
          f.x += f.speed * f.dir;
          if (f.x > W - 30 || f.x < W * 0.35) f.dir *= -1;
          const swimY = f.y + Math.sin(gs.frame * 0.05 + f.x * 0.1) * 5;
          drawDetailedFish(f.x, swimY, f.size, f.type, f.dir);
        });
        
        // Fisher
        ctx.fillStyle = '#8D6E63';
        ctx.beginPath();
        ctx.ellipse(80, H * 0.45, 12, 18, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#C68642';
        ctx.beginPath();
        ctx.arc(80, H * 0.45 - 28, 11, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#2C1810';
        ctx.beginPath();
        ctx.arc(80, H * 0.45 - 32, 11, Math.PI, Math.PI * 2);
        ctx.fill();
        
        // Fishing rod
        ctx.strokeStyle = '#5D4037';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(95, H * 0.42);
        ctx.quadraticCurveTo(140, H * 0.25, 160, H * 0.3);
        ctx.stroke();
        
        // Rod tip
        ctx.strokeStyle = '#8D6E63';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(160, H * 0.3);
        ctx.lineTo(170, H * 0.28);
        ctx.stroke();
        
        // Fishing line
        if (gs.lineOut || gs.fishHooked) {
          ctx.strokeStyle = 'rgba(50,50,50,0.6)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(170, H * 0.28);
          ctx.quadraticCurveTo((170 + gs.bobberX) / 2, H * 0.35, gs.bobberX, gs.bobberY);
          ctx.stroke();
          
          // Bobber
          const bobble = gs.fishNear ? Math.sin(gs.frame * 0.3) * 8 : Math.sin(gs.frame * 0.05) * 2;
          
          // Bobber shadow in water
          ctx.fillStyle = 'rgba(0,0,0,0.2)';
          ctx.beginPath();
          ctx.ellipse(gs.bobberX + 3, gs.bobberY + bobble + 5, 8, 3, 0, 0, Math.PI * 2);
          ctx.fill();
          
          // Bobber
          ctx.fillStyle = '#fff';
          ctx.beginPath();
          ctx.ellipse(gs.bobberX, gs.bobberY + bobble - 4, 6, 6, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#F44336';
          ctx.beginPath();
          ctx.ellipse(gs.bobberX, gs.bobberY + bobble + 4, 6, 6, 0, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Ripples
        gs.ripples = gs.ripples.filter(r => {
          r.size += 1;
          r.alpha -= 0.02;
          ctx.strokeStyle = `rgba(255,255,255,${r.alpha})`;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.ellipse(r.x, r.y, r.size, r.size * 0.3, 0, 0, Math.PI * 2);
          ctx.stroke();
          return r.alpha > 0;
        });
        
        // Hook window indicator
        if (gs.fishNear && gs.hookWindow > 0) {
          gs.hookWindow--;
          
          // Exclamation
          ctx.fillStyle = '#FFD54F';
          ctx.font = 'bold 28px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('!', gs.bobberX, gs.bobberY - 30);
          
          // Splash effect
          if (gs.frame % 5 === 0) {
            gs.ripples.push({ x: gs.bobberX, y: gs.bobberY, size: 3, alpha: 0.8 });
          }
          
          if (gs.hookWindow <= 0) {
            gs.lineOut = false;
            gs.fishNear = false;
          }
        }
        
        // Hooked fish
        if (gs.fishHooked) {
          gs.tension -= 0.008;
          gs.fishX -= 1.5;
          gs.fishY -= 0.3;
          
          // Fish fighting
          const fightX = Math.sin(gs.frame * 0.2) * 10;
          drawDetailedFish(gs.fishX + fightX, gs.fishY, 0.8, 'salmon', -1);
          
          // Splash
          if (gs.frame % 8 === 0) {
            gs.ripples.push({ x: gs.fishX, y: H * 0.45, size: 5, alpha: 0.6 });
          }
          
          // Tension meter
          ctx.fillStyle = 'rgba(0,0,0,0.7)';
          ctx.fillRect(W - 35, 10, 25, 120);
          ctx.fillStyle = '#333';
          ctx.fillRect(W - 32, 13, 19, 114);
          
          const tensionColor = gs.tension > 0.8 ? '#F44336' : gs.tension > 0.5 ? '#FFC107' : '#4CAF50';
          ctx.fillStyle = tensionColor;
          ctx.fillRect(W - 32, 13 + (1 - gs.tension) * 114, 19, gs.tension * 114);
          
          ctx.fillStyle = '#fff';
          ctx.font = '8px sans-serif';
          ctx.textAlign = 'center';
          ctx.save();
          ctx.translate(W - 22, 70);
          ctx.rotate(-Math.PI / 2);
          ctx.fillText('TENSION', 0, 0);
          ctx.restore();
          
          if (gs.fishX < 120) {
            state.minigameScore += 150;
            gs.fishHooked = false;
            gs.lineOut = false;
            gs.reeling = false;
            updateMinigameUI();
          }
          if (gs.tension <= 0) {
            gs.fishHooked = false;
            gs.lineOut = false;
          }
        }
        
        // Instructions
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(8, H - 28, 150, 20);
        ctx.fillStyle = '#fff';
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'left';
        if (!gs.lineOut) ctx.fillText('üé£ Click to cast your line', 12, H - 13);
        else if (gs.fishHooked) ctx.fillText('üêü Click to reel in!', 12, H - 13);
        else ctx.fillText('‚è≥ Waiting for a bite...', 12, H - 13);
        
        requestAnimationFrame(draw);
      }
      draw();
    }

    // GRINDING GAME - DETAILED GRAPHICS
    function initGrinding(canvas, ctx, W, H) {
      const gs = state.gameState;
      gs.grinding = false;
      gs.lastY = 0;
      gs.direction = 0;
      gs.strokes = 0;
      gs.flour = 0;
      gs.pestleY = H/2;
      gs.particles = [];
      gs.frame = 0;
      
      canvas.onmousedown = canvas.ontouchstart = e => { gs.grinding = true; e.preventDefault(); };
      canvas.onmouseup = canvas.ontouchend = e => { gs.grinding = false; e.preventDefault(); };
      canvas.onmousemove = canvas.ontouchmove = e => {
        if (!gs.grinding || !state.minigameActive) return;
        const rect = canvas.getBoundingClientRect();
        const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
        const dir = y > gs.lastY ? 1 : -1;
        if (dir !== gs.direction && Math.abs(y - gs.lastY) > 5) {
          gs.direction = dir;
          gs.strokes++;
          if (gs.strokes % 2 === 0) {
            state.minigameScore += 10;
            gs.flour = Math.min(100, gs.flour + 3);
            // Add particles
            for (let i = 0; i < 5; i++) {
              gs.particles.push({
                x: W/2 + (Math.random() - 0.5) * 40,
                y: H/2 + 20,
                vx: (Math.random() - 0.5) * 3,
                vy: -Math.random() * 4 - 2,
                size: 2 + Math.random() * 3,
                life: 40,
                color: gs.flour > 70 ? '#F5F5DC' : '#D2B48C'
              });
            }
            updateMinigameUI();
          }
        }
        gs.lastY = y;
        gs.pestleY = Math.max(H/2 - 30, Math.min(H/2 + 40, y));
        e.preventDefault();
      };
      
      function draw() {
        if (!state.minigameActive) return;
        gs.frame++;
        
        // Background - outdoor scene
        const skyGrad = ctx.createLinearGradient(0, 0, 0, H * 0.5);
        skyGrad.addColorStop(0, '#87CEEB');
        skyGrad.addColorStop(1, '#E8F5E9');
        ctx.fillStyle = skyGrad;
        ctx.fillRect(0, 0, W, H);
        
        // Ground
        ctx.fillStyle = '#A1887F';
        ctx.fillRect(0, H * 0.65, W, H * 0.35);
        
        // Oak tree in background
        ctx.fillStyle = '#5D4037';
        ctx.fillRect(W - 60, H * 0.3, 20, H * 0.35);
        ctx.fillStyle = '#558B2F';
        ctx.beginPath();
        ctx.arc(W - 50, H * 0.25, 45, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#689F38';
        ctx.beginPath();
        ctx.arc(W - 70, H * 0.3, 35, 0, Math.PI * 2);
        ctx.arc(W - 30, H * 0.28, 30, 0, Math.PI * 2);
        ctx.fill();
        
        // Mortar base (large bedrock)
        ctx.fillStyle = '#757575';
        ctx.beginPath();
        ctx.ellipse(W/2, H * 0.68, 80, 25, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Mortar texture
        ctx.fillStyle = '#616161';
        for (let i = 0; i < 8; i++) {
          ctx.beginPath();
          ctx.ellipse(W/2 - 50 + i * 15, H * 0.68 + Math.random() * 10, 8, 4, 0, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Mortar bowl
        const mortarGrad = ctx.createRadialGradient(W/2, H/2 + 30, 10, W/2, H/2 + 30, 60);
        mortarGrad.addColorStop(0, '#9E9E9E');
        mortarGrad.addColorStop(0.7, '#757575');
        mortarGrad.addColorStop(1, '#616161');
        ctx.fillStyle = mortarGrad;
        
        ctx.beginPath();
        ctx.moveTo(W/2 - 55, H/2);
        ctx.quadraticCurveTo(W/2 - 65, H/2 + 50, W/2 - 40, H/2 + 70);
        ctx.lineTo(W/2 + 40, H/2 + 70);
        ctx.quadraticCurveTo(W/2 + 65, H/2 + 50, W/2 + 55, H/2);
        ctx.closePath();
        ctx.fill();
        
        // Inner bowl shadow
        ctx.fillStyle = '#424242';
        ctx.beginPath();
        ctx.ellipse(W/2, H/2 + 15, 42, 22, 0, 0, Math.PI);
        ctx.fill();
        
        // Contents (acorns ‚Üí flour)
        const contentsColor = `rgb(${Math.floor(210 - gs.flour * 0.7)}, ${Math.floor(180 - gs.flour * 0.3)}, ${Math.floor(140 - gs.flour * 0.2)})`;
        ctx.fillStyle = contentsColor;
        ctx.beginPath();
        ctx.ellipse(W/2, H/2 + 25, 38, 18, 0, 0, Math.PI);
        ctx.fill();
        
        // Acorn pieces (fade as flour increases)
        if (gs.flour < 80) {
          ctx.fillStyle = `rgba(139, 90, 43, ${1 - gs.flour/100})`;
          for (let i = 0; i < 6; i++) {
            ctx.beginPath();
            ctx.ellipse(W/2 - 25 + i * 10, H/2 + 20 + (i % 2) * 5, 6, 4, i * 0.5, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        
        // Pestle
        const py = gs.pestleY;
        
        // Pestle shadow
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.beginPath();
        ctx.ellipse(W/2 + 5, H/2 + 30, 18, 8, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Pestle stone
        const pestleGrad = ctx.createLinearGradient(W/2 - 15, 0, W/2 + 15, 0);
        pestleGrad.addColorStop(0, '#757575');
        pestleGrad.addColorStop(0.3, '#9E9E9E');
        pestleGrad.addColorStop(0.7, '#BDBDBD');
        pestleGrad.addColorStop(1, '#757575');
        ctx.fillStyle = pestleGrad;
        
        // Pestle head
        ctx.beginPath();
        ctx.ellipse(W/2, py, 16, 12, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Pestle shaft
        ctx.fillRect(W/2 - 10, py - 70, 20, 70);
        
        // Pestle top
        ctx.beginPath();
        ctx.ellipse(W/2, py - 70, 10, 5, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Pestle highlight
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.fillRect(W/2 - 3, py - 65, 6, 55);
        
        // Progress bar background
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(15, 15, 110, 24);
        
        // Progress bar
        const progressGrad = ctx.createLinearGradient(17, 0, 17 + gs.flour, 0);
        progressGrad.addColorStop(0, '#8D6E63');
        progressGrad.addColorStop(1, '#F5F5DC');
        ctx.fillStyle = progressGrad;
        ctx.fillRect(17, 17, gs.flour, 20);
        
        // Progress text
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 12px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText(`Flour: ${gs.flour}%`, 22, 32);
        
        // Particles
        gs.particles = gs.particles.filter(p => {
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.15;
          p.life--;
          ctx.fillStyle = p.color;
          ctx.globalAlpha = p.life / 40;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
          return p.life > 0;
        });
        
        // Instructions
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(W/2 - 85, H - 30, 170, 22);
        ctx.fillStyle = '#fff';
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('‚ÜïÔ∏è Move up & down to grind acorns!', W/2, H - 14);
        
        requestAnimationFrame(draw);
      }
      draw();
    }

    // WEAVING GAME - DETAILED GRAPHICS
    function initWeaving(canvas, ctx, W, H) {
      const gs = state.gameState;
      gs.pattern = [];
      gs.playerPattern = [];
      gs.showing = true;
      gs.showIndex = 0;
      gs.playerTurn = false;
      gs.playerIndex = 0;
      gs.frame = 0;
      gs.basketProgress = 0;
      gs.flash = -1;
      
      // Generate pattern
      for (let i = 0; i < 4; i++) {
        gs.pattern.push(Math.floor(Math.random() * 4));
      }
      
      const fiberColors = [
        { main: '#8D6E63', light: '#A1887F', name: 'Willow' },
        { main: '#D7CCC8', light: '#EFEBE9', name: 'Tule' },
        { main: '#5D4037', light: '#795548', name: 'Sedge' },
        { main: '#BCAAA4', light: '#D7CCC8', name: 'Rush' }
      ];
      
      const positions = [
        { x: W/2 - 65, y: H/2 - 50 },
        { x: W/2 + 65, y: H/2 - 50 },
        { x: W/2 - 65, y: H/2 + 50 },
        { x: W/2 + 65, y: H/2 + 50 }
      ];
      
      canvas.onclick = e => {
        if (!gs.playerTurn || !state.minigameActive) return;
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (W / rect.width);
        const y = (e.clientY - rect.top) * (H / rect.height);
        
        positions.forEach((p, i) => {
          if (Math.abs(x - p.x) < 50 && Math.abs(y - p.y) < 40) {
            gs.flash = i;
            setTimeout(() => gs.flash = -1, 200);
            
            gs.playerPattern.push(i);
            if (i === gs.pattern[gs.playerIndex]) {
              state.minigameScore += 25;
              gs.basketProgress = Math.min(100, gs.basketProgress + 5);
              gs.playerIndex++;
              updateMinigameUI();
              if (gs.playerIndex >= gs.pattern.length) {
                gs.pattern.push(Math.floor(Math.random() * 4));
                gs.playerPattern = [];
                gs.playerIndex = 0;
                gs.showing = true;
                gs.showIndex = 0;
                gs.playerTurn = false;
              }
            } else {
              gs.playerPattern = [];
              gs.playerIndex = 0;
              gs.showing = true;
              gs.showIndex = 0;
              gs.playerTurn = false;
            }
          }
        });
      };
      
      let showTimer = 0;
      function draw() {
        if (!state.minigameActive) return;
        gs.frame++;
        
        // Background
        ctx.fillStyle = '#4E342E';
        ctx.fillRect(0, 0, W, H);
        
        // Woven mat texture background
        ctx.strokeStyle = '#3E2723';
        ctx.lineWidth = 1;
        for (let i = 0; i < W; i += 15) {
          ctx.beginPath();
          ctx.moveTo(i, 0);
          ctx.lineTo(i, H);
          ctx.stroke();
        }
        for (let i = 0; i < H; i += 15) {
          ctx.beginPath();
          ctx.moveTo(0, i);
          ctx.lineTo(W, i);
          ctx.stroke();
        }
        
        // Title
        ctx.fillStyle = '#FFECB3';
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Weave the Pattern!', W/2, 25);
        
        // Fiber bundle options
        positions.forEach((p, i) => {
          const fiber = fiberColors[i];
          const highlight = (gs.showing && gs.pattern[gs.showIndex] === i) || gs.flash === i;
          
          // Bundle shadow
          ctx.fillStyle = 'rgba(0,0,0,0.3)';
          ctx.beginPath();
          ctx.ellipse(p.x + 3, p.y + 35, 42, 12, 0, 0, Math.PI * 2);
          ctx.fill();
          
          // Bundle container
          ctx.fillStyle = highlight ? '#FFD54F' : '#5D4037';
          ctx.strokeStyle = highlight ? '#FFC107' : '#3E2723';
          ctx.lineWidth = 3;
          ctx.beginPath();
          // Manual rounded rect for browser compatibility
          const rx = p.x - 45, ry = p.y - 30, rw = 90, rh = 60, radius = 10;
          ctx.moveTo(rx + radius, ry);
          ctx.lineTo(rx + rw - radius, ry);
          ctx.quadraticCurveTo(rx + rw, ry, rx + rw, ry + radius);
          ctx.lineTo(rx + rw, ry + rh - radius);
          ctx.quadraticCurveTo(rx + rw, ry + rh, rx + rw - radius, ry + rh);
          ctx.lineTo(rx + radius, ry + rh);
          ctx.quadraticCurveTo(rx, ry + rh, rx, ry + rh - radius);
          ctx.lineTo(rx, ry + radius);
          ctx.quadraticCurveTo(rx, ry, rx + radius, ry);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          
          // Fiber strands
          for (let j = 0; j < 8; j++) {
            const strand = j % 2 === 0 ? fiber.main : fiber.light;
            ctx.strokeStyle = strand;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(p.x - 35 + j * 9, p.y - 20);
            ctx.quadraticCurveTo(p.x - 35 + j * 9 + Math.sin(gs.frame * 0.02 + j) * 3, p.y, p.x - 35 + j * 9, p.y + 20);
            ctx.stroke();
          }
          
          // Label
          ctx.fillStyle = '#fff';
          ctx.font = '10px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText(fiber.name, p.x, p.y + 48);
        });
        
        // Show pattern
        if (gs.showing) {
          showTimer++;
          if (showTimer > 50) {
            showTimer = 0;
            gs.showIndex++;
            if (gs.showIndex >= gs.pattern.length) {
              gs.showing = false;
              gs.playerTurn = true;
            }
          }
        }
        
        // Basket progress (side panel)
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(W - 55, 40, 45, 180);
        
        // Basket visualization
        const basketLayers = Math.floor(gs.basketProgress / 10);
        for (let i = 0; i < basketLayers; i++) {
          ctx.strokeStyle = fiberColors[i % 4].main;
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.ellipse(W - 32, 200 - i * 15, 15 + i, 6, 0, 0, Math.PI * 2);
          ctx.stroke();
        }
        
        ctx.fillStyle = '#fff';
        ctx.font = '9px sans-serif';
        ctx.fillText(`${gs.basketProgress}%`, W - 32, 215);
        
        // Instructions
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(W/2 - 90, H - 35, 180, 25);
        ctx.fillStyle = '#FFD54F';
        ctx.font = '12px sans-serif';
        ctx.textAlign = 'center';
        if (gs.showing) {
          ctx.fillText(`üëÄ Watch... (${gs.showIndex + 1}/${gs.pattern.length})`, W/2, H - 18);
        } else {
          ctx.fillText(`üß∫ Your turn! (${gs.playerIndex}/${gs.pattern.length})`, W/2, H - 18);
        }
        
        requestAnimationFrame(draw);
      }
      draw();
    }

    // KNAPPING GAME - DETAILED GRAPHICS
    function initKnapping(canvas, ctx, W, H) {
      const gs = state.gameState;
      gs.chips = [];
      gs.sparks = [];
      gs.shape = 100;
      gs.hits = 0;
      gs.frame = 0;
      gs.obsidianPoints = [];
      gs.shapeQuality = 0;
      
      // Define target arrowhead shape
      const targetShape = [
        { x: 0, y: -50 },
        { x: 25, y: 30 },
        { x: 0, y: 15 },
        { x: -25, y: 30 }
      ];
      
      // Current rough obsidian shape (starts as irregular blob)
      gs.obsidianPoints = [
        { x: 0, y: -45, hit: false },
        { x: 30, y: -30, hit: false },
        { x: 40, y: 0, hit: false },
        { x: 35, y: 35, hit: false },
        { x: 10, y: 45, hit: false },
        { x: -10, y: 45, hit: false },
        { x: -35, y: 35, hit: false },
        { x: -40, y: 0, hit: false },
        { x: -30, y: -30, hit: false }
      ];
      
      canvas.onclick = e => {
        if (!state.minigameActive) return;
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (W / rect.width) - W/2;
        const y = (e.clientY - rect.top) * (H / rect.height) - H/2;
        
        // Find closest edge point
        let closest = null;
        let closestDist = Infinity;
        gs.obsidianPoints.forEach((p, i) => {
          if (p.hit) return;
          const dist = Math.hypot(x - p.x, y - p.y);
          if (dist < closestDist && dist < 30) {
            closest = i;
            closestDist = dist;
          }
        });
        
        if (closest !== null) {
          gs.hits++;
          const p = gs.obsidianPoints[closest];
          
          // Move point inward toward target shape
          const targetP = targetShape[Math.floor(closest / gs.obsidianPoints.length * targetShape.length)];
          p.x = p.x * 0.7 + targetP.x * 0.3;
          p.y = p.y * 0.7 + targetP.y * 0.3;
          
          // Add chip
          gs.chips.push({
            x: W/2 + p.x + (Math.random() - 0.5) * 20,
            y: H/2 + p.y + (Math.random() - 0.5) * 20,
            vx: (Math.random() - 0.5) * 5,
            vy: Math.random() * 3 + 2,
            rot: Math.random() * Math.PI * 2,
            size: 4 + Math.random() * 6,
            life: 60
          });
          
          // Add sparks
          for (let i = 0; i < 8; i++) {
            gs.sparks.push({
              x: W/2 + p.x,
              y: H/2 + p.y,
              vx: (Math.random() - 0.5) * 8,
              vy: -Math.random() * 6 - 2,
              life: 20 + Math.random() * 10
            });
          }
          
          state.minigameScore += 15;
          gs.shapeQuality = Math.min(100, gs.shapeQuality + 4);
          updateMinigameUI();
        }
      };
      
      function drawObsidian() {
        ctx.save();
        ctx.translate(W/2, H/2);
        
        // Draw target outline (faint)
        ctx.strokeStyle = 'rgba(255,255,255,0.15)';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(targetShape[0].x, targetShape[0].y);
        targetShape.forEach(p => ctx.lineTo(p.x, p.y));
        ctx.closePath();
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Draw current obsidian
        ctx.fillStyle = '#1a1a1a';
        ctx.beginPath();
        ctx.moveTo(gs.obsidianPoints[0].x, gs.obsidianPoints[0].y);
        gs.obsidianPoints.forEach(p => ctx.lineTo(p.x, p.y));
        ctx.closePath();
        ctx.fill();
        
        // Obsidian shine/reflection
        ctx.fillStyle = 'rgba(255,255,255,0.2)';
        ctx.beginPath();
        ctx.moveTo(-5, -30);
        ctx.lineTo(10, -35);
        ctx.lineTo(5, 0);
        ctx.lineTo(-10, -5);
        ctx.closePath();
        ctx.fill();
        
        // Edge highlights where not yet chipped
        gs.obsidianPoints.forEach((p, i) => {
          if (!p.hit) {
            ctx.fillStyle = 'rgba(100,100,100,0.5)';
            ctx.beginPath();
            ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
            ctx.fill();
          }
        });
        
        ctx.restore();
      }
      
      function draw() {
        if (!state.minigameActive) return;
        gs.frame++;
        
        // Background - work area
        ctx.fillStyle = '#A1887F';
        ctx.fillRect(0, 0, W, H);
        
        // Work surface texture
        ctx.fillStyle = '#8D6E63';
        for (let i = 0; i < 50; i++) {
          ctx.beginPath();
          ctx.ellipse(Math.random() * W, Math.random() * H, 5 + Math.random() * 10, 3 + Math.random() * 5, Math.random() * Math.PI, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Leather work pad
        ctx.fillStyle = '#6D4C41';
        ctx.beginPath();
        ctx.ellipse(W/2, H/2 + 20, 80, 60, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#5D4037';
        ctx.lineWidth = 3;
        ctx.stroke();
        
        // Draw obsidian
        drawObsidian();
        
        // Hammerstone (follows mouse slightly)
        const hammerX = W - 60;
        const hammerY = 60;
        
        ctx.fillStyle = '#757575';
        ctx.beginPath();
        ctx.ellipse(hammerX, hammerY, 20, 16, 0.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#9E9E9E';
        ctx.beginPath();
        ctx.ellipse(hammerX - 3, hammerY - 3, 8, 6, 0.2, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#fff';
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Hammerstone', hammerX, hammerY + 30);
        
        // Fallen chips
        gs.chips = gs.chips.filter(c => {
          c.x += c.vx;
          c.y += c.vy;
          c.vy += 0.2;
          c.rot += 0.1;
          c.life--;
          
          ctx.save();
          ctx.translate(c.x, c.y);
          ctx.rotate(c.rot);
          ctx.fillStyle = '#2d2d2d';
          ctx.beginPath();
          ctx.moveTo(-c.size/2, -c.size/3);
          ctx.lineTo(c.size/2, -c.size/4);
          ctx.lineTo(c.size/3, c.size/3);
          ctx.lineTo(-c.size/3, c.size/4);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
          
          return c.life > 0 && c.y < H + 20;
        });
        
        // Sparks
        gs.sparks = gs.sparks.filter(s => {
          s.x += s.vx;
          s.y += s.vy;
          s.vy += 0.3;
          s.life--;
          
          ctx.fillStyle = `rgba(255, ${180 + Math.random() * 75}, 0, ${s.life / 30})`;
          ctx.beginPath();
          ctx.arc(s.x, s.y, 2, 0, Math.PI * 2);
          ctx.fill();
          
          return s.life > 0;
        });
        
        // Progress indicator
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(10, 10, 120, 45);
        
        ctx.fillStyle = '#fff';
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText('Shape Quality:', 15, 26);
        
        ctx.fillStyle = '#333';
        ctx.fillRect(15, 32, 100, 15);
        ctx.fillStyle = gs.shapeQuality > 70 ? '#4CAF50' : gs.shapeQuality > 40 ? '#FFC107' : '#F44336';
        ctx.fillRect(15, 32, gs.shapeQuality, 15);
        
        // Instructions
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(W/2 - 100, H - 32, 200, 24);
        ctx.fillStyle = '#FFD54F';
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('ü™® Click edges to chip into arrowhead!', W/2, H - 15);
        
        requestAnimationFrame(draw);
      }
      draw();
    }

    // ============================================
    // RENDERING
    // ============================================
    function render() {
      const levelInfo = getLevelInfo(state.xp);
      const progress = levelInfo.nextLevel ? (levelInfo.xpProgress / levelInfo.xpForNext) * 100 : 100;
      
      document.getElementById('app').innerHTML = `
        <div class="header">
          <h1>‚ö±Ô∏è Artifact Hunter<span class="demo-badge">DEMO</span></h1>
          <div class="header-stats">
            <span class="level-badge">Lv.${levelInfo.level}</span>
            <div class="xp-bar-container"><div class="xp-bar" style="width:${progress}%"></div></div>
            <span>${state.xp} XP</span>
          </div>
        </div>
        <div class="instructions">üëÜ Tap to move ‚Ä¢ ${state.artifacts.length} artifacts nearby</div>
        <div id="map"></div>
        <div class="key-hint"><kbd>WASD</kbd> move ‚Ä¢ <kbd>Q</kbd> zoom in ‚Ä¢ <kbd>E</kbd> zoom out</div>
        <div class="bottom-nav">
          <button class="nav-btn" onclick="showCollection()">üìú Collection</button>
          <button class="nav-btn" onclick="showMinigames()">üéÆ Games</button>
          <button class="nav-btn" onclick="showAchievements()">üèÜ Badges</button>
        </div>
        ${state.cleaningArtifact ? renderCleaning() : ''}
        ${state.showingCutscene ? renderCutscene() : ''}
        ${state.foundArtifact ? renderFound() : ''}
        ${state.showLevelUp ? renderLevelUp() : ''}
        ${state.playingMinigame ? renderMinigame() : ''}
        ${state.showingModal === 'collection' ? renderCollectionModal() : ''}
        ${state.showingModal === 'minigames' ? renderMinigamesModal() : ''}
        ${state.showingModal === 'achievements' ? renderAchievementsModal() : ''}
      `;
      
      setTimeout(() => {
        const mapEl = document.getElementById('map');
        if (!state.map && mapEl && !state.cleaningArtifact && !state.showingCutscene && !state.foundArtifact && !state.showLevelUp && !state.playingMinigame && !state.showingModal) { 
          initMap(); 
          initArtifacts(); 
        }
        if (state.cleaningArtifact) {
          setupCleaning();
        }
      }, 50);
    }

    function renderCleaning() {
      return `<div class="cleaning-overlay">
        <div class="cleaning-title">üñåÔ∏è Excavate the Artifact!</div>
        <div class="cleaning-instructions">Brush back and forth to clear the dirt!</div>
        <div class="cleaning-area">
          <div class="artifact-reveal">${state.cleaningArtifact.emoji}</div>
          <canvas id="dirtCanvas" width="280" height="280"></canvas>
        </div>
        <div class="cleaning-progress">
          <div class="cleaning-progress-bar" id="cleaningBar" style="width: 0%"></div>
        </div>
        <div class="cleaning-progress-label" id="cleaningLabel">0% cleared</div>
      </div>`;
    }

    function renderCutscene() {
      const captions = {
        bow_hunt: 'The hunter draws back their bow, eyes fixed on the deer grazing in the meadow...',
        grinding: 'Day after day, the acorns are ground into flour to feed the village...',
        weaving: 'Patient hands weave willow and sedge into baskets that will last generations...',
        fishing: 'By the creek, a patient fisher waits for the salmon to bite...',
        ceremony: 'The village gathers as sacred songs fill the night air...',
        knapping: 'Sparks fly as obsidian is carefully shaped into razor-sharp tools...',
        trading: 'Shell beads change hands as tribes trade goods from across California...',
        gathering: 'Families work together to gather the autumn acorn harvest...',
        cooking: 'Hot stones drop into the basket, and the water begins to boil...',
        scraping: 'The hide is stretched and scraped clean for tanning...',
        chopping: 'The stone axe bites into wood as a new shelter takes shape...'
      };
      return `<div class="cutscene-overlay" onclick="endCutscene()">
        <div class="cutscene-title">üëÅÔ∏è Vision of the Past</div>
        <canvas id="cutsceneCanvas" width="380" height="280"></canvas>
        <div class="cutscene-caption">${captions[state.showingCutscene.cutscene] || state.showingCutscene.description}</div>
        <div class="cutscene-skip">Tap to continue...</div>
      </div>`;
    }

    function renderFound() {
      const a = state.foundArtifact;
      return `<div class="found-overlay" onclick="dismissFound()"><div class="emoji">${a.emoji}</div><h2>Collected!</h2><div class="artifact-name">${a.name}</div><div class="rarity-badge rarity-${a.rarity}">${a.rarity.toUpperCase()}</div><div class="xp-earned">+${a.xpGained} XP</div><p class="description">${a.description}</p><div class="cultural-note"><h4>üìö Did You Know?</h4><p>${a.culturalNote}</p></div>${a.minigame ? `<div class="minigame-unlock"><h4>üéÆ ${MINIGAMES[a.minigame].name} Unlocked!</h4></div>` : ''}<button class="nav-btn">Continue</button></div>`;
    }

    function renderLevelUp() {
      return `<div class="levelup-overlay" onclick="dismissLevelUp()"><h1>‚¨ÜÔ∏è LEVEL UP!</h1><div class="level-num">${state.newLevel.level}</div><div class="reward">${state.newLevel.title}</div><button class="nav-btn">Continue</button></div>`;
    }

    function renderMinigame() {
      const g = MINIGAMES[state.playingMinigame];
      return `<div class="minigame-overlay">
        <div class="minigame-header">
          <h2>${g.emoji} ${g.name}</h2>
          <p>${g.desc}</p>
        </div>
        <div class="minigame-score" id="mgScore">${state.minigameScore}</div>
        <div class="minigame-timer" id="mgTimer">${state.minigameActive ? `‚è±Ô∏è ${state.minigameTimer}s` : 'üèÅ Done!'}</div>
        <div class="game-canvas-container">
          <canvas id="gameCanvas" width="340" height="300"></canvas>
        </div>
        ${!state.minigameActive ? renderLeaderboard() : ''}
        <button class="nav-btn" style="margin-top:15px" onclick="exitMinigame()">${state.minigameActive ? '‚ùå Quit' : '‚úì Done'}</button>
      </div>`;
    }

    function renderLeaderboard() {
      const game = state.playingMinigame;
      const scores = [
        { name: 'OaklandKid', score: 850 },
        { name: 'ArtifactPro', score: 720 },
        { name: 'You', score: state.highScores[game] || 0, you: true },
        { name: 'Explorer', score: 400 }
      ].sort((a, b) => b.score - a.score);
      return `<div class="leaderboard"><h3>üèÜ Leaderboard</h3>${scores.map((s, i) => `<div class="leaderboard-entry ${s.you ? 'you' : ''}"><span class="leaderboard-rank">#${i+1}</span><span class="leaderboard-name">${s.name}</span><span class="leaderboard-score">${s.score}</span></div>`).join('')}</div>`;
    }

    function renderCollectionModal() {
      const collected = new Set(state.collection.map(a => a.name));
      return `<div class="modal-overlay" onclick="closeModal(event)"><div class="modal" onclick="event.stopPropagation()"><div class="modal-header"><h2>üìú Collection (${collected.size}/${ARTIFACT_TYPES.length})</h2><button class="close-btn" onclick="closeModal()">&times;</button></div><div class="modal-body"><div class="collection-grid">${ARTIFACT_TYPES.map(a => `<div class="artifact-card ${collected.has(a.name) ? '' : 'locked'}"><div class="emoji">${collected.has(a.name) ? a.emoji : '‚ùì'}</div><div class="name">${collected.has(a.name) ? a.name : '???'}</div><div class="rarity rarity-${a.rarity}">${a.rarity}</div></div>`).join('')}</div></div></div></div>`;
    }

    function renderMinigamesModal() {
      return `<div class="modal-overlay" onclick="closeModal(event)"><div class="modal" onclick="event.stopPropagation()"><div class="modal-header"><h2>üéÆ Mini-Games</h2><button class="close-btn" onclick="closeModal()">&times;</button></div><div class="modal-body"><p style="margin-bottom:16px;color:#aaa">Unlock games by finding artifacts!</p><div class="minigame-grid">${Object.entries(MINIGAMES).map(([id, g]) => {
        const unlocked = state.unlockedMinigames.includes(id);
        return `<div class="minigame-card ${unlocked ? '' : 'locked'}" onclick="${unlocked ? `playMinigame('${id}')` : ''}"><div class="emoji">${unlocked ? g.emoji : 'üîí'}</div><div class="name">${g.name}</div><div class="high-score">${unlocked ? 'Best: ' + (state.highScores[id] || 0) : 'Locked'}</div></div>`;
      }).join('')}</div></div></div></div>`;
    }

    function renderAchievementsModal() {
      const li = getLevelInfo(state.xp);
      return `<div class="modal-overlay" onclick="closeModal(event)"><div class="modal" onclick="event.stopPropagation()"><div class="modal-header"><h2>üèÜ Achievements</h2><button class="close-btn" onclick="closeModal()">&times;</button></div><div class="modal-body"><div class="stats-panel"><div class="stats-row"><span class="stats-label">Level</span><span class="stats-value">${li.level} - ${li.title}</span></div><div class="stats-row"><span class="stats-label">XP</span><span class="stats-value">${state.xp}</span></div><div class="stats-row"><span class="stats-label">Artifacts</span><span class="stats-value">${state.collection.length}</span></div></div><h3>Badges</h3><div class="achievements-grid">${ACHIEVEMENTS.map(a => `<div class="achievement-card ${state.unlockedAchievements.includes(a.id) ? 'unlocked' : 'locked'}"><div class="emoji">${state.unlockedAchievements.includes(a.id) ? a.emoji : 'üîí'}</div><div class="name">${a.name}</div><div class="desc">${a.desc}</div></div>`).join('')}</div><button class="nav-btn" style="width:100%;margin-top:16px" onclick="resetGame()">üóëÔ∏è Reset</button></div></div></div>`;
    }

    function setupCleaning() {
      const canvas = document.getElementById('dirtCanvas');
      if (!canvas || !state.cleaningArtifact) return;
      const ctx = canvas.getContext('2d');
      const W = canvas.width, H = canvas.height;
      
      // Prevent double-triggering
      let hasCompleted = false;
      
      // Clear canvas to fully transparent first
      ctx.clearRect(0, 0, W, H);
      
      // Draw ONLY dirt on the canvas - the artifact emoji is in HTML behind the canvas
      // When we erase the dirt, the HTML emoji will show through
      
      // Base dirt layer
      ctx.fillStyle = '#5D4E37';
      ctx.fillRect(0, 0, W, H);
      
      // Add dirt texture variation
      for (let i = 0; i < 300; i++) {
        ctx.fillStyle = ['#4A3F2F', '#6B5A45', '#3a3025', '#5D4E37'][Math.floor(Math.random() * 4)];
        ctx.beginPath();
        ctx.arc(Math.random() * W, Math.random() * H, Math.random() * 12 + 4, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Add pebbles
      for (let i = 0; i < 25; i++) {
        ctx.fillStyle = '#2a2520';
        ctx.beginPath();
        ctx.ellipse(Math.random() * W, Math.random() * H, Math.random() * 6 + 3, Math.random() * 4 + 2, Math.random() * Math.PI, 0, Math.PI * 2);
        ctx.fill();
      }
      
      let drawing = false, lastX = 0, lastY = 0, lastPositions = [];
      let totalCleared = 0;
      
      function getPos(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = W / rect.width, scaleY = H / rect.height;
        const touch = e.touches ? e.touches[0] : e;
        return { x: (touch.clientX - rect.left) * scaleX, y: (touch.clientY - rect.top) * scaleY };
      }
      
      function brush(x, y) {
        if (hasCompleted) return; // Prevent further processing after completion
        
        lastPositions.push({ x, y });
        if (lastPositions.length > 8) lastPositions.shift();
        if (lastPositions.length < 3) return;
        
        let dist = 0;
        for (let i = 1; i < lastPositions.length; i++) {
          dist += Math.hypot(lastPositions[i].x - lastPositions[i-1].x, lastPositions[i].y - lastPositions[i-1].y);
        }
        if (dist < 10) return; // Need brushing motion
        
        // Erase dirt pixels to make them transparent
        // This reveals the HTML artifact-reveal div underneath
        ctx.globalCompositeOperation = 'destination-out';
        ctx.fillStyle = 'rgba(255,255,255,1)';
        ctx.beginPath();
        ctx.arc(x, y, 28, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalCompositeOperation = 'source-over';
        
        totalCleared += 1;
        const pct = Math.min(100, totalCleared * 0.7);
        
        const bar = document.getElementById('cleaningBar');
        const label = document.getElementById('cleaningLabel');
        if (bar) bar.style.width = pct + '%';
        if (label) label.textContent = Math.round(pct) + '% cleared';
        
        if (pct >= 65 && !hasCompleted) {
          hasCompleted = true; // Prevent multiple triggers
          setTimeout(() => {
            if (state.cleaningArtifact) {
              showCutscene(state.cleaningArtifact);
            }
          }, 300);
        }
      }
      
      function start(e) { drawing = true; lastPositions = []; const p = getPos(e); lastX = p.x; lastY = p.y; e.preventDefault(); }
      function move(e) {
        if (!drawing || hasCompleted) return;
        const p = getPos(e);
        const steps = Math.max(1, Math.floor(Math.hypot(p.x - lastX, p.y - lastY) / 5));
        for (let i = 0; i <= steps; i++) brush(lastX + (p.x - lastX) * i / steps, lastY + (p.y - lastY) * i / steps);
        lastX = p.x; lastY = p.y;
        e.preventDefault();
      }
      function end() { drawing = false; lastPositions = []; }
      
      canvas.addEventListener('mousedown', start);
      canvas.addEventListener('mousemove', move);
      canvas.addEventListener('mouseup', end);
      canvas.addEventListener('mouseleave', end);
      canvas.addEventListener('touchstart', start);
      canvas.addEventListener('touchmove', move);
      canvas.addEventListener('touchend', end);
    }

    // ============================================
    // ACTIONS
    // ============================================
    window.showCollection = () => { state.showingModal = 'collection'; render(); };
    window.showMinigames = () => { state.showingModal = 'minigames'; render(); };
    window.showAchievements = () => { state.showingModal = 'achievements'; render(); };
    window.closeModal = e => { if (!e || e.target.classList.contains('modal-overlay')) { state.showingModal = null; if (state.map) { state.map.remove(); state.map = null; } render(); } };
    window.dismissFound = () => { 
      state.foundArtifact = null; 
      if (state.map) { 
        state.map.remove(); 
        state.map = null; 
      } 
      render(); 
      // After render, the map will be reinitialized via setTimeout in render()
      // We need to update artifact markers after map is ready
      setTimeout(() => {
        if (state.map) {
          updateArtifactMarkers();
        }
      }, 200);
    };
    window.dismissLevelUp = () => { state.showLevelUp = false; state.newLevel = null; render(); };
    window.endCutscene = () => { if (window.currentCutsceneAnimation) cancelAnimationFrame(window.currentCutsceneAnimation); completeCutscene(); };
    window.playMinigame = id => { state.showingModal = null; if (state.map) { state.map.remove(); state.map = null; } startMinigame(id); };
    window.exitMinigame = () => { state.playingMinigame = null; state.minigameActive = false; if (state.map) { state.map.remove(); state.map = null; } render(); };
    window.resetGame = () => { if (confirm('Reset?')) { state.collection = []; state.xp = 0; state.unlockedAchievements = []; state.unlockedMinigames = []; state.highScores = {}; saveGame(); closeModal(); } };

    // ============================================
    // INIT
    // ============================================
    function init() {
      if (typeof L === 'undefined') { setTimeout(init, 100); return; }
      loadGame();
      checkAchievements();
      render();
    }
    if (document.readyState === 'complete') init();
    else window.addEventListener('load', init);
  </script>
</body>
</html>
