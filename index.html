<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Artifact Hunter - Oakland</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #1a1a2e;
      color: #eee;
      overflow: hidden;
      height: 100vh;
      height: 100dvh;
    }
    #app { height: 100%; display: flex; flex-direction: column; }
    
    .header {
      background: linear-gradient(135deg, #2d1b0e 0%, #1a1a2e 100%);
      padding: 10px 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 2px solid #c9a227;
      z-index: 1000;
    }
    .header h1 { font-size: 1.1rem; color: #c9a227; }
    .demo-badge {
      background: #c9a227;
      color: #1a1a2e;
      padding: 2px 8px;
      border-radius: 10px;
      font-size: 0.7rem;
      font-weight: bold;
      margin-left: 8px;
    }
    .header-stats { display: flex; gap: 12px; font-size: 0.8rem; align-items: center; }
    .level-badge {
      background: linear-gradient(135deg, #c9a227, #a68523);
      color: #1a1a2e;
      padding: 4px 10px;
      border-radius: 12px;
      font-weight: bold;
      font-size: 0.75rem;
    }
    .xp-bar-container { width: 80px; height: 8px; background: #333; border-radius: 4px; overflow: hidden; }
    .xp-bar { height: 100%; background: linear-gradient(90deg, #c9a227, #f0d878); transition: width 0.5s ease; }
    
    #map { flex: 1; z-index: 1; cursor: crosshair; }
    
    .instructions {
      background: rgba(201, 162, 39, 0.15);
      border-bottom: 1px solid #c9a227;
      padding: 6px 16px;
      text-align: center;
      font-size: 0.8rem;
      color: #c9a227;
    }
    
    .bottom-nav {
      background: linear-gradient(135deg, #2d1b0e 0%, #1a1a2e 100%);
      padding: 10px;
      display: flex;
      justify-content: space-around;
      border-top: 2px solid #c9a227;
      z-index: 1000;
    }
    .nav-btn {
      background: rgba(201, 162, 39, 0.2);
      border: 2px solid #c9a227;
      color: #c9a227;
      padding: 8px 14px;
      border-radius: 25px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.3s;
    }
    .nav-btn:hover, .nav-btn.active {
      background: #c9a227;
      color: #1a1a2e;
    }
    
    .modal-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.9);
      z-index: 2000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    .modal {
      background: linear-gradient(135deg, #2d1b0e 0%, #1a1a2e 100%);
      border: 2px solid #c9a227;
      border-radius: 16px;
      width: 100%;
      max-width: 500px;
      max-height: 85vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    .modal-header {
      padding: 14px 16px;
      border-bottom: 1px solid #c9a227;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .modal-header h2 { color: #c9a227; font-size: 1.1rem; }
    .close-btn { background: none; border: none; color: #c9a227; font-size: 1.5rem; cursor: pointer; }
    .modal-body { padding: 16px; overflow-y: auto; flex: 1; }
    .modal-body h3 { color: #c9a227; margin: 16px 0 8px 0; font-size: 0.95rem; }
    .modal-body h3:first-child { margin-top: 0; }
    .modal-body p { line-height: 1.5; margin-bottom: 10px; color: #ccc; font-size: 0.9rem; }
    
    .collection-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      gap: 8px;
    }
    .artifact-card {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      padding: 10px 6px;
      text-align: center;
      border: 2px solid transparent;
      cursor: pointer;
      transition: all 0.3s;
    }
    .artifact-card:hover { border-color: #c9a227; transform: translateY(-2px); }
    .artifact-card.locked { opacity: 0.4; filter: grayscale(1); cursor: default; }
    .artifact-card .emoji { font-size: 2rem; margin-bottom: 4px; }
    .artifact-card .name { font-size: 0.7rem; font-weight: 600; margin-bottom: 4px; }
    .artifact-card .rarity { font-size: 0.6rem; padding: 2px 6px; border-radius: 8px; display: inline-block; }
    
    .rarity-common { background: #6b7280; }
    .rarity-uncommon { background: #047857; }
    .rarity-rare { background: #1d4ed8; }
    .rarity-epic { background: #7c3aed; }
    .rarity-legendary { background: linear-gradient(135deg, #b45309, #dc2626); }
    
    .achievements-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 10px;
    }
    .achievement-card {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      padding: 12px;
      text-align: center;
      border: 2px solid transparent;
    }
    .achievement-card.unlocked { border-color: #c9a227; background: rgba(201, 162, 39, 0.1); }
    .achievement-card.locked { opacity: 0.5; }
    .achievement-card .emoji { font-size: 2rem; margin-bottom: 6px; }
    .achievement-card .name { font-size: 0.8rem; font-weight: 600; color: #c9a227; }
    .achievement-card .desc { font-size: 0.7rem; color: #aaa; }
    
    .stats-panel {
      background: rgba(0,0,0,0.3);
      border-radius: 10px;
      padding: 12px;
      margin-bottom: 16px;
    }
    .stats-row { display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 0.85rem; }
    .stats-row:last-child { margin-bottom: 0; }
    .stats-label { color: #888; }
    .stats-value { color: #c9a227; font-weight: 600; }
    
    .artifact-popup { text-align: center; padding: 6px; min-width: 140px; }
    .artifact-popup .emoji { font-size: 2.2rem; }
    .artifact-popup .name { font-weight: 600; margin: 4px 0; font-size: 0.95rem; }
    .artifact-popup .site-name { font-size: 0.7rem; color: #c9a227; margin: 2px 0 4px 0; }
    .artifact-popup .buried-hint { font-size: 0.75rem; color: #a08060; font-style: italic; }
    .artifact-popup .distance { font-size: 0.75rem; color: #888; margin: 4px 0; }
    .collect-btn {
      background: linear-gradient(135deg, #c9a227, #a68523);
      color: #1a1a2e;
      border: none;
      padding: 8px 16px;
      border-radius: 20px;
      margin-top: 6px;
      cursor: pointer;
      font-weight: 700;
      width: 100%;
      font-size: 0.85rem;
    }
    .collect-btn:hover { transform: scale(1.05); }
    .collect-btn:disabled { background: #444; color: #888; cursor: not-allowed; transform: none; }
    
    /* Excavation System */
    .excavation-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: linear-gradient(180deg, #1a1510 0%, #0d0a07 100%);
      z-index: 3000;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
      overflow-y: auto;
      animation: fadeIn 0.3s ease-out;
    }
    .excavation-header { text-align: center; margin-bottom: 8px; }
    .excavation-phase {
      color: #c9a227;
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 2px;
      margin-bottom: 3px;
    }
    .excavation-title { color: #fff; font-size: 1rem; margin-bottom: 3px; }
    .excavation-instructions { color: #888; font-size: 0.75rem; }
    
    .dig-site-container { position: relative; margin: 8px 0; }
    .dig-site {
      width: 300px;
      height: 300px;
      border-radius: 12px;
      overflow: hidden;
      position: relative;
      border: 3px solid #5d4037;
      box-shadow: 0 0 30px rgba(0,0,0,0.8), inset 0 0 50px rgba(0,0,0,0.5);
    }
    .grid-overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 20;
    }
    .grid-overlay.visible {
      background-image: 
        linear-gradient(rgba(255,255,255,0.2) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255,255,255,0.2) 1px, transparent 1px);
      background-size: 60px 60px;
    }
    .unit-label {
      position: absolute;
      color: rgba(255,255,255,0.6);
      font-size: 9px;
      font-family: monospace;
      background: rgba(0,0,0,0.5);
      padding: 1px 3px;
      border-radius: 2px;
    }
    .artifact-reveal { 
      position: absolute; 
      top: 50%; 
      left: 50%; 
      transform: translate(-50%, -50%); 
      font-size: 4.5rem; 
      z-index: 1;
      opacity: 0;
      transition: opacity 0.5s;
      filter: drop-shadow(0 0 20px rgba(201, 162, 39, 0.8));
    }
    .artifact-reveal.visible { opacity: 1; }
    #excavationCanvas {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 10;
      touch-action: none;
    }
    
    .tool-belt {
      display: flex;
      gap: 6px;
      margin: 8px 0;
      flex-wrap: wrap;
      justify-content: center;
    }
    .tool-btn {
      background: rgba(93, 64, 55, 0.8);
      border: 2px solid #8d6e63;
      color: #d7ccc8;
      padding: 6px 10px;
      border-radius: 10px;
      font-size: 0.7rem;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
      min-width: 55px;
    }
    .tool-btn:hover { background: rgba(141, 110, 99, 0.9); }
    .tool-btn.active { 
      border-color: #c9a227; 
      background: rgba(201, 162, 39, 0.3);
      color: #c9a227;
      box-shadow: 0 0 15px rgba(201, 162, 39, 0.4);
    }
    .tool-btn.disabled { opacity: 0.4; cursor: not-allowed; }
    .tool-btn .tool-icon { font-size: 1.2rem; }
    .tool-btn .tool-name { font-size: 0.6rem; }
    
    .stratigraphy-panel {
      background: rgba(0,0,0,0.6);
      border-radius: 8px;
      padding: 8px 12px;
      margin: 8px 0;
      width: 300px;
    }
    .strat-title {
      color: #c9a227;
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 6px;
    }
    .layer-row {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 4px 0;
      font-size: 0.7rem;
      opacity: 0.4;
      transition: all 0.3s;
    }
    .layer-row.active { opacity: 1; transform: translateX(5px); }
    .layer-row.complete { opacity: 0.6; }
    .layer-row.complete .layer-name::after { content: ' ‚úì'; color: #4CAF50; }
    .layer-color {
      width: 18px;
      height: 10px;
      border-radius: 2px;
      border: 1px solid rgba(255,255,255,0.2);
    }
    .layer-name { color: #ccc; flex: 1; }
    .layer-depth { color: #666; font-size: 0.6rem; }
    
    .excavation-progress { width: 300px; margin: 8px 0; }
    .progress-label {
      display: flex;
      justify-content: space-between;
      font-size: 0.65rem;
      color: #888;
      margin-bottom: 4px;
    }
    .progress-bar-bg {
      height: 8px;
      background: #333;
      border-radius: 4px;
      overflow: hidden;
    }
    .progress-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #8d6e63, #c9a227);
      transition: width 0.3s;
    }
    
    .field-journal {
      background: linear-gradient(135deg, #fffef5 0%, #f5f0e0 100%);
      border-radius: 5px;
      padding: 10px;
      margin: 8px 0;
      width: 300px;
      font-family: 'Courier New', monospace;
      font-size: 0.65rem;
      color: #333;
      box-shadow: 3px 3px 15px rgba(0,0,0,0.4);
      transform: rotate(-0.5deg);
      border: 1px solid #d4c4a8;
    }
    .journal-header {
      display: flex;
      justify-content: space-between;
      border-bottom: 1px solid #8b7355;
      padding-bottom: 5px;
      margin-bottom: 6px;
    }
    .journal-title { font-weight: bold; color: #5d4037; }
    .journal-date { color: #888; font-size: 0.6rem; }
    .journal-entry {
      margin: 4px 0;
      padding-left: 8px;
      border-left: 2px solid #c9a227;
      color: #444;
    }
    .journal-entry.new { animation: newEntry 0.5s ease-out; }
    @keyframes newEntry {
      from { background: rgba(201, 162, 39, 0.3); }
      to { background: transparent; }
    }
    
    /* Discovery Effects */
    .discovery-overlay {
      position: fixed;
      inset: 0;
      background: radial-gradient(ellipse at center, #1a1510 0%, #000 100%);
      z-index: 4000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      animation: discoveryFadeIn 1s ease-out;
    }
    @keyframes discoveryFadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    .discovery-glow {
      position: absolute;
      width: 350px;
      height: 350px;
      background: radial-gradient(circle, rgba(201, 162, 39, 0.5) 0%, rgba(201, 162, 39, 0.1) 40%, transparent 70%);
      animation: pulseGlow 2s ease-in-out infinite;
      pointer-events: none;
    }
    @keyframes pulseGlow {
      0%, 100% { transform: scale(1); opacity: 0.6; }
      50% { transform: scale(1.4); opacity: 1; }
    }
    
    .discovery-rays {
      position: absolute;
      width: 400px;
      height: 400px;
      background: conic-gradient(from 0deg, transparent, rgba(201, 162, 39, 0.1), transparent, rgba(201, 162, 39, 0.1), transparent, rgba(201, 162, 39, 0.1), transparent, rgba(201, 162, 39, 0.1), transparent);
      animation: rotateRays 20s linear infinite;
      pointer-events: none;
    }
    @keyframes rotateRays { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    
    .discovery-particles {
      position: absolute;
      inset: 0;
      pointer-events: none;
      overflow: hidden;
    }
    
    .discovery-artifact {
      font-size: 90px;
      animation: artifactReveal 1.8s cubic-bezier(0.34, 1.56, 0.64, 1);
      filter: drop-shadow(0 0 40px rgba(201, 162, 39, 0.9));
      z-index: 10;
    }
    @keyframes artifactReveal {
      0% { transform: scale(0) rotate(-180deg); opacity: 0; filter: blur(30px) drop-shadow(0 0 0px rgba(201, 162, 39, 0)); }
      60% { transform: scale(1.3) rotate(15deg); opacity: 1; filter: blur(0) drop-shadow(0 0 60px rgba(201, 162, 39, 1)); }
      80% { transform: scale(0.95) rotate(-5deg); }
      100% { transform: scale(1) rotate(0deg); filter: drop-shadow(0 0 40px rgba(201, 162, 39, 0.9)); }
    }
    
    .discovery-text {
      text-align: center;
      z-index: 10;
      animation: textReveal 0.8s ease-out 0.6s both;
    }
    @keyframes textReveal {
      from { transform: translateY(40px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    
    .discovery-headline {
      color: #c9a227;
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 5px;
      margin-bottom: 8px;
      text-shadow: 0 0 20px rgba(201, 162, 39, 0.5);
    }
    .discovery-name {
      color: #fff;
      font-size: 1.8rem;
      font-weight: bold;
      margin-bottom: 5px;
      text-shadow: 0 0 30px rgba(201, 162, 39, 0.6);
    }
    .discovery-rarity {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 15px;
      font-size: 0.7rem;
      font-weight: bold;
      text-transform: uppercase;
      margin-bottom: 12px;
    }
    .discovery-age {
      color: #aaa;
      font-size: 0.9rem;
      font-style: italic;
      margin-bottom: 12px;
    }
    .discovery-first {
      color: #81c784;
      font-size: 0.85rem;
      padding: 10px 20px;
      background: rgba(129, 199, 132, 0.15);
      border: 1px solid rgba(129, 199, 132, 0.3);
      border-radius: 25px;
      margin-bottom: 15px;
      animation: shimmer 2s ease-in-out infinite;
    }
    @keyframes shimmer {
      0%, 100% { opacity: 0.8; box-shadow: 0 0 10px rgba(129, 199, 132, 0.2); }
      50% { opacity: 1; box-shadow: 0 0 25px rgba(129, 199, 132, 0.4); }
    }
    
    .discovery-stats {
      display: flex;
      gap: 25px;
      margin: 12px 0;
    }
    .discovery-stat { text-align: center; }
    .discovery-stat-value {
      color: #c9a227;
      font-size: 1.4rem;
      font-weight: bold;
    }
    .discovery-stat-label {
      color: #666;
      font-size: 0.6rem;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .discovery-quote {
      color: #888;
      font-size: 0.8rem;
      font-style: italic;
      max-width: 300px;
      text-align: center;
      margin: 10px 0;
      line-height: 1.4;
    }
    
    .discovery-continue {
      background: linear-gradient(135deg, #c9a227, #a68523);
      color: #1a1a2e;
      border: none;
      padding: 14px 35px;
      border-radius: 30px;
      font-size: 1rem;
      font-weight: bold;
      cursor: pointer;
      margin-top: 15px;
      animation: buttonPulse 2s ease-in-out infinite;
      transition: transform 0.2s;
    }
    .discovery-continue:hover { transform: scale(1.05); }
    @keyframes buttonPulse {
      0%, 100% { box-shadow: 0 0 20px rgba(201, 162, 39, 0.5); }
      50% { box-shadow: 0 0 40px rgba(201, 162, 39, 0.9); }
    }
    
    .screen-flash {
      position: fixed;
      inset: 0;
      background: #fffde7;
      z-index: 5000;
      animation: flash 0.6s ease-out forwards;
      pointer-events: none;
    }
    @keyframes flash {
      0% { opacity: 1; }
      100% { opacity: 0; }
    }
    
    .screen-shake { animation: shake 0.6s cubic-bezier(.36,.07,.19,.97); }
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      10%, 30%, 50%, 70%, 90% { transform: translateX(-8px) rotate(-0.5deg); }
      20%, 40%, 60%, 80% { transform: translateX(8px) rotate(0.5deg); }
    }
    
    /* Legacy cleaning support */
    .cleaning-overlay { display: none; }
    
    /* Cutscene */
    .cutscene-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: linear-gradient(180deg, #0a0a0a 0%, #1a1a2e 100%);
      z-index: 3500;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
      animation: fadeIn 0.5s ease-out;
    }
    .cutscene-title { 
      color: #c9a227; 
      font-size: 0.9rem; 
      text-transform: uppercase; 
      letter-spacing: 3px; 
      margin-bottom: 15px; 
      opacity: 0.9;
      text-shadow: 0 0 10px rgba(201, 162, 39, 0.5);
    }
    #cutsceneCanvas { 
      border-radius: 16px; 
      background: linear-gradient(180deg, #87CEEB 0%, #90EE90 60%, #228B22 100%); 
      box-shadow: 0 4px 30px rgba(0,0,0,0.6), 0 0 60px rgba(201, 162, 39, 0.2);
      border: 2px solid rgba(201, 162, 39, 0.3);
    }
    .cutscene-caption {
      color: #fff;
      font-size: 1rem;
      margin-top: 20px;
      max-width: 350px;
      text-align: center;
      line-height: 1.6;
      font-style: italic;
      text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
    }
    .cutscene-skip { 
      color: #666; 
      font-size: 0.8rem; 
      margin-top: 20px;
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }
    
    /* Found overlay */
    .found-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.95);
      z-index: 3000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
      overflow-y: auto;
      animation: fadeIn 0.3s ease-out;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    .found-overlay .emoji { font-size: 4rem; animation: bounce 0.6s ease-out; }
    @keyframes bounce {
      0% { transform: scale(0) rotate(-10deg); }
      50% { transform: scale(1.3) rotate(5deg); }
      100% { transform: scale(1) rotate(0deg); }
    }
    .found-overlay h2 { color: #c9a227; margin: 10px 0 6px; font-size: 1rem; text-transform: uppercase; letter-spacing: 3px; }
    .found-overlay .artifact-name { font-size: 1.3rem; font-weight: 700; margin-bottom: 6px; }
    .found-overlay .rarity-badge { padding: 4px 14px; border-radius: 20px; font-size: 0.75rem; font-weight: 600; margin-bottom: 8px; }
    .found-overlay .xp-earned { font-size: 1.4rem; color: #c9a227; font-weight: bold; margin-bottom: 12px; }
    .found-overlay .description { color: #ccc; max-width: 300px; text-align: center; margin-bottom: 12px; line-height: 1.4; font-size: 0.85rem; }
    .found-overlay .cultural-note { background: rgba(201, 162, 39, 0.1); border: 1px solid #c9a227; border-radius: 10px; padding: 10px 14px; max-width: 300px; margin-bottom: 16px; }
    .found-overlay .cultural-note h4 { color: #c9a227; font-size: 0.75rem; margin-bottom: 4px; }
    .found-overlay .cultural-note p { font-size: 0.8rem; color: #ccc; line-height: 1.4; }
    .minigame-unlock { background: rgba(100, 50, 200, 0.2); border: 1px solid #8b5cf6; border-radius: 10px; padding: 10px 14px; max-width: 300px; margin-bottom: 16px; text-align: center; }
    .minigame-unlock h4 { color: #8b5cf6; font-size: 0.8rem; margin-bottom: 4px; }
    .minigame-unlock p { font-size: 0.75rem; color: #aaa; }
    
    /* Level up */
    .levelup-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.95);
      z-index: 4000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .levelup-overlay h1 { font-size: 2.5rem; color: #c9a227; animation: levelPulse 0.5s ease-out; }
    @keyframes levelPulse { 0% { transform: scale(0); } 50% { transform: scale(1.2); } 100% { transform: scale(1); } }
    .levelup-overlay .level-num { font-size: 4rem; font-weight: bold; color: #fff; margin: 16px 0; }
    .levelup-overlay .reward { color: #aaa; font-size: 1rem; margin-bottom: 24px; }
    
    /* Mini-games */
    .minigame-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(10, 10, 10, 0.98);
      z-index: 3000;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      overflow-y: auto;
    }
    .minigame-header { text-align: center; margin-bottom: 15px; }
    .minigame-header h2 { color: #c9a227; font-size: 1.2rem; margin-bottom: 5px; }
    .minigame-header p { color: #888; font-size: 0.8rem; }
    .minigame-score { 
      font-size: 2.5rem; 
      color: #c9a227; 
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
      background: rgba(0,0,0,0.3);
      padding: 5px 20px;
      border-radius: 10px;
    }
    .minigame-timer { 
      font-size: 1.1rem; 
      color: #fff; 
      margin-bottom: 15px;
      background: rgba(0,0,0,0.3);
      padding: 4px 12px;
      border-radius: 8px;
    }
    .game-canvas-container { 
      position: relative; 
      border-radius: 12px; 
      overflow: hidden;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
      border: 2px solid #c9a227;
    }
    #gameCanvas { 
      display: block; 
      border-radius: 10px;
      background: linear-gradient(180deg, #87CEEB 0%, #7CB342 100%);
    }
    .game-instructions { color: #aaa; font-size: 0.8rem; margin-top: 15px; text-align: center; max-width: 300px; }
    
    .leaderboard { width: 100%; max-width: 350px; margin-top: 20px; }
    .leaderboard h3 { color: #c9a227; font-size: 1rem; margin-bottom: 10px; text-align: center; }
    .leaderboard-entry { display: flex; justify-content: space-between; padding: 8px 12px; background: rgba(255,255,255,0.05); border-radius: 8px; margin-bottom: 6px; font-size: 0.85rem; }
    .leaderboard-entry.you { background: rgba(201, 162, 39, 0.2); border: 1px solid #c9a227; }
    .leaderboard-rank { color: #c9a227; font-weight: bold; width: 30px; }
    .leaderboard-name { flex: 1; color: #ccc; }
    .leaderboard-score { color: #fff; font-weight: bold; }
    
    .minigame-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 12px; }
    .minigame-card {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      padding: 16px;
      text-align: center;
      border: 2px solid transparent;
      cursor: pointer;
      transition: all 0.3s;
    }
    .minigame-card:hover { border-color: #c9a227; transform: translateY(-2px); }
    .minigame-card.locked { opacity: 0.4; cursor: not-allowed; }
    .minigame-card .emoji { font-size: 2.5rem; margin-bottom: 8px; }
    .minigame-card .name { font-size: 0.85rem; font-weight: 600; color: #c9a227; }
    .minigame-card .high-score { font-size: 0.75rem; color: #888; }
    
    /* Map markers */
    .player-marker { 
      width: 28px; 
      height: 28px; 
      position: relative;
    }
    /* Head */
    .player-marker::before {
      content: '';
      position: absolute;
      width: 12px;
      height: 12px;
      background: linear-gradient(135deg, #f5d0a9 60%, #e8c090 100%);
      border: 2px solid #d4a574;
      border-radius: 50%;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
      z-index: 2;
    }
    /* Body/shoulders */
    .player-marker::after {
      content: '';
      position: absolute;
      width: 20px;
      height: 12px;
      background: linear-gradient(180deg, #5a9fe9 0%, #4a90d9 50%, #3a80c9 100%);
      border: 2px solid #3a7bc8;
      border-radius: 6px 6px 3px 3px;
      bottom: 2px;
      left: 50%;
      transform: translateX(-50%);
      box-shadow: 0 2px 4px rgba(0,0,0,0.4);
      z-index: 1;
    }
    .player-pulse { position: absolute; width: 60px; height: 60px; background: rgba(74, 144, 217, 0.25); border-radius: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%); animation: pulse-ring 2s infinite; pointer-events: none; }
    @keyframes pulse-ring { 0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; } }
    .artifact-marker { font-size: 36px; filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.5)); cursor: pointer; padding: 10px; margin: -10px; }
    .artifact-marker:hover { transform: scale(1.3); }
    .artifact-marker.nearby { animation: artifact-glow 1.5s ease-in-out infinite; }
    @keyframes artifact-glow { 0%, 100% { filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.5)); } 50% { filter: drop-shadow(0 0 15px rgba(201, 162, 39, 0.9)); } }
    .leaflet-popup-content-wrapper { border-radius: 12px; }
    
    .key-hint {
      position: absolute;
      bottom: 75px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.85);
      padding: 6px 14px;
      border-radius: 15px;
      font-size: 0.7rem;
      color: #aaa;
      z-index: 1000;
    }
    .key-hint kbd { background: #444; padding: 2px 6px; border-radius: 3px; margin: 0 2px; }
  </style>
</head>
<body>
  <div id="app"></div>

  <script>
    // ============================================
    // ARTIFACT DATA
    // ============================================
    const ARTIFACT_TYPES = [
      // TOOLS
      { 
        emoji: '‚¨õ', name: 'Obsidian Arrowhead', category: 'tools', rarity: 'common', xp: 10,
        description: 'A finely knapped obsidian point used for hunting deer and elk.',
        culturalNote: 'Ohlone hunters crafted these from volcanic glass traded from the North Bay.',
        cutscene: 'bow_hunt',
        minigame: 'bow_hunt'
      },
      { 
        emoji: 'üìê', name: 'Chert Point', category: 'tools', rarity: 'common', xp: 10,
        description: 'A tan-colored stone point for hunting small game.',
        culturalNote: 'Chert was found locally in creek beds and used for everyday tools.',
        cutscene: 'bow_hunt',
        minigame: 'bow_hunt'
      },
      { 
        emoji: 'ü™®', name: 'Chert Scraper', category: 'tools', rarity: 'common', xp: 10,
        description: 'A stone tool used for preparing animal hides.',
        culturalNote: 'These scrapers were essential for making clothing from deer hide.',
        cutscene: 'scraping'
      },
      { 
        emoji: 'ü¶¥', name: 'Bone Awl', category: 'tools', rarity: 'uncommon', xp: 25,
        description: 'A pointed bone tool for basket-making and leatherwork.',
        culturalNote: 'Awls were made from deer leg bones for weaving baskets.',
        cutscene: 'weaving',
        minigame: 'weaving'
      },
      { 
        emoji: 'ü™°', name: 'Bone Needle', category: 'tools', rarity: 'uncommon', xp: 25,
        description: 'A delicate sewing needle carved from bird bone.',
        culturalNote: 'Used to sew rabbit skin blankets with plant fiber thread.',
        cutscene: 'weaving',
        minigame: 'weaving'
      },
      { 
        emoji: 'ü™ì', name: 'Grooved Stone Axe', category: 'tools', rarity: 'rare', xp: 50,
        description: 'A heavy stone axe for felling trees.',
        culturalNote: 'These axes took hours to shape and were used for building.',
        cutscene: 'chopping'
      },
      { 
        emoji: 'üî®', name: 'Hammerstone', category: 'tools', rarity: 'common', xp: 10,
        description: 'A rounded stone used for knapping flint.',
        culturalNote: 'Every family had several hammerstones for toolmaking.',
        cutscene: 'knapping',
        minigame: 'knapping'
      },
      { 
        emoji: 'üó°Ô∏è', name: 'Obsidian Blade', category: 'tools', rarity: 'epic', xp: 100,
        description: 'A large ceremonial blade of exceptional craftsmanship.',
        culturalNote: 'Master knappers created these prestige items.',
        cutscene: 'knapping',
        minigame: 'knapping'
      },
      { 
        emoji: 'ü™ù', name: 'Bone Fish Hook', category: 'tools', rarity: 'uncommon', xp: 25,
        description: 'A curved hook for catching fish.',
        culturalNote: 'The Ohlone fished the creeks and bay for salmon and sturgeon.',
        cutscene: 'fishing',
        minigame: 'fishing'
      },
      { 
        emoji: 'üèπ', name: 'Sinew-Backed Bow', category: 'tools', rarity: 'epic', xp: 100,
        description: 'A powerful hunting bow reinforced with deer sinew.',
        culturalNote: 'These bows took weeks to make and prevented breaking.',
        cutscene: 'bow_hunt',
        minigame: 'bow_hunt'
      },
      
      // FOOD
      { 
        emoji: 'üï≥Ô∏è', name: 'Stone Mortar', category: 'food', rarity: 'common', xp: 10,
        description: 'A bowl-shaped grinding stone worn smooth by use.',
        culturalNote: 'Ohlone families ground acorns in these mortars daily.',
        cutscene: 'grinding',
        minigame: 'grinding'
      },
      { 
        emoji: 'ü•¢', name: 'Pestle', category: 'food', rarity: 'common', xp: 10,
        description: 'A cylindrical stone used to pound acorns.',
        culturalNote: 'Pestles were passed down through generations.',
        cutscene: 'grinding',
        minigame: 'grinding'
      },
      { 
        emoji: 'ü™∫', name: 'Acorn Granary Fragment', category: 'food', rarity: 'uncommon', xp: 25,
        description: 'Woven twigs from an acorn storage structure.',
        culturalNote: 'Families stored 500+ pounds of acorns for winter.',
        cutscene: 'gathering'
      },
      { 
        emoji: '‚ô®Ô∏è', name: 'Cooking Stone', category: 'food', rarity: 'uncommon', xp: 25,
        description: 'A stone used to boil water in baskets.',
        culturalNote: 'Hot stones were dropped into baskets to cook food.',
        cutscene: 'cooking'
      },
      { 
        emoji: 'üå∞', name: 'Acorn Cache', category: 'food', rarity: 'common', xp: 10,
        description: 'Preserved acorns from Valley Oaks.',
        culturalNote: 'Acorns were the main food source for the Ohlone.',
        cutscene: 'gathering',
        minigame: 'grinding'
      },
      { 
        emoji: '‚≠ê', name: 'Decorated Mortar', category: 'food', rarity: 'legendary', xp: 200,
        description: 'A rare ceremonial mortar with shell inlay.',
        culturalNote: 'Only a few have ever been found in the Bay Area.',
        cutscene: 'grinding'
      },
      
      // SHELLS
      { 
        emoji: 'üêö', name: 'Olivella Shell Bead', category: 'shells', rarity: 'common', xp: 10,
        description: 'A small shell bead used as currency.',
        culturalNote: 'These shells were California\'s money.',
        cutscene: 'trading'
      },
      { 
        emoji: 'üìø', name: 'Shell Bead Necklace', category: 'shells', rarity: 'uncommon', xp: 25,
        description: 'A strand of carefully matched shell beads.',
        culturalNote: 'Each bead was ground and drilled by hand.',
        cutscene: 'trading'
      },
      { 
        emoji: 'ü¶™', name: 'Abalone Pendant', category: 'shells', rarity: 'rare', xp: 50,
        description: 'An iridescent ornament from abalone shell.',
        culturalNote: 'Chiefs wore these as symbols of power.',
        cutscene: 'ceremony'
      },
      { 
        emoji: 'üëë', name: 'Abalone Crown', category: 'shells', rarity: 'legendary', xp: 200,
        description: 'A magnificent headpiece with abalone and feathers.',
        culturalNote: 'Worn only during the most sacred ceremonies.',
        cutscene: 'ceremony'
      },
      
      // BASKETRY
      { 
        emoji: 'üß∫', name: 'Twined Basket Fragment', category: 'basketry', rarity: 'common', xp: 10,
        description: 'A piece of basket woven from willow.',
        culturalNote: 'Baskets served as pots, plates, and even boats!',
        cutscene: 'weaving',
        minigame: 'weaving'
      },
      { 
        emoji: 'üåø', name: 'Tule Mat', category: 'basketry', rarity: 'common', xp: 10,
        description: 'Woven tule reeds for bedding.',
        culturalNote: 'Tule grew abundantly in Bay Area marshes.',
        cutscene: 'weaving',
        minigame: 'weaving'
      },
      { 
        emoji: 'üèµÔ∏è', name: 'Coiled Gift Basket', category: 'basketry', rarity: 'rare', xp: 50,
        description: 'A finely coiled basket with patterns.',
        culturalNote: 'Gift baskets could hold water‚Äî60 stitches per inch!',
        cutscene: 'weaving',
        minigame: 'weaving'
      },
      { 
        emoji: 'ü™∂', name: 'Feathered Ceremony Basket', category: 'basketry', rarity: 'legendary', xp: 200,
        description: 'A basket with woodpecker and quail feathers.',
        culturalNote: 'These treasures took months to create.',
        cutscene: 'weaving'
      },
      
      // CEREMONIAL
      { 
        emoji: 'ü¶Ö', name: 'Eagle Feather', category: 'ceremonial', rarity: 'rare', xp: 50,
        description: 'A sacred feather for ceremonies.',
        culturalNote: 'Eagles connected people to the sky world.',
        cutscene: 'ceremony'
      },
      { 
        emoji: 'üé∂', name: 'Elderberry Clapper', category: 'ceremonial', rarity: 'uncommon', xp: 25,
        description: 'A split-stick rhythm instrument.',
        culturalNote: 'Clappers drove the rhythm of dances.',
        cutscene: 'ceremony'
      },
      { 
        emoji: 'ü™à', name: 'Bone Whistle', category: 'ceremonial', rarity: 'rare', xp: 50,
        description: 'A whistle carved from bird bone.',
        culturalNote: 'Whistles called people to ceremony.',
        cutscene: 'ceremony'
      },
      { 
        emoji: 'üíé', name: 'Quartz Crystal', category: 'ceremonial', rarity: 'epic', xp: 100,
        description: 'A clear crystal for healing.',
        culturalNote: 'Shamans used crystals to see and heal illness.',
        cutscene: 'ceremony'
      },
      { 
        emoji: '‚ú®', name: 'Shaman\'s Bundle', category: 'ceremonial', rarity: 'legendary', xp: 200,
        description: 'A sacred bundle of spiritual objects.',
        culturalNote: 'These held immense spiritual significance.',
        cutscene: 'ceremony'
      },
    ];

    const RARITY_WEIGHTS = { common: 45, uncommon: 30, rare: 17, epic: 6, legendary: 2 };
    const XP_BY_RARITY = { common: 10, uncommon: 25, rare: 50, epic: 100, legendary: 200 };

    const LEVELS = [
      { level: 1, xpRequired: 0, title: 'Newcomer' },
      { level: 2, xpRequired: 50, title: 'Explorer' },
      { level: 3, xpRequired: 150, title: 'Seeker' },
      { level: 4, xpRequired: 300, title: 'Student' },
      { level: 5, xpRequired: 500, title: 'Researcher' },
      { level: 6, xpRequired: 800, title: 'Archaeologist' },
      { level: 7, xpRequired: 1200, title: 'Expert' },
      { level: 8, xpRequired: 1800, title: 'Scholar' },
      { level: 9, xpRequired: 2500, title: 'Master' },
      { level: 10, xpRequired: 3500, title: 'Historian' },
    ];

    const ACHIEVEMENTS = [
      { id: 'first_find', emoji: 'üéØ', name: 'First Discovery', desc: 'Collect your first artifact', check: (s) => s.collection.length >= 1 },
      { id: 'ten_artifacts', emoji: 'üì¶', name: 'Getting Started', desc: 'Collect 10 artifacts', check: (s) => s.collection.length >= 10 },
      { id: 'first_rare', emoji: 'üíé', name: 'Rare Find', desc: 'Find a rare artifact', check: (s) => s.collection.some(a => a.rarity === 'rare') },
      { id: 'first_legendary', emoji: '‚ú®', name: 'Legendary!', desc: 'Find a legendary artifact', check: (s) => s.collection.some(a => a.rarity === 'legendary') },
      { id: 'sharpshooter', emoji: 'üéØ', name: 'Sharpshooter', desc: 'Score 300+ in Bow Hunt', check: (s) => (s.highScores?.bow_hunt || 0) >= 300 },
      { id: 'master_weaver', emoji: 'üß∫', name: 'Master Weaver', desc: 'Score 400+ in Weaving', check: (s) => (s.highScores?.weaving || 0) >= 400 },
    ];

    const MINIGAMES = {
      bow_hunt: { name: 'Bow Hunting', emoji: 'üèπ', desc: 'Draw, aim, and release to hunt!' },
      fishing: { name: 'Fishing', emoji: 'üé£', desc: 'Cast, wait, and catch fish!' },
      grinding: { name: 'Acorn Grinding', emoji: 'üå∞', desc: 'Grind acorns into flour!' },
      weaving: { name: 'Basket Weaving', emoji: 'üß∫', desc: 'Follow the pattern!' },
      knapping: { name: 'Knapping', emoji: 'ü™®', desc: 'Shape obsidian into tools!' }
    };

    // ============================================
    // GAME STATE
    // ============================================
    let state = {
      playerPos: { lat: 37.8044, lon: -122.2712 },
      artifacts: [],
      collection: [],
      xp: 0,
      unlockedAchievements: [],
      unlockedMinigames: [],
      highScores: {},
      map: null,
      playerMarker: null,
      radiusCircle: null,
      artifactMarkers: [],
      showingModal: null,
      cleaningArtifact: null,
      // Excavation system state
      excavationPhase: 0, // 0=not excavating, 1=survey, 2=excavate, 3=brush, 4=document
      excavationLayer: 0, // 0=topsoil, 1=dark soil, 2=midden, 3=subsoil
      excavationProgress: 0,
      selectedTool: 'trowel',
      fieldNotes: [],
      discoveryPending: null,
      showingCutscene: null,
      foundArtifact: null,
      showLevelUp: false,
      newLevel: null,
      playingMinigame: null,
      minigameScore: 0,
      minigameTimer: 0,
      minigameActive: false,
      zoomLevel: 13,
      // Game-specific state
      gameState: {}
    };

    const COLLECT_DISTANCE = 50;
    const ARTIFACT_COUNT = 12;
    
    // Bay Area locations - historic Ohlone sites and culturally significant areas
    const BAY_AREA_SITES = [
      // Oakland / East Bay
      { lat: 37.8044, lon: -122.2712, name: 'Lake Merritt Shellmound' },
      { lat: 37.8324, lon: -122.2639, name: 'Temescal Creek Village' },
      { lat: 37.7749, lon: -122.2194, name: 'San Leandro Shell Midden' },
      { lat: 37.8716, lon: -122.2727, name: 'Berkeley Shellmound' },
      { lat: 37.9052, lon: -122.0572, name: 'Walnut Creek Area' },
      // San Francisco
      { lat: 37.7694, lon: -122.4862, name: 'Ocean Beach Dunes' },
      { lat: 37.8029, lon: -122.4484, name: 'Presidio Village Site' },
      { lat: 37.7599, lon: -122.4148, name: 'Mission Dolores Ohlone Site' },
      { lat: 37.7275, lon: -122.3930, name: 'Candlestick Point' },
      // South Bay
      { lat: 37.4419, lon: -122.1430, name: 'Palo Alto Shellmound' },
      { lat: 37.3382, lon: -121.8863, name: 'San Jose Pueblo Site' },
      { lat: 37.4849, lon: -122.2278, name: 'Coyote Hills Village' },
      { lat: 37.5585, lon: -122.2711, name: 'Hayward Shell Midden' },
      // North Bay
      { lat: 37.9735, lon: -122.5311, name: 'San Rafael Village' },
      { lat: 38.0724, lon: -122.5298, name: 'Novato Creek Site' },
      { lat: 38.2975, lon: -122.2869, name: 'Napa Valley Trade Route' },
      // Peninsula
      { lat: 37.6213, lon: -122.3790, name: 'San Mateo Shellmound' },
      { lat: 37.5024, lon: -122.2523, name: 'Fremont Mission Site' },
      // Marin Headlands
      { lat: 37.8324, lon: -122.4795, name: 'Marin Headlands Camp' },
      { lat: 37.8562, lon: -122.4783, name: 'Sausalito Fishing Village' },
    ];

    // ============================================
    // UTILITIES
    // ============================================
    function getDistance(lat1, lon1, lat2, lon2) {
      const R = 6371e3;
      const œÜ1 = lat1 * Math.PI / 180, œÜ2 = lat2 * Math.PI / 180;
      const ŒîœÜ = (lat2 - lat1) * Math.PI / 180, ŒîŒª = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(ŒîœÜ/2)**2 + Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(ŒîŒª/2)**2;
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    }
    function formatDistance(m) { return m < 1000 ? `${Math.round(m)}m` : `${(m/1000).toFixed(1)}km`; }
    function randomInRange(min, max) { return Math.random() * (max - min) + min; }
    function pickRarity() {
      const total = Object.values(RARITY_WEIGHTS).reduce((a, b) => a + b, 0);
      let r = Math.random() * total;
      for (const [rarity, weight] of Object.entries(RARITY_WEIGHTS)) { r -= weight; if (r <= 0) return rarity; }
      return 'common';
    }
    function pickArtifactType() {
      const rarity = pickRarity();
      const options = ARTIFACT_TYPES.filter(a => a.rarity === rarity);
      return options[Math.floor(Math.random() * options.length)];
    }
    
    // Spawn artifact at a random Bay Area site with slight offset
    function spawnArtifactAtSite() {
      const site = BAY_AREA_SITES[Math.floor(Math.random() * BAY_AREA_SITES.length)];
      // Add small random offset (within ~200m)
      const latOff = (Math.random() - 0.5) * 0.004;
      const lonOff = (Math.random() - 0.5) * 0.004;
      return { 
        id: Date.now() + Math.random(), 
        lat: site.lat + latOff, 
        lon: site.lon + lonOff, 
        siteName: site.name,
        ...pickArtifactType() 
      };
    }
    
    // Legacy function for compatibility - now spawns at Bay Area sites
    function spawnArtifactNear(lat, lon) {
      return spawnArtifactAtSite();
    }
    
    function getLevelInfo(xp) {
      let cur = LEVELS[0];
      for (const l of LEVELS) { if (xp >= l.xpRequired) cur = l; else break; }
      const next = LEVELS.find(l => l.level === cur.level + 1);
      return { ...cur, nextLevel: next, xpForNext: next ? next.xpRequired - cur.xpRequired : 0, xpProgress: next ? xp - cur.xpRequired : 0 };
    }

    // ============================================
    // GAME LOGIC
    // ============================================
    function initArtifacts() {
      // Spawn artifacts at different Bay Area sites
      const usedSites = new Set();
      while (state.artifacts.length < ARTIFACT_COUNT) {
        const artifact = spawnArtifactAtSite();
        // Try to avoid duplicate sites
        const siteKey = `${Math.round(artifact.lat * 100)},${Math.round(artifact.lon * 100)}`;
        if (!usedSites.has(siteKey) || usedSites.size >= BAY_AREA_SITES.length) {
          state.artifacts.push(artifact);
          usedSites.add(siteKey);
        }
      }
      updateArtifactMarkers();
    }

    function startCleaning(artifact) {
      state.cleaningArtifact = artifact;
      render();
    }

    function showCutscene(artifact) {
      state.cleaningArtifact = null;
      state.showingCutscene = artifact;
      render();
      setTimeout(() => startCutsceneAnimation(artifact), 100);
    }

    function completeCutscene() {
      const artifact = state.showingCutscene;
      if (!artifact) return; // Guard against double-calls
      
      state.showingCutscene = null;
      
      // Check if this artifact was already collected via the new discovery system
      // (indicated by xpGained being pre-set)
      const alreadyCollected = artifact.xpGained !== undefined;
      
      if (!alreadyCollected) {
        // Old path - collect now
        state.collection.push({ ...artifact, collectedAt: new Date().toISOString() });
        
        const xpGained = artifact.xp || XP_BY_RARITY[artifact.rarity];
        const oldLevel = getLevelInfo(state.xp).level;
        state.xp += xpGained;
        const newLevelInfo = getLevelInfo(state.xp);
        
        if (newLevelInfo.level > oldLevel) { state.showLevelUp = true; state.newLevel = newLevelInfo; }
        if (artifact.minigame && !state.unlockedMinigames.includes(artifact.minigame)) state.unlockedMinigames.push(artifact.minigame);
        
        checkAchievements();
        saveGame();
        state.artifacts = state.artifacts.filter(a => a.id !== artifact.id);
        state.foundArtifact = { ...artifact, xpGained };
        
        // Spawn replacement artifact after a delay
        setTimeout(() => { 
          state.artifacts.push(spawnArtifactNear(state.playerPos.lat, state.playerPos.lon)); 
        }, 500);
      } else {
        // New path - already collected in discovery, just show found screen
        state.foundArtifact = artifact;
      }
      
      // Clean up map before re-render
      if (state.map) {
        state.map.remove();
        state.map = null;
      }
      
      render();
    }

    function checkAchievements() {
      ACHIEVEMENTS.forEach(ach => {
        if (!state.unlockedAchievements.includes(ach.id) && ach.check(state)) state.unlockedAchievements.push(ach.id);
      });
    }

    function saveGame() {
      localStorage.setItem('artifactHunterV4', JSON.stringify({
        collection: state.collection, xp: state.xp,
        unlockedAchievements: state.unlockedAchievements,
        unlockedMinigames: state.unlockedMinigames,
        highScores: state.highScores
      }));
    }

    function loadGame() {
      const saved = localStorage.getItem('artifactHunterV4');
      if (saved) {
        const d = JSON.parse(saved);
        state.collection = d.collection || [];
        state.xp = d.xp || 0;
        state.unlockedAchievements = d.unlockedAchievements || [];
        state.unlockedMinigames = d.unlockedMinigames || [];
        state.highScores = d.highScores || {};
      }
    }

    // ============================================
    // CUTSCENE ANIMATIONS - DETAILED GRAPHICS
    // ============================================
    function startCutsceneAnimation(artifact) {
      const canvas = document.getElementById('cutsceneCanvas');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      const W = canvas.width, H = canvas.height;
      
      let frame = 0;
      const type = artifact.cutscene || 'generic';
      
      // Colors
      const SKIN = '#C68642';
      const SKIN_DARK = '#8D5524';
      const HAIR = '#2C1810';
      const CLOTH = '#8B7355';
      const CLOTH_DARK = '#6B5344';
      
      // Draw detailed person
      function drawPerson(x, y, scale = 1, pose = 'stand', facing = 1) {
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(facing * scale, scale);
        
        const s = 1; // Internal scale
        
        // Body/torso
        ctx.fillStyle = CLOTH;
        ctx.beginPath();
        ctx.ellipse(0, 0, 12 * s, 18 * s, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Cloth detail
        ctx.strokeStyle = CLOTH_DARK;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-8 * s, -10 * s);
        ctx.lineTo(-5 * s, 15 * s);
        ctx.moveTo(8 * s, -10 * s);
        ctx.lineTo(5 * s, 15 * s);
        ctx.stroke();
        
        // Head
        ctx.fillStyle = SKIN;
        ctx.beginPath();
        ctx.ellipse(0, -28 * s, 10 * s, 12 * s, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Hair
        ctx.fillStyle = HAIR;
        ctx.beginPath();
        ctx.ellipse(0, -35 * s, 11 * s, 8 * s, 0, Math.PI, Math.PI * 2);
        ctx.fill();
        // Hair sides
        ctx.fillRect(-11 * s, -35 * s, 4 * s, 20 * s);
        ctx.fillRect(7 * s, -35 * s, 4 * s, 20 * s);
        
        // Face
        ctx.fillStyle = '#1a1a1a';
        ctx.beginPath();
        ctx.arc(-4 * s, -30 * s, 1.5 * s, 0, Math.PI * 2); // Left eye
        ctx.arc(4 * s, -30 * s, 1.5 * s, 0, Math.PI * 2); // Right eye
        ctx.fill();
        
        // Arms based on pose
        ctx.fillStyle = SKIN;
        ctx.strokeStyle = SKIN;
        ctx.lineWidth = 6 * s;
        ctx.lineCap = 'round';
        
        if (pose === 'stand') {
          // Arms at sides
          ctx.beginPath();
          ctx.moveTo(-12 * s, -8 * s);
          ctx.lineTo(-15 * s, 20 * s);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(12 * s, -8 * s);
          ctx.lineTo(15 * s, 20 * s);
          ctx.stroke();
        } else if (pose === 'bow_draw') {
          // Left arm extended
          ctx.beginPath();
          ctx.moveTo(-12 * s, -8 * s);
          ctx.lineTo(-40 * s, -15 * s);
          ctx.stroke();
          // Right arm pulled back
          ctx.beginPath();
          ctx.moveTo(12 * s, -8 * s);
          ctx.lineTo(5 * s, -20 * s);
          ctx.stroke();
        } else if (pose === 'grind') {
          const armY = Math.sin(frame * 0.15) * 8;
          ctx.beginPath();
          ctx.moveTo(-12 * s, -8 * s);
          ctx.lineTo(-8 * s, 15 * s + armY);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(12 * s, -8 * s);
          ctx.lineTo(8 * s, 15 * s + armY);
          ctx.stroke();
        } else if (pose === 'weave') {
          const armX = Math.sin(frame * 0.1) * 15;
          ctx.beginPath();
          ctx.moveTo(-12 * s, -8 * s);
          ctx.lineTo(-20 * s + armX, 10 * s);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(12 * s, -8 * s);
          ctx.lineTo(20 * s - armX, 10 * s);
          ctx.stroke();
        } else if (pose === 'fish') {
          // Holding rod
          ctx.beginPath();
          ctx.moveTo(-12 * s, -8 * s);
          ctx.lineTo(-5 * s, 15 * s);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(12 * s, -8 * s);
          ctx.lineTo(25 * s, -25 * s);
          ctx.stroke();
        }
        
        // Legs
        ctx.fillStyle = SKIN_DARK;
        ctx.strokeStyle = SKIN_DARK;
        ctx.lineWidth = 7 * s;
        ctx.beginPath();
        ctx.moveTo(-6 * s, 15 * s);
        ctx.lineTo(-8 * s, 45 * s);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(6 * s, 15 * s);
        ctx.lineTo(8 * s, 45 * s);
        ctx.stroke();
        
        // Feet
        ctx.fillStyle = CLOTH_DARK;
        ctx.beginPath();
        ctx.ellipse(-8 * s, 48 * s, 6 * s, 4 * s, 0, 0, Math.PI * 2);
        ctx.ellipse(8 * s, 48 * s, 6 * s, 4 * s, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
      }
      
      // Draw detailed bow
      function drawBow(x, y, drawn = false, angle = 0) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        
        const curve = drawn ? 25 : 35;
        
        // Bow wood
        ctx.strokeStyle = '#5D4037';
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(0, -40);
        ctx.quadraticCurveTo(curve, 0, 0, 40);
        ctx.stroke();
        
        // Bow detail
        ctx.strokeStyle = '#8D6E63';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, -40);
        ctx.quadraticCurveTo(curve - 5, 0, 0, 40);
        ctx.stroke();
        
        // String
        ctx.strokeStyle = '#4E342E';
        ctx.lineWidth = 2;
        const pullBack = drawn ? -15 : 0;
        ctx.beginPath();
        ctx.moveTo(0, -40);
        ctx.lineTo(pullBack, 0);
        ctx.lineTo(0, 40);
        ctx.stroke();
        
        ctx.restore();
      }
      
      // Draw arrow
      function drawArrow(x, y, angle = 0) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        
        // Shaft
        ctx.strokeStyle = '#8D6E63';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(-25, 0);
        ctx.lineTo(20, 0);
        ctx.stroke();
        
        // Arrowhead (obsidian)
        ctx.fillStyle = '#1a1a1a';
        ctx.beginPath();
        ctx.moveTo(20, 0);
        ctx.lineTo(30, -6);
        ctx.lineTo(35, 0);
        ctx.lineTo(30, 6);
        ctx.closePath();
        ctx.fill();
        
        // Fletching
        ctx.fillStyle = '#B71C1C';
        ctx.beginPath();
        ctx.moveTo(-25, 0);
        ctx.lineTo(-20, -8);
        ctx.lineTo(-15, 0);
        ctx.lineTo(-20, 8);
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
      }
      
      // Draw detailed deer
      function drawDeer(x, y, scale = 1, hit = false) {
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(scale, scale);
        
        const bodyColor = hit ? '#8D6E63' : '#A1887F';
        const legColor = hit ? '#6D4C41' : '#8D6E63';
        
        // Body
        ctx.fillStyle = bodyColor;
        ctx.beginPath();
        ctx.ellipse(0, 0, 40, 25, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Neck
        ctx.beginPath();
        ctx.ellipse(35, -15, 12, 20, 0.5, 0, Math.PI * 2);
        ctx.fill();
        
        // Head
        ctx.beginPath();
        ctx.ellipse(50, -30, 12, 10, 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Ear
        ctx.beginPath();
        ctx.ellipse(45, -42, 4, 8, -0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Eye
        ctx.fillStyle = '#1a1a1a';
        ctx.beginPath();
        ctx.arc(55, -32, 3, 0, Math.PI * 2);
        ctx.fill();
        
        // Antlers
        ctx.strokeStyle = '#5D4037';
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(48, -40);
        ctx.lineTo(55, -55);
        ctx.lineTo(60, -50);
        ctx.moveTo(55, -55);
        ctx.lineTo(50, -60);
        ctx.stroke();
        
        // Legs
        ctx.strokeStyle = legColor;
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(-20, 20);
        ctx.lineTo(-22, 50);
        ctx.moveTo(-5, 22);
        ctx.lineTo(-5, 50);
        ctx.moveTo(15, 22);
        ctx.lineTo(15, 50);
        ctx.moveTo(25, 20);
        ctx.lineTo(27, 50);
        ctx.stroke();
        
        // Hooves
        ctx.fillStyle = '#3E2723';
        ctx.beginPath();
        [-22, -5, 15, 27].forEach(lx => {
          ctx.moveTo(lx, 50);
          ctx.arc(lx, 52, 4, 0, Math.PI * 2);
        });
        ctx.fill();
        
        // White belly
        ctx.fillStyle = '#EFEBE9';
        ctx.beginPath();
        ctx.ellipse(0, 15, 25, 10, 0, 0, Math.PI);
        ctx.fill();
        
        // Tail
        ctx.fillStyle = '#EFEBE9';
        ctx.beginPath();
        ctx.ellipse(-42, -5, 8, 6, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
      }
      
      // Draw grass
      function drawGrass(groundY) {
        ctx.strokeStyle = '#2E7D32';
        ctx.lineWidth = 2;
        for (let i = 0; i < W; i += 8) {
          const h = 10 + Math.sin(i + frame * 0.05) * 5;
          const sway = Math.sin(frame * 0.03 + i * 0.1) * 3;
          ctx.beginPath();
          ctx.moveTo(i, groundY);
          ctx.quadraticCurveTo(i + sway, groundY - h/2, i + sway * 2, groundY - h);
          ctx.stroke();
        }
      }
      
      // Draw tree
      function drawTree(x, groundY, size = 1) {
        ctx.save();
        ctx.translate(x, groundY);
        ctx.scale(size, size);
        
        // Trunk
        ctx.fillStyle = '#5D4037';
        ctx.fillRect(-8, -60, 16, 60);
        
        // Foliage layers
        ctx.fillStyle = '#2E7D32';
        ctx.beginPath();
        ctx.moveTo(0, -140);
        ctx.lineTo(-35, -60);
        ctx.lineTo(35, -60);
        ctx.closePath();
        ctx.fill();
        
        ctx.fillStyle = '#388E3C';
        ctx.beginPath();
        ctx.moveTo(0, -120);
        ctx.lineTo(-40, -50);
        ctx.lineTo(40, -50);
        ctx.closePath();
        ctx.fill();
        
        ctx.fillStyle = '#43A047';
        ctx.beginPath();
        ctx.moveTo(0, -100);
        ctx.lineTo(-45, -40);
        ctx.lineTo(45, -40);
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
      }
      
      // Draw oak tree
      function drawOakTree(x, groundY, size = 1) {
        ctx.save();
        ctx.translate(x, groundY);
        ctx.scale(size, size);
        
        // Trunk
        ctx.fillStyle = '#4E342E';
        ctx.beginPath();
        ctx.moveTo(-15, 0);
        ctx.lineTo(-10, -80);
        ctx.lineTo(10, -80);
        ctx.lineTo(15, 0);
        ctx.closePath();
        ctx.fill();
        
        // Branches
        ctx.strokeStyle = '#5D4037';
        ctx.lineWidth = 8;
        ctx.beginPath();
        ctx.moveTo(0, -70);
        ctx.lineTo(-40, -100);
        ctx.moveTo(0, -60);
        ctx.lineTo(45, -95);
        ctx.stroke();
        
        // Foliage (multiple circles)
        ctx.fillStyle = '#33691E';
        [[-30, -110], [0, -120], [35, -105], [-15, -95], [20, -115]].forEach(([ox, oy]) => {
          ctx.beginPath();
          ctx.arc(ox, oy, 30, 0, Math.PI * 2);
          ctx.fill();
        });
        
        ctx.fillStyle = '#558B2F';
        [[-20, -115], [15, -110], [0, -100]].forEach(([ox, oy]) => {
          ctx.beginPath();
          ctx.arc(ox, oy, 25, 0, Math.PI * 2);
          ctx.fill();
        });
        
        ctx.restore();
      }
      
      // Draw water
      function drawWater(startY) {
        // Water gradient
        const waterGrad = ctx.createLinearGradient(0, startY, 0, H);
        waterGrad.addColorStop(0, '#4FC3F7');
        waterGrad.addColorStop(0.3, '#039BE5');
        waterGrad.addColorStop(1, '#01579B');
        ctx.fillStyle = waterGrad;
        ctx.fillRect(0, startY, W, H - startY);
        
        // Ripples
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = 1;
        for (let i = 0; i < 8; i++) {
          const ry = startY + 20 + i * 25;
          const rx = W/2 + Math.sin(frame * 0.02 + i) * 30;
          ctx.beginPath();
          ctx.ellipse(rx, ry, 40 + Math.sin(frame * 0.05 + i) * 10, 5, 0, 0, Math.PI * 2);
          ctx.stroke();
        }
        
        // Light reflections
        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
        for (let i = 0; i < 5; i++) {
          ctx.beginPath();
          ctx.ellipse(50 + i * 60, startY + 30 + Math.sin(frame * 0.03 + i) * 5, 15, 3, 0, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      // Draw fish
      function drawFish(x, y, size = 1, type = 'salmon') {
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(size, size);
        
        const colors = type === 'salmon' ? ['#E57373', '#C62828'] : ['#90A4AE', '#546E7A'];
        
        // Body
        ctx.fillStyle = colors[0];
        ctx.beginPath();
        ctx.ellipse(0, 0, 25, 12, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Tail
        ctx.fillStyle = colors[1];
        ctx.beginPath();
        ctx.moveTo(-25, 0);
        ctx.lineTo(-40, -15);
        ctx.lineTo(-40, 15);
        ctx.closePath();
        ctx.fill();
        
        // Fins
        ctx.beginPath();
        ctx.moveTo(0, -10);
        ctx.lineTo(-5, -20);
        ctx.lineTo(10, -10);
        ctx.closePath();
        ctx.fill();
        
        // Eye
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(15, -2, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(16, -2, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Scales pattern
        ctx.strokeStyle = colors[1];
        ctx.lineWidth = 0.5;
        for (let i = -15; i < 15; i += 8) {
          ctx.beginPath();
          ctx.arc(i, 0, 6, -0.5, 0.5);
          ctx.stroke();
        }
        
        ctx.restore();
      }
      
      // Draw mortar and pestle
      function drawMortar(x, y, pestleY = 0) {
        ctx.save();
        ctx.translate(x, y);
        
        // Mortar (stone bowl)
        const mortarGrad = ctx.createRadialGradient(0, 20, 10, 0, 20, 50);
        mortarGrad.addColorStop(0, '#9E9E9E');
        mortarGrad.addColorStop(1, '#616161');
        ctx.fillStyle = mortarGrad;
        
        ctx.beginPath();
        ctx.moveTo(-45, 0);
        ctx.quadraticCurveTo(-55, 50, -35, 70);
        ctx.lineTo(35, 70);
        ctx.quadraticCurveTo(55, 50, 45, 0);
        ctx.closePath();
        ctx.fill();
        
        // Inner bowl
        ctx.fillStyle = '#424242';
        ctx.beginPath();
        ctx.ellipse(0, 10, 35, 20, 0, 0, Math.PI);
        ctx.fill();
        
        // Acorns/meal inside
        ctx.fillStyle = '#D7CCC8';
        ctx.beginPath();
        ctx.ellipse(0, 20, 30, 12, 0, 0, Math.PI);
        ctx.fill();
        
        // Stone texture
        ctx.fillStyle = 'rgba(0,0,0,0.1)';
        for (let i = 0; i < 10; i++) {
          ctx.beginPath();
          ctx.arc(-30 + Math.random() * 60, 20 + Math.random() * 40, 3 + Math.random() * 5, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Pestle
        const py = pestleY;
        ctx.fillStyle = '#757575';
        ctx.beginPath();
        ctx.ellipse(0, py - 20, 12, 8, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillRect(-8, py - 70, 16, 50);
        ctx.beginPath();
        ctx.ellipse(0, py - 70, 8, 4, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Pestle highlight
        ctx.fillStyle = 'rgba(255,255,255,0.2)';
        ctx.fillRect(-2, py - 65, 4, 40);
        
        ctx.restore();
      }
      
      // Draw basket
      function drawBasket(x, y, progress = 1) {
        ctx.save();
        ctx.translate(x, y);
        
        const maxH = 60 * progress;
        
        // Basket weave
        ctx.strokeStyle = '#8D6E63';
        ctx.lineWidth = 3;
        
        // Horizontal weaves
        for (let i = 0; i < maxH; i += 6) {
          ctx.strokeStyle = i % 12 === 0 ? '#6D4C41' : '#A1887F';
          ctx.beginPath();
          const w = 30 + (i / maxH) * 20;
          ctx.ellipse(0, -i, w, 8, 0, 0, Math.PI * 2);
          ctx.stroke();
        }
        
        // Vertical supports
        ctx.strokeStyle = '#5D4037';
        ctx.lineWidth = 2;
        for (let a = 0; a < Math.PI * 2; a += Math.PI / 6) {
          ctx.beginPath();
          ctx.moveTo(Math.cos(a) * 30, 0);
          ctx.lineTo(Math.cos(a) * 50, -maxH);
          ctx.stroke();
        }
        
        ctx.restore();
      }
      
      // Draw background
      function drawBackground(type) {
        // Sky
        const skyGrad = ctx.createLinearGradient(0, 0, 0, H * 0.7);
        skyGrad.addColorStop(0, '#81D4FA');
        skyGrad.addColorStop(0.5, '#B3E5FC');
        skyGrad.addColorStop(1, '#E1F5FE');
        ctx.fillStyle = skyGrad;
        ctx.fillRect(0, 0, W, H);
        
        // Sun
        ctx.fillStyle = '#FFF9C4';
        ctx.beginPath();
        ctx.arc(W - 50, 40, 25, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#FFEB3B';
        ctx.beginPath();
        ctx.arc(W - 50, 40, 20, 0, Math.PI * 2);
        ctx.fill();
        
        // Sun rays
        ctx.strokeStyle = 'rgba(255, 235, 59, 0.3)';
        ctx.lineWidth = 2;
        for (let i = 0; i < 8; i++) {
          const angle = (i / 8) * Math.PI * 2 + frame * 0.005;
          ctx.beginPath();
          ctx.moveTo(W - 50 + Math.cos(angle) * 28, 40 + Math.sin(angle) * 28);
          ctx.lineTo(W - 50 + Math.cos(angle) * 40, 40 + Math.sin(angle) * 40);
          ctx.stroke();
        }
        
        // Clouds
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        const cloudX1 = (frame * 0.2) % (W + 100) - 50;
        const cloudX2 = (frame * 0.15 + 150) % (W + 100) - 50;
        
        // Cloud 1
        ctx.beginPath();
        ctx.arc(cloudX1, 50, 20, 0, Math.PI * 2);
        ctx.arc(cloudX1 + 25, 45, 25, 0, Math.PI * 2);
        ctx.arc(cloudX1 + 50, 50, 18, 0, Math.PI * 2);
        ctx.fill();
        
        // Cloud 2
        ctx.beginPath();
        ctx.arc(cloudX2, 80, 15, 0, Math.PI * 2);
        ctx.arc(cloudX2 + 20, 75, 20, 0, Math.PI * 2);
        ctx.arc(cloudX2 + 40, 80, 15, 0, Math.PI * 2);
        ctx.fill();
        
        // Birds
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1.5;
        for (let i = 0; i < 3; i++) {
          const birdX = (frame * 0.5 + i * 80) % (W + 50) - 25;
          const birdY = 60 + i * 20 + Math.sin(frame * 0.1 + i) * 5;
          ctx.beginPath();
          ctx.moveTo(birdX - 8, birdY);
          ctx.quadraticCurveTo(birdX - 4, birdY - 5, birdX, birdY);
          ctx.quadraticCurveTo(birdX + 4, birdY - 5, birdX + 8, birdY);
          ctx.stroke();
        }
        
        // Distant hills
        ctx.fillStyle = '#81C784';
        ctx.beginPath();
        ctx.moveTo(0, H * 0.5);
        ctx.quadraticCurveTo(W * 0.25, H * 0.35, W * 0.5, H * 0.45);
        ctx.quadraticCurveTo(W * 0.75, H * 0.55, W, H * 0.4);
        ctx.lineTo(W, H);
        ctx.lineTo(0, H);
        ctx.closePath();
        ctx.fill();
        
        // Ground
        const groundY = H * 0.7;
        const groundGrad = ctx.createLinearGradient(0, groundY, 0, H);
        groundGrad.addColorStop(0, '#7CB342');
        groundGrad.addColorStop(1, '#558B2F');
        ctx.fillStyle = groundGrad;
        ctx.fillRect(0, groundY, W, H * 0.3);
        
        // Ground texture
        ctx.fillStyle = 'rgba(85, 139, 47, 0.3)';
        for (let i = 0; i < 20; i++) {
          ctx.beginPath();
          ctx.ellipse(Math.random() * W, groundY + 5 + Math.random() * 30, 10 + Math.random() * 15, 3, 0, 0, Math.PI * 2);
          ctx.fill();
        }
        
        return groundY;
      }
      
      let animationId;
      function animate() {
        ctx.clearRect(0, 0, W, H);
        
        const groundY = drawBackground(type);
        
        if (type === 'bow_hunt') {
          // Trees in background
          drawTree(50, groundY, 0.6);
          drawOakTree(W - 60, groundY, 0.5);
          
          const phase = (frame % 200) / 200;
          
          // Deer
          const deerHit = phase > 0.6;
          const deerX = deerHit ? W - 100 : W - 100 + Math.sin(frame * 0.02) * 10;
          drawDeer(deerX, groundY - 30, 0.8, deerHit);
          
          // Hunter
          const pose = phase < 0.5 ? 'bow_draw' : 'stand';
          drawPerson(80, groundY - 50, 1, pose);
          
          // Bow
          const bowDrawn = phase < 0.5;
          drawBow(45, groundY - 55, bowDrawn, -0.2);
          
          // Arrow flight
          if (phase > 0.4 && phase < 0.65) {
            const arrowProgress = (phase - 0.4) / 0.25;
            const arrowX = 80 + arrowProgress * (W - 180);
            const arrowY = groundY - 55 + Math.sin(arrowProgress * Math.PI) * -20;
            drawArrow(arrowX, arrowY, -0.1 + arrowProgress * 0.1);
          }
          
          // Success message
          if (deerHit) {
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(W/2 - 80, 15, 160, 35);
            ctx.fillStyle = '#FFD54F';
            ctx.font = 'bold 18px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('üéØ Successful Hunt!', W/2, 40);
          }
          
          // Grass
          drawGrass(groundY);
          
        } else if (type === 'grinding') {
          drawOakTree(W - 80, groundY, 0.7);
          
          // Falling acorns occasionally
          if (frame % 60 < 30) {
            ctx.fillStyle = '#795548';
            const acornY = (frame % 60) * 3;
            ctx.beginPath();
            ctx.ellipse(W - 80 + (frame % 20), groundY - 100 + acornY, 5, 7, 0, 0, Math.PI * 2);
            ctx.fill();
          }
          
          // Mortar
          const pestleY = Math.sin(frame * 0.15) * 15;
          drawMortar(W/2, groundY - 20, pestleY);
          
          // Person grinding
          drawPerson(W/2, groundY - 70, 1, 'grind');
          
          // Dust particles
          ctx.fillStyle = 'rgba(215, 204, 200, 0.6)';
          for (let i = 0; i < 5; i++) {
            const px = W/2 - 20 + Math.random() * 40;
            const py = groundY - 30 - Math.random() * 20 - (frame % 30);
            ctx.beginPath();
            ctx.arc(px, py, 2, 0, Math.PI * 2);
            ctx.fill();
          }
          
          drawGrass(groundY);
          
        } else if (type === 'weaving') {
          drawOakTree(50, groundY, 0.6);
          
          // Person weaving
          drawPerson(W/2 - 50, groundY - 50, 1, 'weave');
          
          // Basket being woven
          const basketProgress = 0.3 + (Math.sin(frame * 0.02) + 1) * 0.35;
          drawBasket(W/2 + 40, groundY - 10, basketProgress);
          
          // Materials nearby
          ctx.strokeStyle = '#8D6E63';
          ctx.lineWidth = 2;
          for (let i = 0; i < 8; i++) {
            ctx.beginPath();
            ctx.moveTo(W/2 + 80 + i * 3, groundY);
            ctx.lineTo(W/2 + 85 + i * 3 + Math.sin(i) * 5, groundY - 40);
            ctx.stroke();
          }
          
          drawGrass(groundY);
          
        } else if (type === 'fishing') {
          // Water scene
          ctx.fillStyle = '#81D4FA';
          ctx.fillRect(0, 0, W, H * 0.4);
          
          // Bank
          ctx.fillStyle = '#8D6E63';
          ctx.beginPath();
          ctx.moveTo(0, H * 0.4);
          ctx.quadraticCurveTo(W * 0.3, H * 0.35, W * 0.5, H * 0.5);
          ctx.lineTo(0, H);
          ctx.closePath();
          ctx.fill();
          
          // Grass on bank
          ctx.fillStyle = '#7CB342';
          ctx.beginPath();
          ctx.moveTo(0, H * 0.38);
          ctx.quadraticCurveTo(W * 0.25, H * 0.33, W * 0.4, H * 0.45);
          ctx.lineTo(0, H * 0.6);
          ctx.closePath();
          ctx.fill();
          
          drawWater(H * 0.4);
          
          // Fisher
          drawPerson(100, H * 0.5, 0.9, 'fish');
          
          // Fishing rod
          ctx.strokeStyle = '#5D4037';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(125, H * 0.45);
          ctx.quadraticCurveTo(180, H * 0.3, 200, H * 0.35);
          ctx.stroke();
          
          // Fishing line
          ctx.strokeStyle = '#424242';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(200, H * 0.35);
          ctx.lineTo(220, H * 0.55 + Math.sin(frame * 0.1) * 5);
          ctx.stroke();
          
          // Bobber
          ctx.fillStyle = '#F44336';
          ctx.beginPath();
          ctx.arc(220, H * 0.55 + Math.sin(frame * 0.1) * 5, 5, 0, Math.PI * 2);
          ctx.fill();
          
          // Fish swimming
          const fishX = W - 50 - (frame % 150);
          drawFish(fishX, H * 0.65 + Math.sin(frame * 0.05) * 10, 0.7);
          drawFish(fishX + 80, H * 0.75, 0.5, 'other');
          
        } else if (type === 'ceremony') {
          // Night sky
          const nightGrad = ctx.createLinearGradient(0, 0, 0, H);
          nightGrad.addColorStop(0, '#1A237E');
          nightGrad.addColorStop(0.5, '#303F9F');
          nightGrad.addColorStop(1, '#3F51B5');
          ctx.fillStyle = nightGrad;
          ctx.fillRect(0, 0, W, H);
          
          // Stars
          ctx.fillStyle = '#fff';
          for (let i = 0; i < 30; i++) {
            const sx = (i * 37) % W;
            const sy = (i * 23) % (H * 0.5);
            const twinkle = Math.sin(frame * 0.1 + i) > 0.5 ? 2 : 1;
            ctx.beginPath();
            ctx.arc(sx, sy, twinkle, 0, Math.PI * 2);
            ctx.fill();
          }
          
          // Moon
          ctx.fillStyle = '#FFF9C4';
          ctx.beginPath();
          ctx.arc(W - 60, 50, 25, 0, Math.PI * 2);
          ctx.fill();
          
          // Ground
          ctx.fillStyle = '#33691E';
          ctx.fillRect(0, H * 0.7, W, H * 0.3);
          
          // Fire
          const fireX = W/2;
          const fireY = H * 0.75;
          
          // Fire glow
          const glowGrad = ctx.createRadialGradient(fireX, fireY, 10, fireX, fireY, 80);
          glowGrad.addColorStop(0, 'rgba(255, 152, 0, 0.4)');
          glowGrad.addColorStop(1, 'rgba(255, 152, 0, 0)');
          ctx.fillStyle = glowGrad;
          ctx.fillRect(fireX - 100, fireY - 80, 200, 120);
          
          // Fire flames
          for (let i = 0; i < 8; i++) {
            const flameX = fireX - 20 + i * 5 + Math.sin(frame * 0.2 + i) * 3;
            const flameH = 30 + Math.sin(frame * 0.3 + i * 0.5) * 15;
            const hue = 30 + i * 5;
            ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
            ctx.beginPath();
            ctx.moveTo(flameX - 5, fireY);
            ctx.quadraticCurveTo(flameX, fireY - flameH, flameX + 5, fireY);
            ctx.fill();
          }
          
          // Sparks
          ctx.fillStyle = '#FFEB3B';
          for (let i = 0; i < 5; i++) {
            const sparkX = fireX - 10 + Math.random() * 20;
            const sparkY = fireY - 40 - (frame + i * 10) % 50;
            ctx.beginPath();
            ctx.arc(sparkX, sparkY, 1.5, 0, Math.PI * 2);
            ctx.fill();
          }
          
          // Dancers
          for (let i = 0; i < 3; i++) {
            const dx = fireX - 80 + i * 80;
            const sway = Math.sin(frame * 0.08 + i * 2) * 5;
            drawPerson(dx + sway, H * 0.65, 0.8, 'stand');
          }
          
        } else if (type === 'knapping') {
          drawTree(W - 70, groundY, 0.5);
          
          // Person
          drawPerson(W/2 - 30, groundY - 50, 1, 'grind');
          
          // Obsidian being worked
          ctx.fillStyle = '#1a1a1a';
          ctx.beginPath();
          ctx.moveTo(W/2 + 20, groundY - 30);
          ctx.lineTo(W/2 + 50, groundY - 50);
          ctx.lineTo(W/2 + 60, groundY - 35);
          ctx.lineTo(W/2 + 45, groundY - 15);
          ctx.closePath();
          ctx.fill();
          
          // Obsidian shine
          ctx.fillStyle = 'rgba(255,255,255,0.3)';
          ctx.beginPath();
          ctx.moveTo(W/2 + 30, groundY - 40);
          ctx.lineTo(W/2 + 45, groundY - 45);
          ctx.lineTo(W/2 + 40, groundY - 35);
          ctx.closePath();
          ctx.fill();
          
          // Hammerstone
          ctx.fillStyle = '#9E9E9E';
          const hammerY = groundY - 60 + Math.abs(Math.sin(frame * 0.15)) * 20;
          ctx.beginPath();
          ctx.ellipse(W/2 + 40, hammerY, 12, 10, 0, 0, Math.PI * 2);
          ctx.fill();
          
          // Sparks when hitting
          if (Math.sin(frame * 0.15) > 0.8) {
            ctx.fillStyle = '#FFD54F';
            for (let i = 0; i < 6; i++) {
              const sparkX = W/2 + 40 + (Math.random() - 0.5) * 30;
              const sparkY = groundY - 40 - Math.random() * 20;
              ctx.beginPath();
              ctx.arc(sparkX, sparkY, 2, 0, Math.PI * 2);
              ctx.fill();
            }
          }
          
          // Flakes on ground
          ctx.fillStyle = '#37474F';
          for (let i = 0; i < 5; i++) {
            ctx.beginPath();
            ctx.ellipse(W/2 + 30 + i * 10, groundY - 5, 4, 2, i * 0.5, 0, Math.PI * 2);
            ctx.fill();
          }
          
          drawGrass(groundY);
          
        } else if (type === 'trading') {
          // Trading scene
          drawOakTree(W - 70, groundY, 0.6);
          drawOakTree(40, groundY, 0.5);
          
          // Two people trading
          drawPerson(W/2 - 60, groundY - 50, 0.9, 'stand', 1);
          drawPerson(W/2 + 60, groundY - 50, 0.9, 'stand', -1);
          
          // Shell beads being exchanged (animated)
          const beadY = groundY - 80 + Math.sin(frame * 0.05) * 5;
          ctx.fillStyle = '#E8E8E8';
          for (let i = 0; i < 5; i++) {
            ctx.beginPath();
            ctx.ellipse(W/2 - 10 + i * 5, beadY, 4, 6, 0, 0, Math.PI * 2);
            ctx.fill();
          }
          
          // Basket of goods
          ctx.fillStyle = '#8D6E63';
          ctx.beginPath();
          ctx.ellipse(W/2, groundY - 10, 25, 15, 0, Math.PI, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = '#6D4C41';
          ctx.lineWidth = 2;
          for (let i = 0; i < 5; i++) {
            ctx.beginPath();
            ctx.ellipse(W/2, groundY - 10 - i * 3, 25 - i * 2, 8, 0, 0, Math.PI);
            ctx.stroke();
          }
          
          drawGrass(groundY);
          
        } else if (type === 'gathering') {
          // Acorn gathering scene
          drawOakTree(W/2, groundY, 1.2);
          
          // Falling acorns
          ctx.fillStyle = '#795548';
          for (let i = 0; i < 5; i++) {
            const acornX = W/2 - 40 + ((frame + i * 30) % 80);
            const acornY = groundY - 120 + ((frame + i * 20) % 100);
            ctx.beginPath();
            ctx.ellipse(acornX, acornY, 5, 7, 0, 0, Math.PI * 2);
            ctx.fill();
            // Acorn cap
            ctx.fillStyle = '#5D4037';
            ctx.beginPath();
            ctx.ellipse(acornX, acornY - 5, 6, 3, 0, Math.PI, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#795548';
          }
          
          // Person gathering with basket
          drawPerson(W/2 - 80, groundY - 50, 1, 'grind');
          
          // Gathering basket
          ctx.fillStyle = '#A1887F';
          ctx.beginPath();
          ctx.ellipse(W/2 - 50, groundY - 20, 20, 12, 0.3, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#795548';
          for (let i = 0; i < 6; i++) {
            ctx.beginPath();
            ctx.ellipse(W/2 - 50 + (Math.random() - 0.5) * 20, groundY - 22, 4, 5, 0, 0, Math.PI * 2);
            ctx.fill();
          }
          
          drawGrass(groundY);
          
        } else if (type === 'cooking') {
          // Cooking with hot stones scene
          
          // Cooking basket
          ctx.fillStyle = '#8D6E63';
          ctx.beginPath();
          ctx.moveTo(W/2 - 40, groundY - 30);
          ctx.quadraticCurveTo(W/2 - 50, groundY + 20, W/2 - 30, groundY + 40);
          ctx.lineTo(W/2 + 30, groundY + 40);
          ctx.quadraticCurveTo(W/2 + 50, groundY + 20, W/2 + 40, groundY - 30);
          ctx.closePath();
          ctx.fill();
          
          // Weave pattern
          ctx.strokeStyle = '#6D4C41';
          ctx.lineWidth = 2;
          for (let i = 0; i < 8; i++) {
            ctx.beginPath();
            ctx.ellipse(W/2, groundY + 5 - i * 8, 35 - i * 2, 8, 0, 0, Math.PI * 2);
            ctx.stroke();
          }
          
          // Water/soup inside
          ctx.fillStyle = '#90A4AE';
          ctx.beginPath();
          ctx.ellipse(W/2, groundY - 20, 32, 15, 0, 0, Math.PI * 2);
          ctx.fill();
          
          // Steam
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
          ctx.lineWidth = 2;
          for (let i = 0; i < 4; i++) {
            const steamX = W/2 - 20 + i * 15;
            const steamOffset = Math.sin(frame * 0.1 + i) * 5;
            ctx.beginPath();
            ctx.moveTo(steamX, groundY - 35);
            ctx.quadraticCurveTo(steamX + steamOffset, groundY - 55, steamX, groundY - 75);
            ctx.stroke();
          }
          
          // Hot stone being added
          const stoneY = groundY - 60 - (frame % 60);
          if (frame % 120 < 60) {
            ctx.fillStyle = '#FF6B6B';
            ctx.beginPath();
            ctx.ellipse(W/2 + 10, stoneY, 10, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            // Glow
            ctx.fillStyle = 'rgba(255, 100, 100, 0.3)';
            ctx.beginPath();
            ctx.ellipse(W/2 + 10, stoneY, 15, 12, 0, 0, Math.PI * 2);
            ctx.fill();
          }
          
          // Person cooking
          drawPerson(W/2 - 70, groundY - 50, 0.9, 'stand');
          
          // Fire nearby
          for (let i = 0; i < 5; i++) {
            const flameH = 15 + Math.sin(frame * 0.3 + i) * 8;
            ctx.fillStyle = `hsl(${25 + i * 5}, 100%, 50%)`;
            ctx.beginPath();
            ctx.moveTo(W/2 + 80 + i * 8, groundY);
            ctx.quadraticCurveTo(W/2 + 84 + i * 8, groundY - flameH, W/2 + 88 + i * 8, groundY);
            ctx.fill();
          }
          
          drawGrass(groundY);
          
        } else if (type === 'scraping') {
          // Hide scraping scene
          
          // Stretched hide on frame
          ctx.fillStyle = '#D7CCC8';
          ctx.beginPath();
          ctx.ellipse(W/2 + 30, groundY - 40, 50, 35, 0.2, 0, Math.PI * 2);
          ctx.fill();
          
          // Hide texture
          ctx.fillStyle = '#BCAAA4';
          for (let i = 0; i < 8; i++) {
            ctx.beginPath();
            ctx.ellipse(W/2 + 20 + Math.random() * 40, groundY - 50 + Math.random() * 30, 5, 3, Math.random(), 0, Math.PI * 2);
            ctx.fill();
          }
          
          // Frame poles
          ctx.strokeStyle = '#5D4037';
          ctx.lineWidth = 6;
          ctx.beginPath();
          ctx.moveTo(W/2 - 30, groundY);
          ctx.lineTo(W/2 - 20, groundY - 90);
          ctx.moveTo(W/2 + 90, groundY);
          ctx.lineTo(W/2 + 80, groundY - 90);
          ctx.stroke();
          
          // Cross bar
          ctx.beginPath();
          ctx.moveTo(W/2 - 20, groundY - 85);
          ctx.lineTo(W/2 + 80, groundY - 85);
          ctx.stroke();
          
          // Person scraping
          drawPerson(W/2 - 50, groundY - 50, 1, 'grind');
          
          // Scraping tool in motion
          const toolX = W/2 + 10 + Math.sin(frame * 0.15) * 15;
          ctx.fillStyle = '#795548';
          ctx.fillRect(toolX, groundY - 55, 25, 5);
          ctx.fillStyle = '#9E9E9E';
          ctx.beginPath();
          ctx.moveTo(toolX + 25, groundY - 55);
          ctx.lineTo(toolX + 35, groundY - 52);
          ctx.lineTo(toolX + 25, groundY - 50);
          ctx.closePath();
          ctx.fill();
          
          drawGrass(groundY);
          
        } else {
          // Generic scene
          drawOakTree(W - 80, groundY, 0.7);
          drawPerson(W/2, groundY - 50, 1, 'stand');
          
          // Show artifact emoji
          ctx.font = '50px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText(artifact.emoji, W/2, groundY - 120);
          
          drawGrass(groundY);
        }
        
        frame++;
        animationId = requestAnimationFrame(animate);
      }
      
      animate();
      window.currentCutsceneAnimation = animationId;
    }

    // ============================================
    // MOVEMENT & MAP
    // ============================================
    
    // Track which arrow keys are currently held down
    const keysHeld = { up: false, down: false, left: false, right: false };
    let movementLoopId = null;
    
    function movePlayer(lat, lon) {
      state.playerPos = { lat, lon };
      if (state.playerMarker) {
        state.playerMarker.setLatLng([lat, lon]);
      }
      if (state.radiusCircle) {
        state.radiusCircle.setLatLng([lat, lon]);
      }
      updateArtifactMarkers();
    }

    function movePlayerByMeters(mN, mE) {
      const dLat = mN / 111320;
      const dLon = mE / (111320 * Math.cos(state.playerPos.lat * Math.PI / 180));
      const newLat = state.playerPos.lat + dLat;
      const newLon = state.playerPos.lon + dLon;
      movePlayer(newLat, newLon);
      // Smooth pan to new location
      if (state.map) {
        state.map.panTo([newLat, newLon], { animate: true, duration: 0.15, easeLinearity: 0.25 });
      }
    }
    
    function movementLoop() {
      if (state.showingModal || state.foundArtifact || state.showLevelUp || state.cleaningArtifact || state.discoveryPending || state.showingCutscene || state.playingMinigame) {
        movementLoopId = requestAnimationFrame(movementLoop);
        return;
      }
      
      const moveSpeed = 15; // Faster movement for Bay Area traversal (meters per frame)
      let mN = 0, mE = 0;
      
      if (keysHeld.up) mN += moveSpeed;
      if (keysHeld.down) mN -= moveSpeed;
      if (keysHeld.right) mE += moveSpeed;
      if (keysHeld.left) mE -= moveSpeed;
      
      // Diagonal movement should be same speed as cardinal
      if (mN !== 0 && mE !== 0) {
        mN *= 0.707;
        mE *= 0.707;
      }
      
      if (mN !== 0 || mE !== 0) {
        movePlayerByMeters(mN, mE);
      }
      
      movementLoopId = requestAnimationFrame(movementLoop);
    }

    function initMap() {
      const { lat, lon } = state.playerPos;
      state.map = L.map('map', { 
        zoomControl: true,
        zoomAnimation: true,
        markerZoomAnimation: true,
        zoomAnimationThreshold: 4,
        dragging: false,        // Disable map dragging
        doubleClickZoom: false  // Disable double-click zoom
      }).setView([lat, lon], state.zoomLevel);
      L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
        attribution: '¬© OpenStreetMap ¬© CARTO', subdomains: 'abcd', maxZoom: 20
      }).addTo(state.map);
      state.radiusCircle = L.circle([lat, lon], { radius: COLLECT_DISTANCE, color: '#c9a227', fillColor: '#c9a227', fillOpacity: 0.1, weight: 2, dashArray: '5, 5' }).addTo(state.map);
      state.playerMarker = L.marker([lat, lon], { icon: L.divIcon({ className: '', html: '<div class="player-pulse"></div><div class="player-marker"></div>', iconSize: [28, 28], iconAnchor: [14, 14] }), zIndexOffset: 1000 }).addTo(state.map);
      
      // Arrow key movement only - no clicking
      document.addEventListener('keydown', handleKeydown);
      document.addEventListener('keyup', handleKeyup);
      
      // Start the smooth movement loop
      movementLoop();
    }

    function handleKeydown(e) {
      const key = e.key;
      
      // Track arrow key holds for smooth movement
      if (key === 'ArrowUp') { keysHeld.up = true; e.preventDefault(); }
      if (key === 'ArrowDown') { keysHeld.down = true; e.preventDefault(); }
      if (key === 'ArrowLeft') { keysHeld.left = true; e.preventDefault(); }
      if (key === 'ArrowRight') { keysHeld.right = true; e.preventDefault(); }
      
      if (state.showingModal || state.foundArtifact || state.showLevelUp || state.cleaningArtifact || state.discoveryPending || state.showingCutscene || state.playingMinigame) return;
      
      // Q = zoom IN, E = zoom OUT
      if (key.toLowerCase() === 'q') { 
        state.zoomLevel = Math.min(20, state.zoomLevel + 1);
        if (state.map) {
          state.map.flyTo([state.playerPos.lat, state.playerPos.lon], state.zoomLevel, {
            animate: true,
            duration: 0.3,
            easeLinearity: 0.25
          });
        }
      }
      if (key.toLowerCase() === 'e') { 
        state.zoomLevel = Math.max(10, state.zoomLevel - 1);
        if (state.map) {
          state.map.flyTo([state.playerPos.lat, state.playerPos.lon], state.zoomLevel, {
            animate: true,
            duration: 0.3,
            easeLinearity: 0.25
          });
        }
      }
    }
    
    function handleKeyup(e) {
      const key = e.key;
      if (key === 'ArrowUp') keysHeld.up = false;
      if (key === 'ArrowDown') keysHeld.down = false;
      if (key === 'ArrowLeft') keysHeld.left = false;
      if (key === 'ArrowRight') keysHeld.right = false;
    }

    function updateArtifactMarkers() {
      state.artifactMarkers.forEach(m => m.remove());
      state.artifactMarkers = [];
      state.artifacts.forEach(artifact => {
        const dist = getDistance(state.playerPos.lat, state.playerPos.lon, artifact.lat, artifact.lon);
        const near = dist <= COLLECT_DISTANCE;
        const marker = L.marker([artifact.lat, artifact.lon], { icon: L.divIcon({ className: `artifact-marker ${near ? 'nearby' : ''}`, html: artifact.emoji, iconSize: [60, 60], iconAnchor: [30, 30] }) }).addTo(state.map);
        marker.bindPopup(`<div class="artifact-popup"><div class="emoji">${artifact.emoji}</div><div class="name">${artifact.name}</div>${artifact.siteName ? `<div class="site-name">üìç ${artifact.siteName}</div>` : ''}<div class="buried-hint">Half-buried...</div><div class="distance">${formatDistance(dist)}</div><button class="collect-btn" ${near ? '' : 'disabled'} onclick="window.startDigging('${artifact.id}')">${near ? 'üñåÔ∏è Excavate!' : 'Get closer'}</button></div>`, { closeButton: false });
        state.artifactMarkers.push(marker);
      });
    }

    window.startDigging = id => {
      const a = state.artifacts.find(x => x.id == id);
      if (a) { state.map.closePopup(); startCleaning(a); }
    };

    // ============================================
    // MINI-GAMES
    // ============================================
    function startMinigame(type) {
      state.playingMinigame = type;
      state.minigameScore = 0;
      state.minigameTimer = 30;
      state.minigameActive = true;
      state.gameState = {};
      render();
      setTimeout(() => initMinigameCanvas(type), 100);
      
      const timer = setInterval(() => {
        if (!state.minigameActive) { clearInterval(timer); return; }
        state.minigameTimer--;
        updateMinigameUI();
        if (state.minigameTimer <= 0) { endMinigame(); clearInterval(timer); }
      }, 1000);
    }

    function endMinigame() {
      state.minigameActive = false;
      const game = state.playingMinigame;
      if (!state.highScores[game] || state.minigameScore > state.highScores[game]) {
        state.highScores[game] = state.minigameScore;
      }
      checkAchievements();
      saveGame();
      render();
    }

    function updateMinigameUI() {
      const scoreEl = document.getElementById('mgScore');
      const timerEl = document.getElementById('mgTimer');
      if (scoreEl) scoreEl.textContent = state.minigameScore;
      if (timerEl) timerEl.textContent = state.minigameActive ? `‚è±Ô∏è ${state.minigameTimer}s` : 'üèÅ Done!';
    }

    function initMinigameCanvas(type) {
      const canvas = document.getElementById('gameCanvas');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      const W = canvas.width, H = canvas.height;
      
      if (type === 'bow_hunt') initBowHunt(canvas, ctx, W, H);
      else if (type === 'fishing') initFishing(canvas, ctx, W, H);
      else if (type === 'grinding') initGrinding(canvas, ctx, W, H);
      else if (type === 'weaving') initWeaving(canvas, ctx, W, H);
      else if (type === 'knapping') initKnapping(canvas, ctx, W, H);
    }

    // BOW HUNTING GAME - DETAILED GRAPHICS
    function initBowHunt(canvas, ctx, W, H) {
      const gs = state.gameState;
      gs.bowDrawn = 0;
      gs.arrowFlying = false;
      gs.arrowX = 100;
      gs.arrowY = H - 100;
      gs.arrowVX = 0;
      gs.arrowVY = 0;
      gs.targets = [{ x: W - 100, y: H - 80, dir: -1, frame: 0 }];
      gs.aimAngle = 0;
      gs.particles = [];
      gs.frame = 0;
      
      let mouseDown = false;
      let mouseY = H / 2;
      
      canvas.onmousedown = canvas.ontouchstart = e => { mouseDown = true; e.preventDefault(); };
      canvas.onmouseup = canvas.ontouchend = e => {
        if (gs.bowDrawn > 0.3 && !gs.arrowFlying) {
          gs.arrowFlying = true;
          const power = gs.bowDrawn * 16;
          // Arrow flies RIGHT (positive X) and up based on aim
          gs.arrowVX = power;
          gs.arrowVY = gs.aimAngle * power * 0.8;
        }
        mouseDown = false;
        gs.bowDrawn = 0;
        e.preventDefault();
      };
      canvas.onmousemove = canvas.ontouchmove = e => {
        const rect = canvas.getBoundingClientRect();
        const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
        mouseY = y;
        // Aim angle: negative = up, positive = down
        gs.aimAngle = (H * 0.6 - y) / (H * 0.5);
        gs.aimAngle = Math.max(-0.8, Math.min(0.5, gs.aimAngle));
        e.preventDefault();
      };
      
      function drawDetailedDeer(x, y, scale = 1, walking = false, frame = 0) {
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(-scale, scale); // Flip to face left (toward archer)
        
        const legOffset = walking ? Math.sin(frame * 0.15) * 8 : 0;
        
        // Body
        ctx.fillStyle = '#A1887F';
        ctx.beginPath();
        ctx.ellipse(0, 0, 35, 22, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Neck
        ctx.beginPath();
        ctx.ellipse(30, -12, 10, 18, 0.4, 0, Math.PI * 2);
        ctx.fill();
        
        // Head
        ctx.beginPath();
        ctx.ellipse(45, -28, 10, 8, 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Snout
        ctx.fillStyle = '#8D6E63';
        ctx.beginPath();
        ctx.ellipse(55, -25, 5, 4, 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Ears
        ctx.fillStyle = '#A1887F';
        ctx.beginPath();
        ctx.ellipse(40, -38, 4, 8, -0.4, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#FFCCBC';
        ctx.beginPath();
        ctx.ellipse(40, -38, 2, 5, -0.4, 0, Math.PI * 2);
        ctx.fill();
        
        // Eye
        ctx.fillStyle = '#1a1a1a';
        ctx.beginPath();
        ctx.arc(50, -30, 2.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(49, -31, 1, 0, Math.PI * 2);
        ctx.fill();
        
        // Antlers
        ctx.strokeStyle = '#5D4037';
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(43, -35);
        ctx.lineTo(48, -50);
        ctx.lineTo(55, -48);
        ctx.moveTo(48, -50);
        ctx.lineTo(45, -55);
        ctx.moveTo(48, -45);
        ctx.lineTo(52, -42);
        ctx.stroke();
        
        // Legs
        ctx.fillStyle = '#8D6E63';
        ctx.strokeStyle = '#8D6E63';
        ctx.lineWidth = 5;
        ctx.lineCap = 'round';
        
        // Front legs
        ctx.beginPath();
        ctx.moveTo(-15, 18);
        ctx.lineTo(-18 + legOffset, 45);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(5, 20);
        ctx.lineTo(5 - legOffset, 45);
        ctx.stroke();
        
        // Back legs
        ctx.beginPath();
        ctx.moveTo(20, 18);
        ctx.lineTo(22 - legOffset, 45);
        ctx.stroke();
        
        // White belly
        ctx.fillStyle = '#EFEBE9';
        ctx.beginPath();
        ctx.ellipse(0, 12, 22, 8, 0, 0, Math.PI);
        ctx.fill();
        
        // Tail
        ctx.fillStyle = '#EFEBE9';
        ctx.beginPath();
        ctx.ellipse(-38, -5, 7, 5, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
      }
      
      function drawBowAndArcher(x, y, drawAmount, aimAngle) {
        ctx.save();
        ctx.translate(x, y);
        
        // Archer body (facing right)
        ctx.fillStyle = '#8D6E63';
        ctx.beginPath();
        ctx.ellipse(0, 0, 12, 18, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Head
        ctx.fillStyle = '#C68642';
        ctx.beginPath();
        ctx.arc(0, -28, 10, 0, Math.PI * 2);
        ctx.fill();
        
        // Hair
        ctx.fillStyle = '#2C1810';
        ctx.beginPath();
        ctx.arc(0, -32, 10, Math.PI, Math.PI * 2);
        ctx.fill();
        
        // Eyes looking right
        ctx.fillStyle = '#1a1a1a';
        ctx.beginPath();
        ctx.arc(5, -28, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Legs
        ctx.strokeStyle = '#6D4C41';
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(-5, 15);
        ctx.lineTo(-8, 45);
        ctx.moveTo(5, 15);
        ctx.lineTo(8, 45);
        ctx.stroke();
        
        // Arms and bow - rotated by aim angle
        ctx.save();
        ctx.translate(5, -5);
        ctx.rotate(-aimAngle * 0.5);
        
        // Back arm (holding bow)
        ctx.strokeStyle = '#C68642';
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(30, 0);
        ctx.stroke();
        
        // Front arm (pulling string)
        const pullBack = drawAmount * 25;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(10 - pullBack * 0.3, 5);
        ctx.stroke();
        
        // Bow
        ctx.strokeStyle = '#5D4037';
        ctx.lineWidth = 5;
        const bowX = 35;
        const bowCurve = 25 - drawAmount * 8;
        ctx.beginPath();
        ctx.moveTo(bowX, -30);
        ctx.quadraticCurveTo(bowX + bowCurve, 0, bowX, 30);
        ctx.stroke();
        
        // Bow detail
        ctx.strokeStyle = '#8D6E63';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(bowX, -28);
        ctx.quadraticCurveTo(bowX + bowCurve - 3, 0, bowX, 28);
        ctx.stroke();
        
        // String
        ctx.strokeStyle = '#4E342E';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(bowX, -30);
        ctx.lineTo(bowX - pullBack, 0);
        ctx.lineTo(bowX, 30);
        ctx.stroke();
        
        // Arrow on bow (if not flying)
        if (!gs.arrowFlying && drawAmount > 0.1) {
          ctx.fillStyle = '#8D6E63';
          ctx.fillRect(bowX - pullBack - 5, -2, 35, 4);
          // Arrowhead
          ctx.fillStyle = '#1a1a1a';
          ctx.beginPath();
          ctx.moveTo(bowX + 30, 0);
          ctx.lineTo(bowX + 38, -5);
          ctx.lineTo(bowX + 38, 5);
          ctx.closePath();
          ctx.fill();
          // Fletching
          ctx.fillStyle = '#C62828';
          ctx.beginPath();
          ctx.moveTo(bowX - pullBack - 5, 0);
          ctx.lineTo(bowX - pullBack - 12, -6);
          ctx.lineTo(bowX - pullBack - 12, 6);
          ctx.closePath();
          ctx.fill();
        }
        
        ctx.restore();
        ctx.restore();
      }
      
      function draw() {
        if (!state.minigameActive && !gs.arrowFlying) return;
        gs.frame++;
        
        // Sky
        const skyGrad = ctx.createLinearGradient(0, 0, 0, H * 0.65);
        skyGrad.addColorStop(0, '#81D4FA');
        skyGrad.addColorStop(1, '#E1F5FE');
        ctx.fillStyle = skyGrad;
        ctx.fillRect(0, 0, W, H);
        
        // Distant trees
        ctx.fillStyle = '#66BB6A';
        for (let i = 0; i < 8; i++) {
          ctx.beginPath();
          ctx.moveTo(i * 45, H * 0.65);
          ctx.lineTo(i * 45 + 20, H * 0.45);
          ctx.lineTo(i * 45 + 40, H * 0.65);
          ctx.fill();
        }
        
        // Ground
        ctx.fillStyle = '#7CB342';
        ctx.fillRect(0, H * 0.65, W, H * 0.35);
        
        // Grass
        ctx.strokeStyle = '#558B2F';
        ctx.lineWidth = 2;
        for (let i = 0; i < W; i += 12) {
          ctx.beginPath();
          ctx.moveTo(i, H * 0.65);
          ctx.lineTo(i + Math.sin(gs.frame * 0.02 + i) * 2, H * 0.65 - 8 - Math.random() * 4);
          ctx.stroke();
        }
        
        // Power meter
        if (mouseDown && !gs.arrowFlying) {
          gs.bowDrawn = Math.min(1, gs.bowDrawn + 0.025);
        }
        
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(10, 10, 80, 18);
        ctx.fillStyle = gs.bowDrawn > 0.7 ? '#4CAF50' : '#FFC107';
        ctx.fillRect(12, 12, gs.bowDrawn * 76, 14);
        ctx.fillStyle = '#fff';
        ctx.font = '10px sans-serif';
        ctx.fillText('POWER', 14, 23);
        
        // Archer with bow (on left side, facing right)
        drawBowAndArcher(60, H - 80, gs.bowDrawn, gs.aimAngle);
        
        // Flying arrow
        if (gs.arrowFlying) {
          gs.arrowX += gs.arrowVX;
          gs.arrowY -= gs.arrowVY;
          gs.arrowVY -= 0.35; // Gravity
          
          const arrowAngle = Math.atan2(-gs.arrowVY, gs.arrowVX);
          
          ctx.save();
          ctx.translate(gs.arrowX, gs.arrowY);
          ctx.rotate(arrowAngle);
          
          // Arrow shaft
          ctx.fillStyle = '#8D6E63';
          ctx.fillRect(-20, -2, 40, 4);
          
          // Arrowhead (pointing right, in direction of travel)
          ctx.fillStyle = '#1a1a1a';
          ctx.beginPath();
          ctx.moveTo(20, 0);
          ctx.lineTo(28, -5);
          ctx.lineTo(28, 5);
          ctx.closePath();
          ctx.fill();
          
          // Fletching (on the back)
          ctx.fillStyle = '#C62828';
          ctx.beginPath();
          ctx.moveTo(-20, 0);
          ctx.lineTo(-28, -6);
          ctx.lineTo(-28, 6);
          ctx.closePath();
          ctx.fill();
          
          ctx.restore();
          
          // Check hits
          gs.targets.forEach((t, i) => {
            if (Math.abs(gs.arrowX - t.x) < 50 && Math.abs(gs.arrowY - t.y) < 40) {
              state.minigameScore += 100;
              // Add particles
              for (let p = 0; p < 10; p++) {
                gs.particles.push({
                  x: t.x, y: t.y,
                  vx: (Math.random() - 0.5) * 8,
                  vy: -Math.random() * 5,
                  life: 30,
                  color: '#FFD54F'
                });
              }
              gs.targets.splice(i, 1);
              gs.arrowFlying = false;
              gs.arrowX = 100;
              gs.arrowY = H - 100;
              updateMinigameUI();
            }
          });
          
          // Reset if out of bounds
          if (gs.arrowX > W + 50 || gs.arrowY > H + 50 || gs.arrowY < -50 || gs.arrowX < -50) {
            gs.arrowFlying = false;
            gs.arrowX = 100;
            gs.arrowY = H - 100;
          }
        }
        
        // Deer targets (on right side, facing left toward archer)
        gs.targets.forEach(t => {
          t.x += t.dir * 0.8;
          t.frame++;
          if (t.x > W - 40 || t.x < W * 0.5) t.dir *= -1;
          drawDetailedDeer(t.x, t.y, 0.7, true, t.frame);
        });
        
        // Spawn new targets
        if (gs.targets.length < 2 && Math.random() < 0.015) {
          gs.targets.push({ x: W - 60, y: H - 60 - Math.random() * 50, dir: -1, frame: 0 });
        }
        
        // Particles
        gs.particles = gs.particles.filter(p => {
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.3;
          p.life--;
          ctx.fillStyle = p.color;
          ctx.globalAlpha = p.life / 30;
          ctx.beginPath();
          ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
          return p.life > 0;
        });
        
        // Aim guide line (faint)
        if (!gs.arrowFlying && gs.bowDrawn > 0.1) {
          ctx.strokeStyle = 'rgba(255,255,255,0.3)';
          ctx.setLineDash([5, 5]);
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(100, H - 85);
          const guideLen = 80;
          ctx.lineTo(100 + guideLen, H - 85 - gs.aimAngle * guideLen * 0.8);
          ctx.stroke();
          ctx.setLineDash([]);
        }
        
        requestAnimationFrame(draw);
      }
      draw();
    }

    // FISHING GAME - DETAILED GRAPHICS
    function initFishing(canvas, ctx, W, H) {
      const gs = state.gameState;
      gs.casting = false;
      gs.lineOut = false;
      gs.bobberX = 0;
      gs.bobberY = 0;
      gs.fishNear = false;
      gs.fishHooked = false;
      gs.reeling = false;
      gs.fishX = 0;
      gs.fishY = 0;
      gs.tension = 0;
      gs.hookWindow = 0;
      gs.ripples = [];
      gs.fish = [];
      gs.frame = 0;
      
      // Spawn some fish
      for (let i = 0; i < 4; i++) {
        gs.fish.push({
          x: 100 + Math.random() * (W - 150),
          y: H * 0.55 + Math.random() * 80,
          speed: 0.5 + Math.random() * 1,
          dir: Math.random() > 0.5 ? 1 : -1,
          type: Math.random() > 0.5 ? 'salmon' : 'trout',
          size: 0.6 + Math.random() * 0.4
        });
      }
      
      canvas.onclick = e => {
        if (!state.minigameActive) return;
        if (!gs.lineOut) {
          gs.lineOut = true;
          gs.bobberX = W * 0.55 + Math.random() * 80;
          gs.bobberY = H * 0.48;
          gs.fishNear = false;
          gs.hookWindow = 0;
          gs.ripples.push({ x: gs.bobberX, y: gs.bobberY, size: 5, alpha: 1 });
          setTimeout(() => {
            if (gs.lineOut && !gs.fishHooked) {
              gs.fishNear = true;
              gs.hookWindow = 90;
            }
          }, 1500 + Math.random() * 2000);
        } else if (gs.fishNear && gs.hookWindow > 0) {
          gs.fishHooked = true;
          gs.fishNear = false;
          gs.fishX = gs.bobberX;
          gs.fishY = gs.bobberY + 40;
          gs.reeling = true;
          gs.tension = 0.5;
        } else if (gs.fishHooked) {
          gs.tension = Math.min(1, gs.tension + 0.12);
        }
      };
      
      function drawDetailedFish(x, y, scale, type, dir) {
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(dir * scale, scale);
        
        const colors = type === 'salmon' ? 
          { body: '#E57373', belly: '#FFCDD2', fin: '#C62828', spots: '#B71C1C' } :
          { body: '#81C784', belly: '#C8E6C9', fin: '#388E3C', spots: '#1B5E20' };
        
        // Body
        ctx.fillStyle = colors.body;
        ctx.beginPath();
        ctx.ellipse(0, 0, 30, 14, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Gradient overlay
        const bodyGrad = ctx.createLinearGradient(0, -14, 0, 14);
        bodyGrad.addColorStop(0, 'rgba(255,255,255,0.3)');
        bodyGrad.addColorStop(0.5, 'rgba(255,255,255,0)');
        bodyGrad.addColorStop(1, 'rgba(0,0,0,0.2)');
        ctx.fillStyle = bodyGrad;
        ctx.beginPath();
        ctx.ellipse(0, 0, 30, 14, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Belly
        ctx.fillStyle = colors.belly;
        ctx.beginPath();
        ctx.ellipse(0, 6, 22, 6, 0, 0, Math.PI);
        ctx.fill();
        
        // Tail
        ctx.fillStyle = colors.fin;
        ctx.beginPath();
        ctx.moveTo(-30, 0);
        ctx.lineTo(-48, -18);
        ctx.quadraticCurveTo(-38, 0, -48, 18);
        ctx.closePath();
        ctx.fill();
        
        // Dorsal fin
        ctx.beginPath();
        ctx.moveTo(-5, -12);
        ctx.lineTo(0, -24);
        ctx.lineTo(12, -12);
        ctx.closePath();
        ctx.fill();
        
        // Pectoral fin
        ctx.beginPath();
        ctx.moveTo(5, 5);
        ctx.lineTo(15, 18);
        ctx.lineTo(-5, 10);
        ctx.closePath();
        ctx.fill();
        
        // Spots
        ctx.fillStyle = colors.spots;
        for (let i = 0; i < 5; i++) {
          ctx.beginPath();
          ctx.arc(-15 + i * 8, -3 + (i % 2) * 4, 2, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Eye
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(20, -3, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#1a1a1a';
        ctx.beginPath();
        ctx.arc(21, -3, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(20, -4, 1, 0, Math.PI * 2);
        ctx.fill();
        
        // Mouth
        ctx.strokeStyle = colors.spots;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(28, 2, 4, 0.5, Math.PI - 0.5);
        ctx.stroke();
        
        // Scales shimmer
        ctx.fillStyle = 'rgba(255,255,255,0.15)';
        for (let i = 0; i < 8; i++) {
          ctx.beginPath();
          ctx.arc(-20 + i * 6, 0, 4, 0, Math.PI * 2);
          ctx.fill();
        }
        
        ctx.restore();
      }
      
      function draw() {
        if (!state.minigameActive && !gs.fishHooked) return;
        gs.frame++;
        
        // Sky
        const skyGrad = ctx.createLinearGradient(0, 0, 0, H * 0.4);
        skyGrad.addColorStop(0, '#81D4FA');
        skyGrad.addColorStop(1, '#E1F5FE');
        ctx.fillStyle = skyGrad;
        ctx.fillRect(0, 0, W, H * 0.4);
        
        // Distant trees
        ctx.fillStyle = '#66BB6A';
        for (let i = 0; i < 6; i++) {
          ctx.beginPath();
          ctx.arc(W - 50 - i * 30, H * 0.35, 20, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Bank
        ctx.fillStyle = '#8D6E63';
        ctx.beginPath();
        ctx.moveTo(0, H * 0.35);
        ctx.quadraticCurveTo(W * 0.2, H * 0.32, W * 0.35, H * 0.45);
        ctx.lineTo(0, H);
        ctx.closePath();
        ctx.fill();
        
        // Grass on bank
        ctx.fillStyle = '#7CB342';
        ctx.beginPath();
        ctx.moveTo(0, H * 0.33);
        ctx.quadraticCurveTo(W * 0.15, H * 0.3, W * 0.3, H * 0.42);
        ctx.lineTo(0, H * 0.5);
        ctx.closePath();
        ctx.fill();
        
        // Water
        const waterGrad = ctx.createLinearGradient(0, H * 0.4, 0, H);
        waterGrad.addColorStop(0, '#4FC3F7');
        waterGrad.addColorStop(0.5, '#039BE5');
        waterGrad.addColorStop(1, '#01579B');
        ctx.fillStyle = waterGrad;
        ctx.fillRect(W * 0.3, H * 0.4, W * 0.7, H * 0.6);
        
        // Water surface shimmer
        ctx.fillStyle = 'rgba(255,255,255,0.1)';
        for (let i = 0; i < 10; i++) {
          const wx = W * 0.35 + i * 25 + Math.sin(gs.frame * 0.02 + i) * 5;
          ctx.beginPath();
          ctx.ellipse(wx, H * 0.42, 15, 3, 0, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Underwater fish
        gs.fish.forEach(f => {
          f.x += f.speed * f.dir;
          if (f.x > W - 30 || f.x < W * 0.35) f.dir *= -1;
          const swimY = f.y + Math.sin(gs.frame * 0.05 + f.x * 0.1) * 5;
          drawDetailedFish(f.x, swimY, f.size, f.type, f.dir);
        });
        
        // Fisher
        ctx.fillStyle = '#8D6E63';
        ctx.beginPath();
        ctx.ellipse(80, H * 0.45, 12, 18, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#C68642';
        ctx.beginPath();
        ctx.arc(80, H * 0.45 - 28, 11, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#2C1810';
        ctx.beginPath();
        ctx.arc(80, H * 0.45 - 32, 11, Math.PI, Math.PI * 2);
        ctx.fill();
        
        // Fishing rod
        ctx.strokeStyle = '#5D4037';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(95, H * 0.42);
        ctx.quadraticCurveTo(140, H * 0.25, 160, H * 0.3);
        ctx.stroke();
        
        // Rod tip
        ctx.strokeStyle = '#8D6E63';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(160, H * 0.3);
        ctx.lineTo(170, H * 0.28);
        ctx.stroke();
        
        // Fishing line
        if (gs.lineOut || gs.fishHooked) {
          ctx.strokeStyle = 'rgba(50,50,50,0.6)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(170, H * 0.28);
          ctx.quadraticCurveTo((170 + gs.bobberX) / 2, H * 0.35, gs.bobberX, gs.bobberY);
          ctx.stroke();
          
          // Bobber
          const bobble = gs.fishNear ? Math.sin(gs.frame * 0.3) * 8 : Math.sin(gs.frame * 0.05) * 2;
          
          // Bobber shadow in water
          ctx.fillStyle = 'rgba(0,0,0,0.2)';
          ctx.beginPath();
          ctx.ellipse(gs.bobberX + 3, gs.bobberY + bobble + 5, 8, 3, 0, 0, Math.PI * 2);
          ctx.fill();
          
          // Bobber
          ctx.fillStyle = '#fff';
          ctx.beginPath();
          ctx.ellipse(gs.bobberX, gs.bobberY + bobble - 4, 6, 6, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#F44336';
          ctx.beginPath();
          ctx.ellipse(gs.bobberX, gs.bobberY + bobble + 4, 6, 6, 0, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Ripples
        gs.ripples = gs.ripples.filter(r => {
          r.size += 1;
          r.alpha -= 0.02;
          ctx.strokeStyle = `rgba(255,255,255,${r.alpha})`;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.ellipse(r.x, r.y, r.size, r.size * 0.3, 0, 0, Math.PI * 2);
          ctx.stroke();
          return r.alpha > 0;
        });
        
        // Hook window indicator
        if (gs.fishNear && gs.hookWindow > 0) {
          gs.hookWindow--;
          
          // Exclamation
          ctx.fillStyle = '#FFD54F';
          ctx.font = 'bold 28px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('!', gs.bobberX, gs.bobberY - 30);
          
          // Splash effect
          if (gs.frame % 5 === 0) {
            gs.ripples.push({ x: gs.bobberX, y: gs.bobberY, size: 3, alpha: 0.8 });
          }
          
          if (gs.hookWindow <= 0) {
            gs.lineOut = false;
            gs.fishNear = false;
          }
        }
        
        // Hooked fish
        if (gs.fishHooked) {
          gs.tension -= 0.008;
          gs.fishX -= 1.5;
          gs.fishY -= 0.3;
          
          // Fish fighting
          const fightX = Math.sin(gs.frame * 0.2) * 10;
          drawDetailedFish(gs.fishX + fightX, gs.fishY, 0.8, 'salmon', -1);
          
          // Splash
          if (gs.frame % 8 === 0) {
            gs.ripples.push({ x: gs.fishX, y: H * 0.45, size: 5, alpha: 0.6 });
          }
          
          // Tension meter
          ctx.fillStyle = 'rgba(0,0,0,0.7)';
          ctx.fillRect(W - 35, 10, 25, 120);
          ctx.fillStyle = '#333';
          ctx.fillRect(W - 32, 13, 19, 114);
          
          const tensionColor = gs.tension > 0.8 ? '#F44336' : gs.tension > 0.5 ? '#FFC107' : '#4CAF50';
          ctx.fillStyle = tensionColor;
          ctx.fillRect(W - 32, 13 + (1 - gs.tension) * 114, 19, gs.tension * 114);
          
          ctx.fillStyle = '#fff';
          ctx.font = '8px sans-serif';
          ctx.textAlign = 'center';
          ctx.save();
          ctx.translate(W - 22, 70);
          ctx.rotate(-Math.PI / 2);
          ctx.fillText('TENSION', 0, 0);
          ctx.restore();
          
          if (gs.fishX < 120) {
            state.minigameScore += 150;
            gs.fishHooked = false;
            gs.lineOut = false;
            gs.reeling = false;
            updateMinigameUI();
          }
          if (gs.tension <= 0) {
            gs.fishHooked = false;
            gs.lineOut = false;
          }
        }
        
        // Instructions
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(8, H - 28, 150, 20);
        ctx.fillStyle = '#fff';
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'left';
        if (!gs.lineOut) ctx.fillText('üé£ Click to cast your line', 12, H - 13);
        else if (gs.fishHooked) ctx.fillText('üêü Click to reel in!', 12, H - 13);
        else ctx.fillText('‚è≥ Waiting for a bite...', 12, H - 13);
        
        requestAnimationFrame(draw);
      }
      draw();
    }

    // GRINDING GAME - DETAILED GRAPHICS
    function initGrinding(canvas, ctx, W, H) {
      const gs = state.gameState;
      gs.grinding = false;
      gs.lastY = 0;
      gs.direction = 0;
      gs.strokes = 0;
      gs.flour = 0;
      gs.pestleY = H/2;
      gs.particles = [];
      gs.frame = 0;
      
      canvas.onmousedown = canvas.ontouchstart = e => { gs.grinding = true; e.preventDefault(); };
      canvas.onmouseup = canvas.ontouchend = e => { gs.grinding = false; e.preventDefault(); };
      canvas.onmousemove = canvas.ontouchmove = e => {
        if (!gs.grinding || !state.minigameActive) return;
        const rect = canvas.getBoundingClientRect();
        const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
        const dir = y > gs.lastY ? 1 : -1;
        if (dir !== gs.direction && Math.abs(y - gs.lastY) > 5) {
          gs.direction = dir;
          gs.strokes++;
          if (gs.strokes % 2 === 0) {
            state.minigameScore += 10;
            gs.flour = Math.min(100, gs.flour + 3);
            // Add particles
            for (let i = 0; i < 5; i++) {
              gs.particles.push({
                x: W/2 + (Math.random() - 0.5) * 40,
                y: H/2 + 20,
                vx: (Math.random() - 0.5) * 3,
                vy: -Math.random() * 4 - 2,
                size: 2 + Math.random() * 3,
                life: 40,
                color: gs.flour > 70 ? '#F5F5DC' : '#D2B48C'
              });
            }
            updateMinigameUI();
          }
        }
        gs.lastY = y;
        gs.pestleY = Math.max(H/2 - 30, Math.min(H/2 + 40, y));
        e.preventDefault();
      };
      
      function draw() {
        if (!state.minigameActive) return;
        gs.frame++;
        
        // Background - outdoor scene
        const skyGrad = ctx.createLinearGradient(0, 0, 0, H * 0.5);
        skyGrad.addColorStop(0, '#87CEEB');
        skyGrad.addColorStop(1, '#E8F5E9');
        ctx.fillStyle = skyGrad;
        ctx.fillRect(0, 0, W, H);
        
        // Ground
        ctx.fillStyle = '#A1887F';
        ctx.fillRect(0, H * 0.65, W, H * 0.35);
        
        // Oak tree in background
        ctx.fillStyle = '#5D4037';
        ctx.fillRect(W - 60, H * 0.3, 20, H * 0.35);
        ctx.fillStyle = '#558B2F';
        ctx.beginPath();
        ctx.arc(W - 50, H * 0.25, 45, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#689F38';
        ctx.beginPath();
        ctx.arc(W - 70, H * 0.3, 35, 0, Math.PI * 2);
        ctx.arc(W - 30, H * 0.28, 30, 0, Math.PI * 2);
        ctx.fill();
        
        // Mortar base (large bedrock)
        ctx.fillStyle = '#757575';
        ctx.beginPath();
        ctx.ellipse(W/2, H * 0.68, 80, 25, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Mortar texture
        ctx.fillStyle = '#616161';
        for (let i = 0; i < 8; i++) {
          ctx.beginPath();
          ctx.ellipse(W/2 - 50 + i * 15, H * 0.68 + Math.random() * 10, 8, 4, 0, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Mortar bowl
        const mortarGrad = ctx.createRadialGradient(W/2, H/2 + 30, 10, W/2, H/2 + 30, 60);
        mortarGrad.addColorStop(0, '#9E9E9E');
        mortarGrad.addColorStop(0.7, '#757575');
        mortarGrad.addColorStop(1, '#616161');
        ctx.fillStyle = mortarGrad;
        
        ctx.beginPath();
        ctx.moveTo(W/2 - 55, H/2);
        ctx.quadraticCurveTo(W/2 - 65, H/2 + 50, W/2 - 40, H/2 + 70);
        ctx.lineTo(W/2 + 40, H/2 + 70);
        ctx.quadraticCurveTo(W/2 + 65, H/2 + 50, W/2 + 55, H/2);
        ctx.closePath();
        ctx.fill();
        
        // Inner bowl shadow
        ctx.fillStyle = '#424242';
        ctx.beginPath();
        ctx.ellipse(W/2, H/2 + 15, 42, 22, 0, 0, Math.PI);
        ctx.fill();
        
        // Contents (acorns ‚Üí flour)
        const contentsColor = `rgb(${Math.floor(210 - gs.flour * 0.7)}, ${Math.floor(180 - gs.flour * 0.3)}, ${Math.floor(140 - gs.flour * 0.2)})`;
        ctx.fillStyle = contentsColor;
        ctx.beginPath();
        ctx.ellipse(W/2, H/2 + 25, 38, 18, 0, 0, Math.PI);
        ctx.fill();
        
        // Acorn pieces (fade as flour increases)
        if (gs.flour < 80) {
          ctx.fillStyle = `rgba(139, 90, 43, ${1 - gs.flour/100})`;
          for (let i = 0; i < 6; i++) {
            ctx.beginPath();
            ctx.ellipse(W/2 - 25 + i * 10, H/2 + 20 + (i % 2) * 5, 6, 4, i * 0.5, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        
        // Pestle
        const py = gs.pestleY;
        
        // Pestle shadow
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.beginPath();
        ctx.ellipse(W/2 + 5, H/2 + 30, 18, 8, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Pestle stone
        const pestleGrad = ctx.createLinearGradient(W/2 - 15, 0, W/2 + 15, 0);
        pestleGrad.addColorStop(0, '#757575');
        pestleGrad.addColorStop(0.3, '#9E9E9E');
        pestleGrad.addColorStop(0.7, '#BDBDBD');
        pestleGrad.addColorStop(1, '#757575');
        ctx.fillStyle = pestleGrad;
        
        // Pestle head
        ctx.beginPath();
        ctx.ellipse(W/2, py, 16, 12, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Pestle shaft
        ctx.fillRect(W/2 - 10, py - 70, 20, 70);
        
        // Pestle top
        ctx.beginPath();
        ctx.ellipse(W/2, py - 70, 10, 5, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Pestle highlight
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.fillRect(W/2 - 3, py - 65, 6, 55);
        
        // Progress bar background
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(15, 15, 110, 24);
        
        // Progress bar
        const progressGrad = ctx.createLinearGradient(17, 0, 17 + gs.flour, 0);
        progressGrad.addColorStop(0, '#8D6E63');
        progressGrad.addColorStop(1, '#F5F5DC');
        ctx.fillStyle = progressGrad;
        ctx.fillRect(17, 17, gs.flour, 20);
        
        // Progress text
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 12px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText(`Flour: ${gs.flour}%`, 22, 32);
        
        // Particles
        gs.particles = gs.particles.filter(p => {
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.15;
          p.life--;
          ctx.fillStyle = p.color;
          ctx.globalAlpha = p.life / 40;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
          return p.life > 0;
        });
        
        // Instructions
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(W/2 - 85, H - 30, 170, 22);
        ctx.fillStyle = '#fff';
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('‚ÜïÔ∏è Move up & down to grind acorns!', W/2, H - 14);
        
        requestAnimationFrame(draw);
      }
      draw();
    }

    // WEAVING GAME - DETAILED GRAPHICS
    function initWeaving(canvas, ctx, W, H) {
      const gs = state.gameState;
      gs.pattern = [];
      gs.playerPattern = [];
      gs.showing = true;
      gs.showIndex = 0;
      gs.playerTurn = false;
      gs.playerIndex = 0;
      gs.frame = 0;
      gs.basketProgress = 0;
      gs.flash = -1;
      
      // Generate pattern
      for (let i = 0; i < 4; i++) {
        gs.pattern.push(Math.floor(Math.random() * 4));
      }
      
      const fiberColors = [
        { main: '#8D6E63', light: '#A1887F', name: 'Willow' },
        { main: '#D7CCC8', light: '#EFEBE9', name: 'Tule' },
        { main: '#5D4037', light: '#795548', name: 'Sedge' },
        { main: '#BCAAA4', light: '#D7CCC8', name: 'Rush' }
      ];
      
      const positions = [
        { x: W/2 - 65, y: H/2 - 50 },
        { x: W/2 + 65, y: H/2 - 50 },
        { x: W/2 - 65, y: H/2 + 50 },
        { x: W/2 + 65, y: H/2 + 50 }
      ];
      
      canvas.onclick = e => {
        if (!gs.playerTurn || !state.minigameActive) return;
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (W / rect.width);
        const y = (e.clientY - rect.top) * (H / rect.height);
        
        positions.forEach((p, i) => {
          if (Math.abs(x - p.x) < 50 && Math.abs(y - p.y) < 40) {
            gs.flash = i;
            setTimeout(() => gs.flash = -1, 200);
            
            gs.playerPattern.push(i);
            if (i === gs.pattern[gs.playerIndex]) {
              state.minigameScore += 25;
              gs.basketProgress = Math.min(100, gs.basketProgress + 5);
              gs.playerIndex++;
              updateMinigameUI();
              if (gs.playerIndex >= gs.pattern.length) {
                gs.pattern.push(Math.floor(Math.random() * 4));
                gs.playerPattern = [];
                gs.playerIndex = 0;
                gs.showing = true;
                gs.showIndex = 0;
                gs.playerTurn = false;
              }
            } else {
              gs.playerPattern = [];
              gs.playerIndex = 0;
              gs.showing = true;
              gs.showIndex = 0;
              gs.playerTurn = false;
            }
          }
        });
      };
      
      let showTimer = 0;
      function draw() {
        if (!state.minigameActive) return;
        gs.frame++;
        
        // Background
        ctx.fillStyle = '#4E342E';
        ctx.fillRect(0, 0, W, H);
        
        // Woven mat texture background
        ctx.strokeStyle = '#3E2723';
        ctx.lineWidth = 1;
        for (let i = 0; i < W; i += 15) {
          ctx.beginPath();
          ctx.moveTo(i, 0);
          ctx.lineTo(i, H);
          ctx.stroke();
        }
        for (let i = 0; i < H; i += 15) {
          ctx.beginPath();
          ctx.moveTo(0, i);
          ctx.lineTo(W, i);
          ctx.stroke();
        }
        
        // Title
        ctx.fillStyle = '#FFECB3';
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Weave the Pattern!', W/2, 25);
        
        // Fiber bundle options
        positions.forEach((p, i) => {
          const fiber = fiberColors[i];
          const highlight = (gs.showing && gs.pattern[gs.showIndex] === i) || gs.flash === i;
          
          // Bundle shadow
          ctx.fillStyle = 'rgba(0,0,0,0.3)';
          ctx.beginPath();
          ctx.ellipse(p.x + 3, p.y + 35, 42, 12, 0, 0, Math.PI * 2);
          ctx.fill();
          
          // Bundle container
          ctx.fillStyle = highlight ? '#FFD54F' : '#5D4037';
          ctx.strokeStyle = highlight ? '#FFC107' : '#3E2723';
          ctx.lineWidth = 3;
          ctx.beginPath();
          // Manual rounded rect for browser compatibility
          const rx = p.x - 45, ry = p.y - 30, rw = 90, rh = 60, radius = 10;
          ctx.moveTo(rx + radius, ry);
          ctx.lineTo(rx + rw - radius, ry);
          ctx.quadraticCurveTo(rx + rw, ry, rx + rw, ry + radius);
          ctx.lineTo(rx + rw, ry + rh - radius);
          ctx.quadraticCurveTo(rx + rw, ry + rh, rx + rw - radius, ry + rh);
          ctx.lineTo(rx + radius, ry + rh);
          ctx.quadraticCurveTo(rx, ry + rh, rx, ry + rh - radius);
          ctx.lineTo(rx, ry + radius);
          ctx.quadraticCurveTo(rx, ry, rx + radius, ry);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          
          // Fiber strands
          for (let j = 0; j < 8; j++) {
            const strand = j % 2 === 0 ? fiber.main : fiber.light;
            ctx.strokeStyle = strand;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(p.x - 35 + j * 9, p.y - 20);
            ctx.quadraticCurveTo(p.x - 35 + j * 9 + Math.sin(gs.frame * 0.02 + j) * 3, p.y, p.x - 35 + j * 9, p.y + 20);
            ctx.stroke();
          }
          
          // Label
          ctx.fillStyle = '#fff';
          ctx.font = '10px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText(fiber.name, p.x, p.y + 48);
        });
        
        // Show pattern
        if (gs.showing) {
          showTimer++;
          if (showTimer > 50) {
            showTimer = 0;
            gs.showIndex++;
            if (gs.showIndex >= gs.pattern.length) {
              gs.showing = false;
              gs.playerTurn = true;
            }
          }
        }
        
        // Basket progress (side panel)
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(W - 55, 40, 45, 180);
        
        // Basket visualization
        const basketLayers = Math.floor(gs.basketProgress / 10);
        for (let i = 0; i < basketLayers; i++) {
          ctx.strokeStyle = fiberColors[i % 4].main;
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.ellipse(W - 32, 200 - i * 15, 15 + i, 6, 0, 0, Math.PI * 2);
          ctx.stroke();
        }
        
        ctx.fillStyle = '#fff';
        ctx.font = '9px sans-serif';
        ctx.fillText(`${gs.basketProgress}%`, W - 32, 215);
        
        // Instructions
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(W/2 - 90, H - 35, 180, 25);
        ctx.fillStyle = '#FFD54F';
        ctx.font = '12px sans-serif';
        ctx.textAlign = 'center';
        if (gs.showing) {
          ctx.fillText(`üëÄ Watch... (${gs.showIndex + 1}/${gs.pattern.length})`, W/2, H - 18);
        } else {
          ctx.fillText(`üß∫ Your turn! (${gs.playerIndex}/${gs.pattern.length})`, W/2, H - 18);
        }
        
        requestAnimationFrame(draw);
      }
      draw();
    }

    // KNAPPING GAME - DETAILED GRAPHICS
    function initKnapping(canvas, ctx, W, H) {
      const gs = state.gameState;
      gs.chips = [];
      gs.sparks = [];
      gs.shape = 100;
      gs.hits = 0;
      gs.frame = 0;
      gs.obsidianPoints = [];
      gs.shapeQuality = 0;
      
      // Define target arrowhead shape
      const targetShape = [
        { x: 0, y: -50 },
        { x: 25, y: 30 },
        { x: 0, y: 15 },
        { x: -25, y: 30 }
      ];
      
      // Current rough obsidian shape (starts as irregular blob)
      gs.obsidianPoints = [
        { x: 0, y: -45, hit: false },
        { x: 30, y: -30, hit: false },
        { x: 40, y: 0, hit: false },
        { x: 35, y: 35, hit: false },
        { x: 10, y: 45, hit: false },
        { x: -10, y: 45, hit: false },
        { x: -35, y: 35, hit: false },
        { x: -40, y: 0, hit: false },
        { x: -30, y: -30, hit: false }
      ];
      
      canvas.onclick = e => {
        if (!state.minigameActive) return;
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (W / rect.width) - W/2;
        const y = (e.clientY - rect.top) * (H / rect.height) - H/2;
        
        // Find closest edge point
        let closest = null;
        let closestDist = Infinity;
        gs.obsidianPoints.forEach((p, i) => {
          if (p.hit) return;
          const dist = Math.hypot(x - p.x, y - p.y);
          if (dist < closestDist && dist < 30) {
            closest = i;
            closestDist = dist;
          }
        });
        
        if (closest !== null) {
          gs.hits++;
          const p = gs.obsidianPoints[closest];
          
          // Move point inward toward target shape
          const targetP = targetShape[Math.floor(closest / gs.obsidianPoints.length * targetShape.length)];
          p.x = p.x * 0.7 + targetP.x * 0.3;
          p.y = p.y * 0.7 + targetP.y * 0.3;
          
          // Add chip
          gs.chips.push({
            x: W/2 + p.x + (Math.random() - 0.5) * 20,
            y: H/2 + p.y + (Math.random() - 0.5) * 20,
            vx: (Math.random() - 0.5) * 5,
            vy: Math.random() * 3 + 2,
            rot: Math.random() * Math.PI * 2,
            size: 4 + Math.random() * 6,
            life: 60
          });
          
          // Add sparks
          for (let i = 0; i < 8; i++) {
            gs.sparks.push({
              x: W/2 + p.x,
              y: H/2 + p.y,
              vx: (Math.random() - 0.5) * 8,
              vy: -Math.random() * 6 - 2,
              life: 20 + Math.random() * 10
            });
          }
          
          state.minigameScore += 15;
          gs.shapeQuality = Math.min(100, gs.shapeQuality + 4);
          updateMinigameUI();
        }
      };
      
      function drawObsidian() {
        ctx.save();
        ctx.translate(W/2, H/2);
        
        // Draw target outline (faint)
        ctx.strokeStyle = 'rgba(255,255,255,0.15)';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(targetShape[0].x, targetShape[0].y);
        targetShape.forEach(p => ctx.lineTo(p.x, p.y));
        ctx.closePath();
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Draw current obsidian
        ctx.fillStyle = '#1a1a1a';
        ctx.beginPath();
        ctx.moveTo(gs.obsidianPoints[0].x, gs.obsidianPoints[0].y);
        gs.obsidianPoints.forEach(p => ctx.lineTo(p.x, p.y));
        ctx.closePath();
        ctx.fill();
        
        // Obsidian shine/reflection
        ctx.fillStyle = 'rgba(255,255,255,0.2)';
        ctx.beginPath();
        ctx.moveTo(-5, -30);
        ctx.lineTo(10, -35);
        ctx.lineTo(5, 0);
        ctx.lineTo(-10, -5);
        ctx.closePath();
        ctx.fill();
        
        // Edge highlights where not yet chipped
        gs.obsidianPoints.forEach((p, i) => {
          if (!p.hit) {
            ctx.fillStyle = 'rgba(100,100,100,0.5)';
            ctx.beginPath();
            ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
            ctx.fill();
          }
        });
        
        ctx.restore();
      }
      
      function draw() {
        if (!state.minigameActive) return;
        gs.frame++;
        
        // Background - work area
        ctx.fillStyle = '#A1887F';
        ctx.fillRect(0, 0, W, H);
        
        // Work surface texture
        ctx.fillStyle = '#8D6E63';
        for (let i = 0; i < 50; i++) {
          ctx.beginPath();
          ctx.ellipse(Math.random() * W, Math.random() * H, 5 + Math.random() * 10, 3 + Math.random() * 5, Math.random() * Math.PI, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Leather work pad
        ctx.fillStyle = '#6D4C41';
        ctx.beginPath();
        ctx.ellipse(W/2, H/2 + 20, 80, 60, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#5D4037';
        ctx.lineWidth = 3;
        ctx.stroke();
        
        // Draw obsidian
        drawObsidian();
        
        // Hammerstone (follows mouse slightly)
        const hammerX = W - 60;
        const hammerY = 60;
        
        ctx.fillStyle = '#757575';
        ctx.beginPath();
        ctx.ellipse(hammerX, hammerY, 20, 16, 0.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#9E9E9E';
        ctx.beginPath();
        ctx.ellipse(hammerX - 3, hammerY - 3, 8, 6, 0.2, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#fff';
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Hammerstone', hammerX, hammerY + 30);
        
        // Fallen chips
        gs.chips = gs.chips.filter(c => {
          c.x += c.vx;
          c.y += c.vy;
          c.vy += 0.2;
          c.rot += 0.1;
          c.life--;
          
          ctx.save();
          ctx.translate(c.x, c.y);
          ctx.rotate(c.rot);
          ctx.fillStyle = '#2d2d2d';
          ctx.beginPath();
          ctx.moveTo(-c.size/2, -c.size/3);
          ctx.lineTo(c.size/2, -c.size/4);
          ctx.lineTo(c.size/3, c.size/3);
          ctx.lineTo(-c.size/3, c.size/4);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
          
          return c.life > 0 && c.y < H + 20;
        });
        
        // Sparks
        gs.sparks = gs.sparks.filter(s => {
          s.x += s.vx;
          s.y += s.vy;
          s.vy += 0.3;
          s.life--;
          
          ctx.fillStyle = `rgba(255, ${180 + Math.random() * 75}, 0, ${s.life / 30})`;
          ctx.beginPath();
          ctx.arc(s.x, s.y, 2, 0, Math.PI * 2);
          ctx.fill();
          
          return s.life > 0;
        });
        
        // Progress indicator
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(10, 10, 120, 45);
        
        ctx.fillStyle = '#fff';
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText('Shape Quality:', 15, 26);
        
        ctx.fillStyle = '#333';
        ctx.fillRect(15, 32, 100, 15);
        ctx.fillStyle = gs.shapeQuality > 70 ? '#4CAF50' : gs.shapeQuality > 40 ? '#FFC107' : '#F44336';
        ctx.fillRect(15, 32, gs.shapeQuality, 15);
        
        // Instructions
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(W/2 - 100, H - 32, 200, 24);
        ctx.fillStyle = '#FFD54F';
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('ü™® Click edges to chip into arrowhead!', W/2, H - 15);
        
        requestAnimationFrame(draw);
      }
      draw();
    }

    // ============================================
    // RENDERING
    // ============================================
    function render() {
      const levelInfo = getLevelInfo(state.xp);
      const progress = levelInfo.nextLevel ? (levelInfo.xpProgress / levelInfo.xpForNext) * 100 : 100;
      
      document.getElementById('app').innerHTML = `
        <div class="header">
          <h1>‚ö±Ô∏è Artifact Hunter<span class="demo-badge">DEMO</span></h1>
          <div class="header-stats">
            <span class="level-badge">Lv.${levelInfo.level}</span>
            <div class="xp-bar-container"><div class="xp-bar" style="width:${progress}%"></div></div>
            <span>${state.xp} XP</span>
          </div>
        </div>
        <div class="instructions">üéÆ Use arrow keys to move ‚Ä¢ ${state.artifacts.length} artifacts nearby</div>
        <div id="map"></div>
        <div class="key-hint"><kbd>‚Üë</kbd><kbd>‚Üì</kbd><kbd>‚Üê</kbd><kbd>‚Üí</kbd> move ‚Ä¢ <kbd>Q</kbd> zoom in ‚Ä¢ <kbd>E</kbd> zoom out</div>
        <div class="bottom-nav">
          <button class="nav-btn" onclick="showCollection()">üìú Collection</button>
          <button class="nav-btn" onclick="showMinigames()">üéÆ Games</button>
          <button class="nav-btn" onclick="showAchievements()">üèÜ Badges</button>
        </div>
        ${state.cleaningArtifact ? renderCleaning() : ''}
        ${state.discoveryPending ? renderDiscovery() : ''}
        ${state.showingCutscene ? renderCutscene() : ''}
        ${state.foundArtifact ? renderFound() : ''}
        ${state.showLevelUp ? renderLevelUp() : ''}
        ${state.playingMinigame ? renderMinigame() : ''}
        ${state.showingModal === 'collection' ? renderCollectionModal() : ''}
        ${state.showingModal === 'minigames' ? renderMinigamesModal() : ''}
        ${state.showingModal === 'achievements' ? renderAchievementsModal() : ''}
      `;
      
      setTimeout(() => {
        const mapEl = document.getElementById('map');
        if (!state.map && mapEl && !state.cleaningArtifact && !state.discoveryPending && !state.showingCutscene && !state.foundArtifact && !state.showLevelUp && !state.playingMinigame && !state.showingModal) { 
          initMap(); 
          initArtifacts(); 
        }
        if (state.cleaningArtifact) {
          setupCleaning();
        }
      }, 50);
    }

    function renderExcavation() {
      const a = state.cleaningArtifact;
      const layers = [
        { name: 'Surface (Grass/Debris)', color: '#4a7c59', depth: '0-5cm' },
        { name: 'Topsoil (Dark Humus)', color: '#3d3428', depth: '5-15cm' },
        { name: 'Midden Layer (Artifact!)', color: '#5c4a3d', depth: '15-40cm' }
      ];
      
      const tools = [
        { id: 'trowel', icon: 'üî™', name: 'Trowel', desc: 'Dig through layers' },
        { id: 'brush', icon: 'üñåÔ∏è', name: 'Brush', desc: 'Fine detail work' },
        { id: 'screen', icon: 'üî≤', name: 'Screen', desc: 'Find small items' },
        { id: 'camera', icon: 'üì∑', name: 'Camera', desc: 'Document finds' }
      ];
      
      const phaseInfo = [
        { title: 'Clear Surface', instruction: 'Click and drag to excavate the grass and debris!' },
        { title: 'Excavate Topsoil', instruction: 'Keep digging through the dark soil layer...' },
        { title: 'Reveal Artifact', instruction: 'Artifact found! Carefully brush away the midden!' }
      ];
      
      const phase = state.excavationPhase || 1;
      const currentPhase = phaseInfo[phase - 1] || phaseInfo[0];
      
      const today = new Date();
      const dateStr = today.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
      
      return `<div class="excavation-overlay">
        <div class="excavation-header">
          <div class="excavation-phase">Phase ${phase} of 3</div>
          <div class="excavation-title">‚õèÔ∏è ${currentPhase.title}</div>
          <div class="excavation-instructions">${currentPhase.instruction}</div>
        </div>
        
        <div class="dig-site-container">
          <div class="dig-site">
            <div class="artifact-reveal ${state.excavationLayer >= 2 ? 'visible' : ''}">${a.emoji}</div>
            <canvas id="excavationCanvas" width="300" height="300"></canvas>
            <div class="grid-overlay ${phase >= 1 ? 'visible' : ''}"></div>
            <div class="unit-label" style="top:2px;left:2px">Unit A1</div>
            <div class="unit-label" style="top:2px;right:2px">N: 37.804¬∞</div>
            <div class="unit-label" style="bottom:2px;left:2px">Depth: ${(state.excavationLayer * 12 + state.excavationProgress * 0.12).toFixed(1)}cm</div>
          </div>
        </div>
        
        <div class="tool-belt">
          ${tools.map(t => `
            <button class="tool-btn ${state.selectedTool === t.id ? 'active' : ''} ${
              (t.id === 'brush' && state.excavationLayer < 2) || 
              (t.id === 'camera' && state.excavationLayer < 2) ||
              (t.id === 'screen' && state.excavationLayer < 1) ? 'disabled' : ''
            }" onclick="selectTool('${t.id}')" title="${t.desc}">
              <span class="tool-icon">${t.icon}</span>
              <span class="tool-name">${t.name}</span>
            </button>
          `).join('')}
        </div>
        
        <div class="stratigraphy-panel">
          <div class="strat-title">üìä Stratigraphy Profile</div>
          ${layers.map((l, i) => `
            <div class="layer-row ${state.excavationLayer === i ? 'active' : ''} ${state.excavationLayer > i ? 'complete' : ''}">
              <div class="layer-color" style="background:${l.color}"></div>
              <span class="layer-name">${l.name}${state.excavationLayer === i ? ' ‚Üê NOW' : ''}</span>
              <span class="layer-depth">${l.depth}</span>
            </div>
          `).join('')}
        </div>
        
        <div class="excavation-progress">
          <div class="progress-label">
            <span>Layer ${state.excavationLayer + 1} of 3</span>
            <span>${Math.round(state.excavationProgress)}%</span>
          </div>
          <div class="progress-bar-bg">
            <div class="progress-bar-fill" style="width:${state.excavationProgress}%"></div>
          </div>
        </div>
        
        <div class="field-journal">
          <div class="journal-header">
            <span class="journal-title">üìì Field Journal</span>
            <span class="journal-date">${dateStr}</span>
          </div>
          ${state.fieldNotes.length === 0 ? 
            '<div class="journal-entry" style="color:#888;font-style:italic">Begin excavation to record notes...</div>' :
            state.fieldNotes.slice(-4).map(note => `<div class="journal-entry">${note}</div>`).join('')
          }
        </div>
        
        <button class="nav-btn" style="margin-top:10px" onclick="cancelExcavation()">‚ùå Abandon Excavation</button>
      </div>`;
    }
    
    function renderDiscovery() {
      const a = state.discoveryPending;
      if (!a) return '';
      
      const ageYears = 200 + Math.floor(Math.random() * 800);
      const particles = Array(30).fill(0).map((_, i) => {
        const left = Math.random() * 100;
        const delay = Math.random() * 2;
        const size = 4 + Math.random() * 8;
        return `<div class="particle" style="left:${left}%;animation-delay:${delay}s;width:${size}px;height:${size}px;background:${Math.random() > 0.5 ? '#ffd700' : '#c9a227'}"></div>`;
      }).join('');
      
      return `<div class="discovery-overlay" id="discoveryOverlay">
        <div class="discovery-rays"></div>
        <div class="discovery-glow"></div>
        <div class="discovery-particles">${particles}</div>
        
        <div class="discovery-artifact">${a.emoji}</div>
        
        <div class="discovery-text">
          <div class="discovery-headline">‚ú® Archaeological Discovery ‚ú®</div>
          <div class="discovery-name">${a.name}</div>
          <div class="discovery-rarity rarity-${a.rarity}">${a.rarity}</div>
          <div class="discovery-age">Estimated age: ~${ageYears} years old</div>
          
          <div class="discovery-first">
            üëÅÔ∏è You are the first person to see this artifact in ${ageYears} years
          </div>
          
          <div class="discovery-stats">
            <div class="discovery-stat">
              <div class="discovery-stat-value">+${a.xpGained || a.xp}</div>
              <div class="discovery-stat-label">XP Earned</div>
            </div>
            <div class="discovery-stat">
              <div class="discovery-stat-value">${state.collection.length + 1}</div>
              <div class="discovery-stat-label">Total Finds</div>
            </div>
            <div class="discovery-stat">
              <div class="discovery-stat-value">A1</div>
              <div class="discovery-stat-label">Unit</div>
            </div>
          </div>
          
          <div class="discovery-quote">"${a.culturalNote}"</div>
        </div>
        
        <button class="discovery-continue" onclick="completeDiscovery()">
          üìú Add to Collection
        </button>
      </div>`;
    }

    function renderCleaning() {
      // Redirect to new excavation system
      return renderExcavation();
    }

    function renderCutscene() {
      const captions = {
        bow_hunt: 'The hunter draws back their bow, eyes fixed on the deer grazing in the meadow...',
        grinding: 'Day after day, the acorns are ground into flour to feed the village...',
        weaving: 'Patient hands weave willow and sedge into baskets that will last generations...',
        fishing: 'By the creek, a patient fisher waits for the salmon to bite...',
        ceremony: 'The village gathers as sacred songs fill the night air...',
        knapping: 'Sparks fly as obsidian is carefully shaped into razor-sharp tools...',
        trading: 'Shell beads change hands as tribes trade goods from across California...',
        gathering: 'Families work together to gather the autumn acorn harvest...',
        cooking: 'Hot stones drop into the basket, and the water begins to boil...',
        scraping: 'The hide is stretched and scraped clean for tanning...',
        chopping: 'The stone axe bites into wood as a new shelter takes shape...'
      };
      return `<div class="cutscene-overlay" onclick="endCutscene()">
        <div class="cutscene-title">üëÅÔ∏è Vision of the Past</div>
        <canvas id="cutsceneCanvas" width="380" height="280"></canvas>
        <div class="cutscene-caption">${captions[state.showingCutscene.cutscene] || state.showingCutscene.description}</div>
        <div class="cutscene-skip">Tap to continue...</div>
      </div>`;
    }

    function renderFound() {
      const a = state.foundArtifact;
      return `<div class="found-overlay" onclick="dismissFound()"><div class="emoji">${a.emoji}</div><h2>Collected!</h2><div class="artifact-name">${a.name}</div><div class="rarity-badge rarity-${a.rarity}">${a.rarity.toUpperCase()}</div><div class="xp-earned">+${a.xpGained} XP</div><p class="description">${a.description}</p><div class="cultural-note"><h4>üìö Did You Know?</h4><p>${a.culturalNote}</p></div>${a.minigame ? `<div class="minigame-unlock"><h4>üéÆ ${MINIGAMES[a.minigame].name} Unlocked!</h4></div>` : ''}<button class="nav-btn">Continue</button></div>`;
    }

    function renderLevelUp() {
      return `<div class="levelup-overlay" onclick="dismissLevelUp()"><h1>‚¨ÜÔ∏è LEVEL UP!</h1><div class="level-num">${state.newLevel.level}</div><div class="reward">${state.newLevel.title}</div><button class="nav-btn">Continue</button></div>`;
    }

    function renderMinigame() {
      const g = MINIGAMES[state.playingMinigame];
      return `<div class="minigame-overlay">
        <div class="minigame-header">
          <h2>${g.emoji} ${g.name}</h2>
          <p>${g.desc}</p>
        </div>
        <div class="minigame-score" id="mgScore">${state.minigameScore}</div>
        <div class="minigame-timer" id="mgTimer">${state.minigameActive ? `‚è±Ô∏è ${state.minigameTimer}s` : 'üèÅ Done!'}</div>
        <div class="game-canvas-container">
          <canvas id="gameCanvas" width="340" height="300"></canvas>
        </div>
        ${!state.minigameActive ? renderLeaderboard() : ''}
        <button class="nav-btn" style="margin-top:15px" onclick="exitMinigame()">${state.minigameActive ? '‚ùå Quit' : '‚úì Done'}</button>
      </div>`;
    }

    function renderLeaderboard() {
      const game = state.playingMinigame;
      const scores = [
        { name: 'OaklandKid', score: 850 },
        { name: 'ArtifactPro', score: 720 },
        { name: 'You', score: state.highScores[game] || 0, you: true },
        { name: 'Explorer', score: 400 }
      ].sort((a, b) => b.score - a.score);
      return `<div class="leaderboard"><h3>üèÜ Leaderboard</h3>${scores.map((s, i) => `<div class="leaderboard-entry ${s.you ? 'you' : ''}"><span class="leaderboard-rank">#${i+1}</span><span class="leaderboard-name">${s.name}</span><span class="leaderboard-score">${s.score}</span></div>`).join('')}</div>`;
    }

    function renderCollectionModal() {
      const collected = new Set(state.collection.map(a => a.name));
      return `<div class="modal-overlay" onclick="closeModal(event)"><div class="modal" onclick="event.stopPropagation()"><div class="modal-header"><h2>üìú Collection (${collected.size}/${ARTIFACT_TYPES.length})</h2><button class="close-btn" onclick="closeModal()">&times;</button></div><div class="modal-body"><div class="collection-grid">${ARTIFACT_TYPES.map(a => `<div class="artifact-card ${collected.has(a.name) ? '' : 'locked'}"><div class="emoji">${collected.has(a.name) ? a.emoji : '‚ùì'}</div><div class="name">${collected.has(a.name) ? a.name : '???'}</div><div class="rarity rarity-${a.rarity}">${a.rarity}</div></div>`).join('')}</div></div></div></div>`;
    }

    function renderMinigamesModal() {
      return `<div class="modal-overlay" onclick="closeModal(event)"><div class="modal" onclick="event.stopPropagation()"><div class="modal-header"><h2>üéÆ Mini-Games</h2><button class="close-btn" onclick="closeModal()">&times;</button></div><div class="modal-body"><p style="margin-bottom:16px;color:#aaa">Unlock games by finding artifacts!</p><div class="minigame-grid">${Object.entries(MINIGAMES).map(([id, g]) => {
        const unlocked = state.unlockedMinigames.includes(id);
        return `<div class="minigame-card ${unlocked ? '' : 'locked'}" onclick="${unlocked ? `playMinigame('${id}')` : ''}"><div class="emoji">${unlocked ? g.emoji : 'üîí'}</div><div class="name">${g.name}</div><div class="high-score">${unlocked ? 'Best: ' + (state.highScores[id] || 0) : 'Locked'}</div></div>`;
      }).join('')}</div></div></div></div>`;
    }

    function renderAchievementsModal() {
      const li = getLevelInfo(state.xp);
      return `<div class="modal-overlay" onclick="closeModal(event)"><div class="modal" onclick="event.stopPropagation()"><div class="modal-header"><h2>üèÜ Achievements</h2><button class="close-btn" onclick="closeModal()">&times;</button></div><div class="modal-body"><div class="stats-panel"><div class="stats-row"><span class="stats-label">Level</span><span class="stats-value">${li.level} - ${li.title}</span></div><div class="stats-row"><span class="stats-label">XP</span><span class="stats-value">${state.xp}</span></div><div class="stats-row"><span class="stats-label">Artifacts</span><span class="stats-value">${state.collection.length}</span></div></div><h3>Badges</h3><div class="achievements-grid">${ACHIEVEMENTS.map(a => `<div class="achievement-card ${state.unlockedAchievements.includes(a.id) ? 'unlocked' : 'locked'}"><div class="emoji">${state.unlockedAchievements.includes(a.id) ? a.emoji : 'üîí'}</div><div class="name">${a.name}</div><div class="desc">${a.desc}</div></div>`).join('')}</div><button class="nav-btn" style="width:100%;margin-top:16px" onclick="resetGame()">üóëÔ∏è Reset</button></div></div></div>`;
    }

    function setupCleaning() {
      // Redirect to new excavation system
      setupExcavation();
    }
    
    function setupExcavation() {
      const canvas = document.getElementById('excavationCanvas');
      if (!canvas || !state.cleaningArtifact) return;
      const ctx = canvas.getContext('2d');
      const W = canvas.width, H = canvas.height;
      
      // Initialize excavation state
      state.excavationPhase = 1;
      state.excavationLayer = 0;
      state.excavationProgress = 0;
      state.selectedTool = 'trowel';
      state.fieldNotes = [
        'üìç Unit A1 established',
        'üî™ Starting with trowel - clear the surface layer first!'
      ];
      
      let hasCompleted = false;
      let layerPixels = []; // Track cleared pixels per layer
      let artifactRevealed = 0;
      
      // Layer definitions with colors (3 layers total)
      const layers = [
        { colors: ['#4a7c59', '#3d6b4a', '#5a8c69', '#2d5a3a'], name: 'Surface Layer' },
        { colors: ['#3d3428', '#2d2418', '#4d4438', '#1d1408'], name: 'Topsoil' },
        { colors: ['#5c4a3d', '#6c5a4d', '#4c3a2d', '#7c6a5d'], name: 'Midden Layer' }
      ];
      
      // Draw ONLY the current layer (one layer at a time)
      function drawLayers() {
        ctx.clearRect(0, 0, W, H);
        
        const currentLayer = state.excavationLayer;
        
        // If we've finished all layers, show completed state
        if (currentLayer >= 3) {
          ctx.fillStyle = '#5c4a3d';
          ctx.fillRect(0, 0, W, H);
          return;
        }
        
        const layer = layers[currentLayer];
        
        // Fill base color for current layer
        ctx.fillStyle = layer.colors[0];
        ctx.fillRect(0, 0, W, H);
        
        // Add texture
        for (let i = 0; i < 200; i++) {
          ctx.fillStyle = layer.colors[Math.floor(Math.random() * layer.colors.length)];
          const px = Math.random() * W;
          const py = Math.random() * H;
          ctx.beginPath();
          ctx.arc(px, py, Math.random() * 12 + 4, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Add layer-specific details
        if (currentLayer === 0) {
          // Grass on surface
          ctx.strokeStyle = '#2d5a3a';
          ctx.lineWidth = 2;
          for (let g = 0; g < 60; g++) {
            const gx = Math.random() * W;
            const gy = Math.random() * H;
            ctx.beginPath();
            ctx.moveTo(gx, gy);
            ctx.lineTo(gx + (Math.random() - 0.5) * 8, gy - 8 - Math.random() * 12);
            ctx.stroke();
          }
          // Small rocks
          ctx.fillStyle = '#555';
          for (let r = 0; r < 15; r++) {
            ctx.beginPath();
            ctx.ellipse(Math.random() * W, Math.random() * H, Math.random() * 6 + 2, Math.random() * 4 + 2, Math.random() * Math.PI, 0, Math.PI * 2);
            ctx.fill();
          }
        } else if (currentLayer === 1) {
          // Roots in topsoil
          ctx.strokeStyle = '#5a4a3a';
          ctx.lineWidth = 2;
          for (let r = 0; r < 20; r++) {
            const rx = Math.random() * W;
            const ry = Math.random() * H;
            ctx.beginPath();
            ctx.moveTo(rx, ry);
            ctx.quadraticCurveTo(rx + Math.random() * 30, ry + Math.random() * 20, rx + Math.random() * 50, ry + Math.random() * 30);
            ctx.stroke();
          }
        } else if (currentLayer === 2) {
          // Shell fragments in midden
          ctx.fillStyle = '#e8e0d0';
          for (let s = 0; s < 30; s++) {
            ctx.beginPath();
            ctx.ellipse(
              Math.random() * W, 
              Math.random() * H,
              Math.random() * 10 + 4,
              Math.random() * 6 + 3,
              Math.random() * Math.PI,
              0, Math.PI * 2
            );
            ctx.fill();
          }
          // Small bone fragments
          ctx.fillStyle = '#d4c8b8';
          for (let b = 0; b < 15; b++) {
            ctx.fillRect(
              Math.random() * W,
              Math.random() * H,
              Math.random() * 18 + 6,
              Math.random() * 4 + 2
            );
          }
          // Charcoal flecks
          ctx.fillStyle = '#222';
          for (let c = 0; c < 20; c++) {
            ctx.beginPath();
            ctx.arc(Math.random() * W, Math.random() * H, Math.random() * 3 + 1, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        
        // Show artifact peeking through in midden layer only
        if (currentLayer === 2) {
          const revealDiv = document.querySelector('.artifact-reveal');
          if (revealDiv) revealDiv.classList.add('visible');
        }
      }
      
      drawLayers();
      
      // Set initial cursor for trowel
      canvas.style.cursor = 'url("data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'32\' height=\'32\'%3E%3Ctext y=\'24\' font-size=\'24\'%3Eüî™%3C/text%3E%3C/svg%3E") 16 16, crosshair';
      
      // Cleared areas map
      let clearedMap = new Array(Math.ceil(W/10)).fill(null).map(() => new Array(Math.ceil(H/10)).fill(0));
      
      function getPos(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = W / rect.width, scaleY = H / rect.height;
        const touch = e.touches ? e.touches[0] : e;
        return { x: (touch.clientX - rect.left) * scaleX, y: (touch.clientY - rect.top) * scaleY };
      }
      
      function dig(x, y) {
        if (hasCompleted) return;
        
        const tool = state.selectedTool;
        let radius = 25;
        let effectiveness = 1;
        
        if (tool === 'trowel') {
          radius = 30;
          effectiveness = 1.5;
        } else if (tool === 'brush') {
          if (state.excavationLayer < 2) return; // Brush only works on midden layer
          radius = 20;
          effectiveness = 0.8;
        } else if (tool === 'screen') {
          // Screen finds small items occasionally
          if (Math.random() < 0.02 && state.excavationLayer >= 1) {
            addFieldNote('üîç Found tiny shell bead fragment in screen!');
            updateJournalDisplay();
          }
          return;
        } else if (tool === 'camera') {
          // Camera documents
          addFieldNote('üì∑ Photo taken: Layer ' + (state.excavationLayer + 1) + ' at depth ' + (state.excavationLayer * 12).toFixed(0) + 'cm');
          updateJournalDisplay();
          return;
        }
        
        // Clear area
        ctx.globalCompositeOperation = 'destination-out';
        ctx.fillStyle = 'rgba(255,255,255,1)';
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalCompositeOperation = 'source-over';
        
        // Track cleared area
        const gridX = Math.floor(x / 10);
        const gridY = Math.floor(y / 10);
        if (gridX >= 0 && gridX < clearedMap.length && gridY >= 0 && gridY < clearedMap[0].length) {
          if (clearedMap[gridX][gridY] === 0) {
            clearedMap[gridX][gridY] = 1;
            state.excavationProgress += effectiveness * 0.5;
          }
        }
        
        // Update progress
        state.excavationProgress = Math.min(100, state.excavationProgress);
        
        // Update progress bar directly without re-rendering
        const progressFill = document.querySelector('.progress-bar-fill');
        const progressLabel = document.querySelector('.progress-label span:last-child');
        const layerLabel = document.querySelector('.progress-label span:first-child');
        const depthLabel = document.querySelector('.unit-label:last-of-type');
        
        if (progressFill) progressFill.style.width = state.excavationProgress + '%';
        if (progressLabel) progressLabel.textContent = Math.round(state.excavationProgress) + '%';
        if (layerLabel) layerLabel.textContent = 'Layer ' + (state.excavationLayer + 1) + ' of 3';
        
        // Calculate depth based on layer and progress within that layer
        const layerDepths = [5, 15, 40]; // cm at bottom of each layer
        const layerStarts = [0, 5, 15]; // cm at top of each layer
        const currentDepth = layerStarts[state.excavationLayer] + (state.excavationProgress / 100) * (layerDepths[state.excavationLayer] - layerStarts[state.excavationLayer]);
        if (depthLabel) depthLabel.textContent = 'Depth: ' + currentDepth.toFixed(1) + 'cm';
        
        // Check layer completion
        if (state.excavationProgress >= 95) {
          advanceLayer();
        }
      }
      
      function updateJournalDisplay() {
        const journal = document.querySelector('.field-journal');
        if (!journal) return;
        
        const today = new Date();
        const dateStr = today.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
        
        const entries = state.fieldNotes.length === 0 
          ? '<div class="journal-entry" style="color:#888;font-style:italic">Begin excavation to record notes...</div>'
          : state.fieldNotes.slice(-4).map(note => `<div class="journal-entry">${note}</div>`).join('');
        
        journal.innerHTML = `
          <div class="journal-header">
            <span class="journal-title">üìì Field Journal</span>
            <span class="journal-date">${dateStr}</span>
          </div>
          ${entries}
        `;
      }
      
      function updateLayerDisplay() {
        const rows = document.querySelectorAll('.layer-row');
        rows.forEach((row, i) => {
          row.classList.remove('active', 'complete');
          if (i === state.excavationLayer) row.classList.add('active');
          if (i < state.excavationLayer) row.classList.add('complete');
        });
      }
      
      function advanceLayer() {
        const previousLayer = state.excavationLayer;
        state.excavationLayer++;
        state.excavationProgress = 0;
        clearedMap = new Array(Math.ceil(W/10)).fill(null).map(() => new Array(Math.ceil(H/10)).fill(0));
        
        const layerNames = ['Surface', 'Topsoil', 'Midden Layer'];
        
        // Check if we just completed the midden layer (layer 2) - that's where artifacts are!
        if (previousLayer === 2) {
          hasCompleted = true;
          addFieldNote('üéâ ARTIFACT FULLY EXCAVATED!');
          triggerDiscovery();
          return;
        }
        
        // Still have layers to go
        if (state.excavationLayer < 3) {
          addFieldNote('‚¨áÔ∏è Layer complete! Now excavating: ' + layerNames[state.excavationLayer]);
          state.excavationPhase = state.excavationLayer + 1;
          drawLayers();
          updateLayerDisplay();
          updateJournalDisplay();
          
          // Update phase text
          const phaseEl = document.querySelector('.excavation-phase');
          const titleEl = document.querySelector('.excavation-title');
          const instrEl = document.querySelector('.excavation-instructions');
          if (phaseEl) phaseEl.textContent = 'Phase ' + state.excavationPhase + ' of 3';
          if (titleEl) {
            const titles = ['Clear Surface', 'Excavate Topsoil', 'Reveal Artifact'];
            titleEl.textContent = '‚õèÔ∏è ' + (titles[state.excavationPhase - 1] || titles[0]);
          }
          if (instrEl) {
            const instructions = [
              'Click and drag to excavate the grass and debris!',
              'Keep digging through the dark soil layer...',
              'Artifact found! Carefully brush away the midden!'
            ];
            instrEl.textContent = instructions[state.excavationPhase - 1] || instructions[0];
          }
        }
        
        // Entering midden layer - artifact is here!
        if (state.excavationLayer === 2) {
          addFieldNote('‚ö†Ô∏è ARTIFACT DETECTED in midden layer!');
          addFieldNote('üí° Tip: Switch to brush for careful excavation');
          state.selectedTool = 'brush';
          state.excavationPhase = 3;
          updateJournalDisplay();
          
          // Update tool selection visually
          document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.classList.remove('active', 'disabled');
            if (btn.getAttribute('onclick')?.includes('brush')) {
              btn.classList.add('active');
            }
          });
          
          // Update cursor to brush
          const canvas = document.getElementById('excavationCanvas');
          if (canvas) {
            canvas.style.cursor = 'url("data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'32\' height=\'32\'%3E%3Ctext y=\'24\' font-size=\'24\'%3EüñåÔ∏è%3C/text%3E%3C/svg%3E") 16 16, crosshair';
          }
          
          // Show artifact peeking through
          const artifactReveal = document.querySelector('.artifact-reveal');
          if (artifactReveal) artifactReveal.classList.add('visible');
        }
      }
      
      function addFieldNote(note) {
        state.fieldNotes.push(note);
        if (state.fieldNotes.length > 10) state.fieldNotes.shift();
      }
      
      let isDigging = false;
      let lastX = 0, lastY = 0;
      let digInterval = null;
      
      function startDig(e) {
        isDigging = true;
        const p = getPos(e);
        lastX = p.x;
        lastY = p.y;
        
        // Dig immediately on click
        dig(p.x, p.y);
        dig(p.x + 5, p.y);
        dig(p.x - 5, p.y);
        dig(p.x, p.y + 5);
        dig(p.x, p.y - 5);
        
        // Continue digging while holding
        if (digInterval) clearInterval(digInterval);
        digInterval = setInterval(() => {
          if (isDigging && !hasCompleted) {
            dig(lastX + (Math.random() - 0.5) * 20, lastY + (Math.random() - 0.5) * 20);
          }
        }, 50);
        
        e.preventDefault();
      }
      
      function moveDig(e) {
        if (!isDigging || hasCompleted) return;
        const p = getPos(e);
        
        // Interpolate for smooth digging
        const dist = Math.hypot(p.x - lastX, p.y - lastY);
        const steps = Math.max(1, Math.floor(dist / 8));
        for (let i = 1; i <= steps; i++) {
          dig(lastX + (p.x - lastX) * i / steps, lastY + (p.y - lastY) * i / steps);
        }
        
        lastX = p.x;
        lastY = p.y;
        e.preventDefault();
      }
      
      function endDig() {
        isDigging = false;
        if (digInterval) {
          clearInterval(digInterval);
          digInterval = null;
        }
      }
      
      canvas.addEventListener('mousedown', startDig);
      canvas.addEventListener('mousemove', moveDig);
      canvas.addEventListener('mouseup', endDig);
      canvas.addEventListener('mouseleave', endDig);
      canvas.addEventListener('touchstart', startDig);
      canvas.addEventListener('touchmove', moveDig);
      canvas.addEventListener('touchend', endDig);
    }
    
    window.selectTool = function(toolId) {
      // Check if tool is allowed
      if (toolId === 'brush' && state.excavationLayer < 2) return;
      if (toolId === 'camera' && state.excavationLayer < 2) return;
      if (toolId === 'screen' && state.excavationLayer < 1) return;
      
      state.selectedTool = toolId;
      
      // Update tool buttons visually without re-rendering
      document.querySelectorAll('.tool-btn').forEach(btn => {
        btn.classList.remove('active');
        if (btn.getAttribute('onclick')?.includes(toolId)) {
          btn.classList.add('active');
        }
      });
      
      // Update cursor based on tool
      const canvas = document.getElementById('excavationCanvas');
      if (canvas) {
        if (toolId === 'trowel') {
          canvas.style.cursor = 'url("data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'32\' height=\'32\'%3E%3Ctext y=\'24\' font-size=\'24\'%3Eüî™%3C/text%3E%3C/svg%3E") 16 16, crosshair';
        } else if (toolId === 'brush') {
          canvas.style.cursor = 'url("data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'32\' height=\'32\'%3E%3Ctext y=\'24\' font-size=\'24\'%3EüñåÔ∏è%3C/text%3E%3C/svg%3E") 16 16, crosshair';
        } else {
          canvas.style.cursor = 'crosshair';
        }
      }
      
      // Add field note
      const toolNames = { trowel: 'Trowel', brush: 'Brush', screen: 'Screen', camera: 'Camera' };
      state.fieldNotes.push('üîß Switched to ' + toolNames[toolId]);
      
      // Update journal without full re-render
      const journalEntries = document.querySelectorAll('.journal-entry');
      if (journalEntries.length > 0) {
        const journal = document.querySelector('.field-journal');
        if (journal) {
          const header = journal.querySelector('.journal-header');
          if (header) {
            const entries = state.fieldNotes.slice(-4).map(note => `<div class="journal-entry">${note}</div>`).join('');
            journal.innerHTML = header.outerHTML + entries;
          }
        }
      }
    };
    
    window.cancelExcavation = function() {
      state.cleaningArtifact = null;
      state.excavationPhase = 0;
      state.excavationLayer = 0;
      state.excavationProgress = 0;
      state.fieldNotes = [];
      render();
    };
    
    function triggerDiscovery() {
      const artifact = state.cleaningArtifact;
      
      // Add screen flash effect
      const flash = document.createElement('div');
      flash.className = 'screen-flash';
      document.body.appendChild(flash);
      setTimeout(() => flash.remove(), 600);
      
      // Add screen shake
      document.body.classList.add('screen-shake');
      setTimeout(() => document.body.classList.remove('screen-shake'), 600);
      
      // Prepare discovery data
      const xpGained = Math.round(artifact.xp * (1 + Math.random() * 0.5));
      state.discoveryPending = { ...artifact, xpGained };
      
      // Clear cleaning state and show discovery
      state.cleaningArtifact = null;
      state.excavationPhase = 0;
      
      render();
    }
    
    window.completeDiscovery = function() {
      const artifact = state.discoveryPending;
      if (!artifact) return;
      
      // Add to collection
      state.collection.push({ ...artifact, collectedAt: new Date().toISOString() });
      
      // Award XP
      const oldLevel = getLevelInfo(state.xp);
      state.xp += artifact.xpGained;
      const newLevel = getLevelInfo(state.xp);
      
      // Check level up
      if (newLevel.level > oldLevel.level) {
        state.showLevelUp = true;
        state.newLevel = newLevel;
      }
      
      // Unlock minigame if applicable
      if (artifact.minigame && !state.unlockedMinigames.includes(artifact.minigame)) {
        state.unlockedMinigames.push(artifact.minigame);
      }
      
      // Remove artifact from map
      state.artifacts = state.artifacts.filter(a => 
        !(a.lat === artifact.lat && a.lon === artifact.lon)
      );
      
      // Check achievements
      checkAchievements();
      
      // Spawn replacement
      state.artifacts.push(spawnArtifactNear(state.playerPos.lat, state.playerPos.lon));
      
      // Save game
      saveGame();
      
      // Clear discovery and show cutscene
      state.discoveryPending = null;
      
      // Show cutscene for the artifact
      showCutscene({ ...artifact, xpGained: artifact.xpGained });
      
      updateArtifactMarkers();
    };

    // ============================================
    // ACTIONS
    // ============================================
    window.showCollection = () => { state.showingModal = 'collection'; render(); };
    window.showMinigames = () => { state.showingModal = 'minigames'; render(); };
    window.showAchievements = () => { state.showingModal = 'achievements'; render(); };
    window.closeModal = e => { if (!e || e.target.classList.contains('modal-overlay')) { state.showingModal = null; if (state.map) { state.map.remove(); state.map = null; } render(); } };
    window.dismissFound = () => { 
      state.foundArtifact = null; 
      if (state.map) { 
        state.map.remove(); 
        state.map = null; 
      } 
      render(); 
      // After render, the map will be reinitialized via setTimeout in render()
      // We need to update artifact markers after map is ready
      setTimeout(() => {
        if (state.map) {
          updateArtifactMarkers();
        }
      }, 200);
    };
    window.dismissLevelUp = () => { state.showLevelUp = false; state.newLevel = null; render(); };
    window.endCutscene = () => { if (window.currentCutsceneAnimation) cancelAnimationFrame(window.currentCutsceneAnimation); completeCutscene(); };
    window.playMinigame = id => { state.showingModal = null; if (state.map) { state.map.remove(); state.map = null; } startMinigame(id); };
    window.exitMinigame = () => { state.playingMinigame = null; state.minigameActive = false; if (state.map) { state.map.remove(); state.map = null; } render(); };
    window.resetGame = () => { if (confirm('Reset?')) { state.collection = []; state.xp = 0; state.unlockedAchievements = []; state.unlockedMinigames = []; state.highScores = {}; saveGame(); closeModal(); } };

    // ============================================
    // INIT
    // ============================================
    function init() {
      if (typeof L === 'undefined') { setTimeout(init, 100); return; }
      loadGame();
      checkAchievements();
      render();
    }
    if (document.readyState === 'complete') init();
    else window.addEventListener('load', init);
  </script>
</body>
</html>
